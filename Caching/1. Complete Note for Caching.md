# Laravel Caching: Complete Tutorial

## Introduction

Laravel caching allows you to store frequently accessed data in fast storage systems like Redis or Memcached. This tutorial will show you how to implement caching for articles where users always get updated data, and the cache automatically refreshes when articles are created, updated, or deleted.

## Step 1: Configure Cache Driver

### Update your `.env` file:
```env
CACHE_DRIVER=redis
REDIS_HOST=127.0.0.1
REDIS_PASSWORD=null
REDIS_PORT=6379
```

### Install Redis package:
```bash
composer require predis/predis
```

### Configure `config/cache.php`:
```php
'default' => env('CACHE_DRIVER', 'redis'),

'stores' => [
    'redis' => [
        'driver' => 'redis',
        'connection' => 'cache',
        'lock_connection' => 'default',
    ],
    // ... other stores
],
```

**Why Redis/Memcached?** These are memory-based storage systems that are much faster than file-based caching.

## Step 2: Basic Caching Operations

### Retrieve data from cache:
```php
use Illuminate\Support\Facades\Cache;

// Get value from cache
$value = Cache::get('key');

// Get with default value
$value = Cache::get('key', 'default_value');

// Get with closure as default
$articles = Cache::get('articles', function() {
    return Article::with('user', 'category')->get();
});
```

### Check if data exists in cache:
```php
if (Cache::has('articles')) {
    $articles = Cache::get('articles');
} else {
    // Fetch from database and cache it
}
```

### Store data with expiration:
```php
// Store for 60 minutes
Cache::remember('articles', 60, function() {
    return Article::with('user', 'category')
                 ->orderBy('created_at', 'desc')
                 ->take(20)
                 ->get();
});
```

### Store data permanently:
```php
Cache::rememberForever('articles', function() {
    return Article::with('user', 'category')->get();
});
```

### Other useful methods:
```php
// Store data
Cache::put('key', $value, 60); // 60 minutes

// Add data only if key doesn't exist
Cache::add('key', $value, 60);

// Store forever
Cache::forever('key', $value);

// Retrieve and delete
$value = Cache::pull('key');

// Delete specific key
Cache::forget('key');

// Clear all cache
Cache::flush();
```

### Helper methods:
```php
// Short syntax for getting cache
$value = cache('key');

// Get with default closure
$value = cache('key', function() {
    return expensive_operation();
});

// Store with helper
cache(['key' => 'value'], 60); // 60 minutes
```

## Step 3: Create Article Model with Events

### Update your Article model:
```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use App\Events\ArticleCreated;
use App\Events\ArticleUpdated;
use App\Events\ArticleDeleted;

class Article extends Model
{
    protected $fillable = ['title', 'content', 'user_id', 'category_id'];

    // Dispatch events automatically
    protected $dispatchesEvents = [
        'created' => ArticleCreated::class,
        'updated' => ArticleUpdated::class,
        'deleted' => ArticleDeleted::class,
    ];

    // Relationships
    public function user()
    {
        return $this->belongsTo(User::class);
    }

    public function category()
    {
        return $this->belongsTo(Category::class);
    }
}
```

## Step 4: Create Events

### Generate events:
```bash
php artisan make:event ArticleCreated
php artisan make:event ArticleUpdated
php artisan make:event ArticleDeleted
```

### Example ArticleCreated event:
```php
<?php

namespace App\Events;

use App\Models\Article;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Queue\SerializesModels;

class ArticleCreated
{
    use Dispatchable, SerializesModels;

    public $article;

    public function __construct(Article $article)
    {
        $this->article = $article;
    }
}
```

**Note:** Create similar events for `ArticleUpdated` and `ArticleDeleted`.

## Step 5: Create Cache Listener

### Generate listener:
```bash
php artisan make:listener ArticleCacheListener
```

### Implement the listener:
```php
<?php

namespace App\Listeners;

use Illuminate\Support\Facades\Cache;
use App\Models\Article;
use Illuminate\Support\Facades\Log;

class ArticleCacheListener
{
    public function handle($event)
    {
        // Clear the existing cache
        Cache::forget('articles');
        
        // Refresh cache with updated data
        $articles = Article::with('user', 'category')
                          ->orderBy('created_at', 'desc')
                          ->take(20)
                          ->get();
        
        Cache::forever('articles', $articles);
        
        // Log for debugging
        Log::info('Articles cache refreshed', [
            'count' => $articles->count(),
            'triggered_by' => class_basename($event)
        ]);
    }
}
```

## Step 6: Register Events and Listeners

### Update `app/Providers/EventServiceProvider.php`:
```php
<?php

namespace App\Providers;

use Illuminate\Foundation\Support\Providers\EventServiceProvider as ServiceProvider;
use App\Events\ArticleCreated;
use App\Events\ArticleUpdated;
use App\Events\ArticleDeleted;
use App\Listeners\ArticleCacheListener;

class EventServiceProvider extends ServiceProvider
{
    protected $listen = [
        ArticleCreated::class => [
            ArticleCacheListener::class,
        ],
        ArticleUpdated::class => [
            ArticleCacheListener::class,
        ],
        ArticleDeleted::class => [
            ArticleCacheListener::class,
        ],
    ];

    public function boot()
    {
        //
    }
}
```

## Step 7: Implement in Controller

### ArticleController example:
```php
<?php

namespace App\Http\Controllers;

use App\Models\Article;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Cache;

class ArticleController extends Controller
{
    public function index()
    {
        // Always get from cache, cache is automatically updated via events
        $articles = Cache::rememberForever('articles', function() {
            return Article::with('user', 'category')
                          ->orderBy('created_at', 'desc')
                          ->take(20)
                          ->get();
        });

        return view('articles.index', compact('articles'));
    }

    public function show(Article $article)
    {
        // Cache individual articles
        $cachedArticle = Cache::remember("article.{$article->id}", 60, function() use ($article) {
            return $article->load('user', 'category');
        });

        return view('articles.show', compact('cachedArticle'));
    }

    public function store(Request $request)
    {
        $request->validate([
            'title' => 'required|max:255',
            'content' => 'required',
            'category_id' => 'required|exists:categories,id'
        ]);

        // Create article - this will automatically trigger cache refresh
        Article::create([
            'title' => $request->title,
            'content' => $request->content,
            'category_id' => $request->category_id,
            'user_id' => auth()->id(),
        ]);

        return redirect()->route('articles.index')->with('success', 'Article created successfully!');
    }

    public function update(Request $request, Article $article)
    {
        $request->validate([
            'title' => 'required|max:255',
            'content' => 'required',
            'category_id' => 'required|exists:categories,id'
        ]);

        // Update article - this will automatically trigger cache refresh
        $article->update($request->only(['title', 'content', 'category_id']));

        // Clear individual article cache
        Cache::forget("article.{$article->id}");

        return redirect()->route('articles.show', $article)->with('success', 'Article updated successfully!');
    }

    public function destroy(Article $article)
    {
        // Delete article - this will automatically trigger cache refresh
        $article->delete();

        // Clear individual article cache
        Cache::forget("article.{$article->id}");

        return redirect()->route('articles.index')->with('success', 'Article deleted successfully!');
    }
}
```

## Step 8: Advanced Caching Strategies

### Cache Tags (for Redis/Memcached):
```php
// Store with tags
Cache::tags(['articles', 'posts'])->put('article.1', $article, 60);

// Flush all cached items with specific tag
Cache::tags(['articles'])->flush();
```

### Cache with different keys for different scenarios:
```php
class ArticleService
{
    public function getLatestArticles($limit = 20)
    {
        return Cache::remember("articles.latest.{$limit}", 60, function() use ($limit) {
            return Article::with('user', 'category')
                          ->orderBy('created_at', 'desc')
                          ->take($limit)
                          ->get();
        });
    }

    public function getArticlesByCategory($categoryId)
    {
        return Cache::remember("articles.category.{$categoryId}", 60, function() use ($categoryId) {
            return Article::with('user', 'category')
                          ->where('category_id', $categoryId)
                          ->orderBy('created_at', 'desc')
                          ->get();
        });
    }
}
```

## Best Practices

### 1. Use descriptive cache keys:
```php
// Good
Cache::remember('articles.latest.20', 60, $callback);
Cache::remember("user.{$userId}.profile", 60, $callback);

// Bad
Cache::remember('data', 60, $callback);
Cache::remember('stuff', 60, $callback);
```

### 2. Set appropriate expiration times:
```php
// Frequently changing data - short cache
Cache::remember('live.stock.prices', 1, $callback); // 1 minute

// Rarely changing data - longer cache
Cache::remember('site.settings', 1440, $callback); // 24 hours

// Static data - forever (until manually cleared)
Cache::rememberForever('countries.list', $callback);
```

### 3. Handle cache failures gracefully:
```php
try {
    $articles = Cache::remember('articles', 60, function() {
        return Article::latest()->take(20)->get();
    });
} catch (\Exception $e) {
    // Fallback to database if cache fails
    Log::error('Cache error: ' . $e->getMessage());
    $articles = Article::latest()->take(20)->get();
}
```

### 4. Use cache for expensive operations:
```php
// Cache complex queries
$stats = Cache::remember('dashboard.stats', 60, function() {
    return [
        'total_articles' => Article::count(),
        'published_articles' => Article::where('status', 'published')->count(),
        'total_users' => User::count(),
        'popular_articles' => Article::withCount('views')
                                   ->orderBy('views_count', 'desc')
                                   ->take(5)
                                   ->get()
    ];
});
```

## Testing Your Cache Implementation

### Check if cache is working:
```php
// In tinker or a test route
php artisan tinker

// Test cache operations
Cache::put('test', 'Hello World', 60);
$value = Cache::get('test'); // Should return "Hello World"
Cache::forget('test');
$value = Cache::get('test'); // Should return null
```

### Monitor cache in logs:
Check your `storage/logs/laravel.log` for the cache refresh messages from the listener.

## Conclusion

This caching implementation ensures that:
- Users always get fast responses from cache
- Cache is automatically updated when articles are created, updated, or deleted
- The system gracefully handles cache failures
- You have full control over what gets cached and for how long

Your articles will now be served from cache, providing faster page loads while always showing the most up-to-date content!
