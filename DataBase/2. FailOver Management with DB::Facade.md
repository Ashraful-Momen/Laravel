# Laravel DB Facade Guide with Failover Management

Yes, with Laravel's `DB` facade (part of the Query Builder), **you can perform almost anything** related to raw SQL operations, including:

---

### ‚úÖ 1. **Database Connection & Failover Management**

#### Basic Connection:
```php
DB::connection()->getPdo(); // Get PDO instance
DB::connection('mysql')->select(...); // Use named connection
```

#### Failover with 2 Backup Connections:
```php
// config/database.php
'mysql' => [
    'driver' => 'mysql',
    'host' => env('DB_HOST', '127.0.0.1'),
    'database' => env('DB_DATABASE', 'forge'),
    'username' => env('DB_USERNAME', 'forge'),
    'password' => env('DB_PASSWORD', ''),
    // Add failover hosts
    'read' => [
        'host' => [
            env('DB_READ_HOST_1', '192.168.1.1'), // Primary read
            env('DB_READ_HOST_2', '192.168.1.2'), // Backup 1
            env('DB_READ_HOST_3', '192.168.1.3'), // Backup 2
        ],
    ],
    'write' => [
        'host' => [
            env('DB_WRITE_HOST_1', '192.168.1.1'), // Primary write
            env('DB_WRITE_HOST_2', '192.168.1.2'), // Backup 1
            env('DB_WRITE_HOST_3', '192.168.1.3'), // Backup 2
        ],
    ],
    'sticky' => true, // Optional: Use same connection for reads after writes
],
```

#### Manual Failover Implementation:
```php
use Illuminate\Support\Facades\DB;
use Illuminate\Database\QueryException;

class DatabaseFailoverService
{
    protected $connections = ['primary', 'backup1', 'backup2'];
    
    public function executeWithFailover($callback)
    {
        foreach ($this->connections as $connection) {
            try {
                // Attempt to use the connection
                DB::connection($connection)->getPdo();
                
                // Execute the callback with this connection
                return $callback(DB::connection($connection));
                
            } catch (QueryException $e) {
                \Log::warning("Connection {$connection} failed: " . $e->getMessage());
                
                // If this was the last connection, throw the exception
                if ($connection === end($this->connections)) {
                    throw new \Exception('All database connections failed');
                }
                // Otherwise, continue to next connection
            }
        }
    }
}

// Usage:
$failover = new DatabaseFailoverService();
$result = $failover->executeWithFailover(function($db) {
    return $db->table('users')->get();
});
```

#### Connection Health Check:
```php
class DatabaseHealthCheck
{
    public static function checkConnections()
    {
        $connections = ['primary', 'backup1', 'backup2'];
        $status = [];
        
        foreach ($connections as $conn) {
            try {
                DB::connection($conn)->getPdo();
                DB::connection($conn)->select('SELECT 1');
                $status[$conn] = 'healthy';
            } catch (\Exception $e) {
                $status[$conn] = 'down';
            }
        }
        
        return $status;
    }
}
```

---

### ‚úÖ 2. **Create, Read, Update, Delete (CRUD)**

#### ‚û§ Create (Insert):
```php
DB::table('users')->insert([
    'name' => 'Ashraful',
    'email' => 'ashraful@example.com'
]);
```

#### ‚û§ Read (Select):
```php
$users = DB::table('users')->where('active', 1)->get();
```

#### ‚û§ Update:
```php
DB::table('users')->where('id', 1)->update(['name' => 'Antor']);
```

#### ‚û§ Delete:
```php
DB::table('users')->where('id', 1)->delete();
```

---

### ‚úÖ 3. **Raw SQL Queries**
```php
DB::statement("ALTER TABLE users ADD COLUMN age INT");
DB::select("SELECT * FROM users WHERE id = ?", [1]);
```

---

### ‚úÖ 4. **ACID & Transactions**
```php
DB::beginTransaction();
try {
    DB::table('accounts')->decrement('balance', 100);
    DB::table('transactions')->insert(['amount' => 100]);
    DB::commit(); // ‚úÖ Success
} catch (\Exception $e) {
    DB::rollBack(); // ‚ùå Failed ‚Äî rollback everything
}
```

---

### ‚úÖ 5. **Check Table/Column Existence**
```php
// Table check
$tableExists = DB::select("SHOW TABLES LIKE ?", ['users']);
// Column check
$columnExists = DB::select("SHOW COLUMNS FROM users LIKE 'email'");
```

---

### ‚úÖ 6. **Create / Drop Table / Column**
```php
// Create table
DB::statement("CREATE TABLE IF NOT EXISTS logs (id INT AUTO_INCREMENT PRIMARY KEY)");
// Drop table
DB::statement("DROP TABLE IF EXISTS logs");
// Add column
DB::statement("ALTER TABLE users ADD COLUMN status VARCHAR(50)");
// Drop column (careful!)
DB::statement("ALTER TABLE users DROP COLUMN status");
```

---

### ‚úÖ 7. **Custom Queries or Stored Procedures**
```php
DB::unprepared("CALL SomeProcedure()");
```

---

### ‚úÖ 8. **Advanced Failover Strategies**

#### Retry Logic with Exponential Backoff:
```php
class DatabaseRetryService
{
    public static function retryWithBackoff($callback, $maxAttempts = 3)
    {
        $attempt = 1;
        $delay = 100; // Start with 100ms
        
        while ($attempt <= $maxAttempts) {
            try {
                return $callback();
            } catch (QueryException $e) {
                if ($attempt === $maxAttempts) {
                    throw $e;
                }
                
                usleep($delay * 1000); // Convert to microseconds
                $delay *= 2; // Exponential backoff
                $attempt++;
            }
        }
    }
}

// Usage:
$users = DatabaseRetryService::retryWithBackoff(function() {
    return DB::table('users')->get();
});
```

#### Connection Pool Manager:
```php
class ConnectionPoolManager
{
    protected static $activeConnection = null;
    
    public static function getHealthyConnection()
    {
        $connections = ['primary', 'backup1', 'backup2'];
        
        // Return cached healthy connection if available
        if (self::$activeConnection && self::isHealthy(self::$activeConnection)) {
            return self::$activeConnection;
        }
        
        // Find a new healthy connection
        foreach ($connections as $conn) {
            if (self::isHealthy($conn)) {
                self::$activeConnection = $conn;
                return $conn;
            }
        }
        
        throw new \Exception('No healthy database connections available');
    }
    
    protected static function isHealthy($connection)
    {
        try {
            DB::connection($connection)->select('SELECT 1');
            return true;
        } catch (\Exception $e) {
            return false;
        }
    }
}
```

---

### üü° When Should You Use `DB::`?

| Use Case                    | Recommended?                   |
| --------------------------- | ------------------------------ |
| Complex raw SQL             | ‚úÖ Yes                          |
| Simple queries              | ‚úÖ Ok                           |
| Large logic, reusable model | ‚ùå Use Eloquent or Repositories |
| Migrations & structure      | ‚ùå Use `Schema::` or migrations |
| Failover & high availability| ‚úÖ Yes (with custom wrapper)    |

---

### üìù Best Practices for Failover Management:
1. **Monitor Connection Health**: Implement regular health checks
2. **Log Failures**: Track which connections fail and when
3. **Circuit Breaker Pattern**: Temporarily skip known-bad connections
4. **Load Balancing**: Distribute read queries across healthy replicas
5. **Graceful Degradation**: Have a plan when all connections fail
