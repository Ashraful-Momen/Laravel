# Laravel DB Facade Guide with Failover Management

Yes, with Laravel's `DB` facade (part of the Query Builder), **you can perform almost anything** related to raw SQL operations, including:

---

### ‚úÖ 1. **Database Connection & Failover Management**

#### Basic Connection:
```php
DB::connection()->getPdo(); // Get PDO instance
DB::connection('mysql')->select(...); // Use named connection
```

#### Failover with 2 Backup Connections:
```php
// config/database.php
'mysql' => [
    'driver' => 'mysql',
    'host' => env('DB_HOST', '127.0.0.1'),
    'database' => env('DB_DATABASE', 'forge'),
    'username' => env('DB_USERNAME', 'forge'),
    'password' => env('DB_PASSWORD', ''),
    // Add failover hosts
    'read' => [
        'host' => [
            env('DB_READ_HOST_1', '192.168.1.1'), // Primary read
            env('DB_READ_HOST_2', '192.168.1.2'), // Backup 1
            env('DB_READ_HOST_3', '192.168.1.3'), // Backup 2
        ],
    ],
    'write' => [
        'host' => [
            env('DB_WRITE_HOST_1', '192.168.1.1'), // Primary write
            env('DB_WRITE_HOST_2', '192.168.1.2'), // Backup 1
            env('DB_WRITE_HOST_3', '192.168.1.3'), // Backup 2
        ],
    ],
    'sticky' => true, // Optional: Use same connection for reads after writes
],
```

#### Manual Failover Implementation:
```php
use Illuminate\Support\Facades\DB;
use Illuminate\Database\QueryException;

class DatabaseFailoverService
{
    protected $connections = ['primary', 'backup1', 'backup2'];
    
    public function executeWithFailover($callback)
    {
        foreach ($this->connections as $connection) {
            try {
                // Attempt to use the connection
                DB::connection($connection)->getPdo();
                
                // Execute the callback with this connection
                return $callback(DB::connection($connection));
                
            } catch (QueryException $e) {
                \Log::warning("Connection {$connection} failed: " . $e->getMessage());
                
                // If this was the last connection, throw the exception
                if ($connection === end($this->connections)) {
                    throw new \Exception('All database connections failed');
                }
                // Otherwise, continue to next connection
            }
        }
    }
}

// Usage:
$failover = new DatabaseFailoverService();
$result = $failover->executeWithFailover(function($db) {
    return $db->table('users')->get();
});
```

#### Connection Health Check:
```php
class DatabaseHealthCheck
{
    public static function checkConnections()
    {
        $connections = ['primary', 'backup1', 'backup2'];
        $status = [];
        
        foreach ($connections as $conn) {
            try {
                DB::connection($conn)->getPdo();
                DB::connection($conn)->select('SELECT 1');
                $status[$conn] = 'healthy';
            } catch (\Exception $e) {
                $status[$conn] = 'down';
            }
        }
        
        return $status;
    }
}
```

---

### ‚úÖ 2. **Create, Read, Update, Delete (CRUD)**

#### ‚û§ Create (Insert):
```php
DB::table('users')->insert([
    'name' => 'Ashraful',
    'email' => 'ashraful@example.com'
]);
```

#### ‚û§ Read (Select):
```php
$users = DB::table('users')->where('active', 1)->get();
```

#### ‚û§ Update:
```php
DB::table('users')->where('id', 1)->update(['name' => 'Antor']);
```

#### ‚û§ Delete:
```php
DB::table('users')->where('id', 1)->delete();
```

---

### ‚úÖ 3. **Raw SQL Queries**
```php
DB::statement("ALTER TABLE users ADD COLUMN age INT");
DB::select("SELECT * FROM users WHERE id = ?", [1]);
```

---

### ‚úÖ 4. **ACID & Transactions**
```php
DB::beginTransaction();
try {
    DB::table('accounts')->decrement('balance', 100);
    DB::table('transactions')->insert(['amount' => 100]);
    DB::commit(); // ‚úÖ Success
} catch (\Exception $e) {
    DB::rollBack(); // ‚ùå Failed ‚Äî rollback everything
}
```

---

### ‚úÖ 5. **Check Table/Column Existence**
```php
// Table check
$tableExists = DB::select("SHOW TABLES LIKE ?", ['users']);
// Column check
$columnExists = DB::select("SHOW COLUMNS FROM users LIKE 'email'");
```

---

### ‚úÖ 6. **Create / Drop Table / Column**
```php
// Create table
DB::statement("CREATE TABLE IF NOT EXISTS logs (id INT AUTO_INCREMENT PRIMARY KEY)");
// Drop table
DB::statement("DROP TABLE IF EXISTS logs");
// Add column
DB::statement("ALTER TABLE users ADD COLUMN status VARCHAR(50)");
// Drop column (careful!)
DB::statement("ALTER TABLE users DROP COLUMN status");
```

---

### ‚úÖ 7. **Custom Queries or Stored Procedures**
```php
DB::unprepared("CALL SomeProcedure()");
```

---

### ‚úÖ 8. **Advanced Failover Strategies**

#### Retry Logic with Exponential Backoff:
```php
class DatabaseRetryService
{
    public static function retryWithBackoff($callback, $maxAttempts = 3)
    {
        $attempt = 1;
        $delay = 100; // Start with 100ms
        
        while ($attempt <= $maxAttempts) {
            try {
                return $callback();
            } catch (QueryException $e) {
                if ($attempt === $maxAttempts) {
                    throw $e;
                }
                
                usleep($delay * 1000); // Convert to microseconds
                $delay *= 2; // Exponential backoff
                $attempt++;
            }
        }
    }
}

// Usage:
$users = DatabaseRetryService::retryWithBackoff(function() {
    return DB::table('users')->get();
});
```

#### Connection Pool Manager:
```php
class ConnectionPoolManager
{
    protected static $activeConnection = null;
    
    public static function getHealthyConnection()
    {
        $connections = ['primary', 'backup1', 'backup2'];
        
        // Return cached healthy connection if available
        if (self::$activeConnection && self::isHealthy(self::$activeConnection)) {
            return self::$activeConnection;
        }
        
        // Find a new healthy connection
        foreach ($connections as $conn) {
            if (self::isHealthy($conn)) {
                self::$activeConnection = $conn;
                return $conn;
            }
        }
        
        throw new \Exception('No healthy database connections available');
    }
    
    protected static function isHealthy($connection)
    {
        try {
            DB::connection($connection)->select('SELECT 1');
            return true;
        } catch (\Exception $e) {
            return false;
        }
    }
}
```

---

### üü° When Should You Use `DB::`?

| Use Case                    | Recommended?                   |
| --------------------------- | ------------------------------ |
| Complex raw SQL             | ‚úÖ Yes                          |
| Simple queries              | ‚úÖ Ok                           |
| Large logic, reusable model | ‚ùå Use Eloquent or Repositories |
| Migrations & structure      | ‚ùå Use `Schema::` or migrations |
| Failover & high availability| ‚úÖ Yes (with custom wrapper)    |

---

### ‚úÖ 9. **Eloquent & Repositories for Large Logic**

#### Why Use Eloquent Instead of DB::
```php
// ‚ùå Bad: Using DB:: for complex business logic
$user = DB::table('users')->where('id', 1)->first();
$posts = DB::table('posts')->where('user_id', $user->id)->get();
$comments = DB::table('comments')->whereIn('post_id', $posts->pluck('id'))->get();

// ‚úÖ Good: Using Eloquent with relationships
$user = User::with('posts.comments')->find(1);
```

#### Eloquent Model Example:
```php
namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\SoftDeletes;

class User extends Model
{
    use SoftDeletes;
    
    protected $fillable = ['name', 'email', 'password'];
    protected $hidden = ['password', 'remember_token'];
    protected $casts = [
        'email_verified_at' => 'datetime',
        'is_active' => 'boolean',
    ];
    
    // Relationships
    public function posts()
    {
        return $this->hasMany(Post::class);
    }
    
    public function profile()
    {
        return $this->hasOne(Profile::class);
    }
    
    // Scopes
    public function scopeActive($query)
    {
        return $query->where('is_active', true);
    }
    
    // Accessors & Mutators
    public function getFullNameAttribute()
    {
        return "{$this->first_name} {$this->last_name}";
    }
    
    // Business Logic
    public function canPublishPosts()
    {
        return $this->is_active && $this->email_verified_at !== null;
    }
}

// Usage:
$activeUsers = User::active()->with('posts')->get();
$user = User::find(1);
if ($user->canPublishPosts()) {
    // Business logic here
}
```

#### Repository Pattern for Complex Logic:
```php
namespace App\Repositories;

interface UserRepositoryInterface
{
    public function findById($id);
    public function findByEmail($email);
    public function createUser(array $data);
    public function updateUser($id, array $data);
    public function getActiveUsersWithPosts();
}

class UserRepository implements UserRepositoryInterface
{
    protected $model;
    
    public function __construct(User $model)
    {
        $this->model = $model;
    }
    
    public function findById($id)
    {
        return $this->model->with('profile')->find($id);
    }
    
    public function findByEmail($email)
    {
        return $this->model->where('email', $email)->first();
    }
    
    public function createUser(array $data)
    {
        return DB::transaction(function () use ($data) {
            $user = $this->model->create($data);
            $user->profile()->create($data['profile'] ?? []);
            return $user;
        });
    }
    
    public function updateUser($id, array $data)
    {
        $user = $this->findById($id);
        $user->update($data);
        return $user;
    }
    
    public function getActiveUsersWithPosts()
    {
        return $this->model
            ->active()
            ->with(['posts' => function ($query) {
                $query->published()->latest();
            }])
            ->paginate(20);
    }
}

// Service Provider Registration:
namespace App\Providers;

class RepositoryServiceProvider extends ServiceProvider
{
    public function register()
    {
        $this->app->bind(
            UserRepositoryInterface::class,
            UserRepository::class
        );
    }
}

// Controller Usage:
class UserController extends Controller
{
    protected $userRepository;
    
    public function __construct(UserRepositoryInterface $userRepository)
    {
        $this->userRepository = $userRepository;
    }
    
    public function show($id)
    {
        $user = $this->userRepository->findById($id);
        return view('users.show', compact('user'));
    }
}
```

#### Service Layer for Business Logic:
```php
namespace App\Services;

class UserService
{
    protected $userRepository;
    protected $emailService;
    
    public function __construct(
        UserRepositoryInterface $userRepository,
        EmailService $emailService
    ) {
        $this->userRepository = $userRepository;
        $this->emailService = $emailService;
    }
    
    public function registerUser(array $data)
    {
        DB::beginTransaction();
        try {
            // Create user
            $user = $this->userRepository->createUser($data);
            
            // Send welcome email
            $this->emailService->sendWelcomeEmail($user);
            
            // Log registration
            activity()
                ->performedOn($user)
                ->log('User registered');
            
            DB::commit();
            return $user;
            
        } catch (\Exception $e) {
            DB::rollBack();
            throw $e;
        }
    }
    
    public function deactivateInactiveUsers()
    {
        $inactiveUsers = User::where('last_login_at', '<', now()->subMonths(6))
            ->where('is_active', true)
            ->chunk(100, function ($users) {
                foreach ($users as $user) {
                    $user->update(['is_active' => false]);
                    $this->emailService->sendReactivationEmail($user);
                }
            });
    }
}
```

---

### ‚úÖ 10. **Schema Builder & Migrations for Database Structure**

#### Why Use Schema:: Instead of DB::
```php
// ‚ùå Bad: Using raw SQL for structure changes
DB::statement("CREATE TABLE users (id INT, name VARCHAR(255))");

// ‚úÖ Good: Using Schema Builder
Schema::create('users', function (Blueprint $table) {
    $table->id();
    $table->string('name');
    $table->timestamps();
});
```

#### Migration Examples:
```php
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

class CreateUsersTable extends Migration
{
    public function up()
    {
        Schema::create('users', function (Blueprint $table) {
            $table->id();
            $table->string('name');
            $table->string('email')->unique();
            $table->timestamp('email_verified_at')->nullable();
            $table->string('password');
            $table->boolean('is_active')->default(true);
            $table->rememberToken();
            $table->timestamps();
            $table->softDeletes();
            
            // Indexes
            $table->index('email');
            $table->index(['is_active', 'created_at']);
        });
    }
    
    public function down()
    {
        Schema::dropIfExists('users');
    }
}
```

#### Complex Migration with Foreign Keys:
```php
class CreateBlogTables extends Migration
{
    public function up()
    {
        // Create posts table
        Schema::create('posts', function (Blueprint $table) {
            $table->id();
            $table->foreignId('user_id')->constrained()->onDelete('cascade');
            $table->string('title');
            $table->string('slug')->unique();
            $table->text('content');
            $table->enum('status', ['draft', 'published', 'archived'])
                  ->default('draft');
            $table->timestamp('published_at')->nullable();
            $table->timestamps();
            
            $table->index(['user_id', 'status']);
            $table->fullText(['title', 'content']); // MySQL 5.7+
        });
        
        // Create categories table
        Schema::create('categories', function (Blueprint $table) {
            $table->id();
            $table->string('name');
            $table->string('slug')->unique();
            $table->text('description')->nullable();
            $table->timestamps();
        });
        
        // Create pivot table
        Schema::create('post_categories', function (Blueprint $table) {
            $table->id();
            $table->foreignId('post_id')->constrained()->onDelete('cascade');
            $table->foreignId('category_id')->constrained()->onDelete('cascade');
            $table->timestamps();
            
            $table->unique(['post_id', 'category_id']);
        });
    }
    
    public function down()
    {
        Schema::dropIfExists('post_categories');
        Schema::dropIfExists('categories');
        Schema::dropIfExists('posts');
    }
}
```

#### Modifying Existing Tables:
```php
class AddFieldsToUsersTable extends Migration
{
    public function up()
    {
        Schema::table('users', function (Blueprint $table) {
            // Add columns
            $table->string('phone')->nullable()->after('email');
            $table->date('birth_date')->nullable();
            $table->json('preferences')->nullable();
            
            // Modify columns (requires doctrine/dbal)
            $table->string('name', 100)->change();
            
            // Add indexes
            $table->index('phone');
        });
    }
    
    public function down()
    {
        Schema::table('users', function (Blueprint $table) {
            $table->dropIndex(['phone']);
            $table->dropColumn(['phone', 'birth_date', 'preferences']);
        });
    }
}
```

#### Advanced Schema Operations:
```php
class AdvancedSchemaOperations extends Migration
{
    public function up()
    {
        // Rename table
        Schema::rename('old_users', 'users');
        
        // Check if table exists
        if (!Schema::hasTable('logs')) {
            Schema::create('logs', function (Blueprint $table) {
                $table->id();
                $table->string('message');
                $table->timestamps();
            });
        }
        
        // Check if column exists
        if (!Schema::hasColumn('users', 'avatar')) {
            Schema::table('users', function (Blueprint $table) {
                $table->string('avatar')->nullable();
            });
        }
        
        // Raw index creation for complex cases
        Schema::table('posts', function (Blueprint $table) {
            $table->rawIndex('(created_at DESC)', 'posts_created_at_desc');
        });
        
        // Spatial indexes (MySQL)
        Schema::table('locations', function (Blueprint $table) {
            $table->point('coordinates');
            $table->spatialIndex('coordinates');
        });
    }
}
```

#### Database Seeding:
```php
namespace Database\Seeders;

use Illuminate\Database\Seeder;
use App\Models\User;
use App\Models\Post;

class DatabaseSeeder extends Seeder
{
    public function run()
    {
        // Using Factories
        User::factory(10)->create()->each(function ($user) {
            Post::factory(rand(5, 10))->create([
                'user_id' => $user->id
            ]);
        });
        
        // Direct seeding
        User::create([
            'name' => 'Admin User',
            'email' => 'admin@example.com',
            'password' => bcrypt('password'),
            'is_admin' => true
        ]);
        
        // Bulk insert for performance
        $categories = collect(['Technology', 'Business', 'Health'])
            ->map(fn($name) => [
                'name' => $name,
                'slug' => Str::slug($name),
                'created_at' => now(),
                'updated_at' => now()
            ]);
        
        DB::table('categories')->insert($categories->toArray());
    }
}
```

---

### üìù Best Practices Summary:

#### For Database Queries:
- **Simple queries**: DB:: is fine
- **Complex relationships**: Use Eloquent
- **Business logic**: Implement in Models/Services
- **Data access patterns**: Use Repositories

#### For Database Structure:
- **Table creation/modification**: Always use migrations
- **Schema changes**: Use Schema:: builder
- **Production changes**: Test migrations in staging first
- **Rollback plan**: Always implement down() method

#### For Failover Management:
1. **Monitor Connection Health**: Implement regular health checks
2. **Log Failures**: Track which connections fail and when
3. **Circuit Breaker Pattern**: Temporarily skip known-bad connections
4. **Load Balancing**: Distribute read queries across healthy replicas
5. **Graceful Degradation**: Have a plan when all connections fail
