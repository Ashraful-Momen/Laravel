# Laravel DB Facade Guide with Failover Management

Yes, with Laravel's `DB` facade (part of the Query Builder), **you can perform almost anything** related to raw SQL operations, including:

---

### ✅ 1. **Database Connection & Failover Management**

#### Basic Connection:
```php
DB::connection()->getPdo(); // Get PDO instance
DB::connection('mysql')->select(...); // Use named connection
```

#### Failover with 2 Backup Connections:
```php
// config/database.php
'mysql' => [
    'driver' => 'mysql',
    'host' => env('DB_HOST', '127.0.0.1'),
    'database' => env('DB_DATABASE', 'forge'),
    'username' => env('DB_USERNAME', 'forge'),
    'password' => env('DB_PASSWORD', ''),
    // Add failover hosts
    'read' => [
        'host' => [
            env('DB_READ_HOST_1', '192.168.1.1'), // Primary read
            env('DB_READ_HOST_2', '192.168.1.2'), // Backup 1
            env('DB_READ_HOST_3', '192.168.1.3'), // Backup 2
        ],
    ],
    'write' => [
        'host' => [
            env('DB_WRITE_HOST_1', '192.168.1.1'), // Primary write
            env('DB_WRITE_HOST_2', '192.168.1.2'), // Backup 1
            env('DB_WRITE_HOST_3', '192.168.1.3'), // Backup 2
        ],
    ],
    'sticky' => true, // Optional: Use same connection for reads after writes
],
```

#### Manual Failover Implementation:
```php
use Illuminate\Support\Facades\DB;
use Illuminate\Database\QueryException;

class DatabaseFailoverService
{
    protected $connections = ['primary', 'backup1', 'backup2'];
    
    public function executeWithFailover($callback)
    {
        foreach ($this->connections as $connection) {
            try {
                // Attempt to use the connection
                DB::connection($connection)->getPdo();
                
                // Execute the callback with this connection
                return $callback(DB::connection($connection));
                
            } catch (QueryException $e) {
                \Log::warning("Connection {$connection} failed: " . $e->getMessage());
                
                // If this was the last connection, throw the exception
                if ($connection === end($this->connections)) {
                    throw new \Exception('All database connections failed');
                }
                // Otherwise, continue to next connection
            }
        }
    }
}

// Usage:
$failover = new DatabaseFailoverService();
$result = $failover->executeWithFailover(function($db) {
    return $db->table('users')->get();
});
```

#### Connection Health Check:
```php
class DatabaseHealthCheck
{
    public static function checkConnections()
    {
        $connections = ['primary', 'backup1', 'backup2'];
        $status = [];
        
        foreach ($connections as $conn) {
            try {
                DB::connection($conn)->getPdo();
                DB::connection($conn)->select('SELECT 1');
                $status[$conn] = 'healthy';
            } catch (\Exception $e) {
                $status[$conn] = 'down';
            }
        }
        
        return $status;
    }
}
```

---

### ✅ 2. **Create, Read, Update, Delete (CRUD)**

#### ➤ Create (Insert):
```php
DB::table('users')->insert([
    'name' => 'Ashraful',
    'email' => 'ashraful@example.com'
]);
```

#### ➤ Read (Select):
```php
$users = DB::table('users')->where('active', 1)->get();
```

#### ➤ Update:
```php
DB::table('users')->where('id', 1)->update(['name' => 'Antor']);
```

#### ➤ Delete:
```php
DB::table('users')->where('id', 1)->delete();
```

---

### ✅ 3. **Raw SQL Queries**
```php
DB::statement("ALTER TABLE users ADD COLUMN age INT");
DB::select("SELECT * FROM users WHERE id = ?", [1]);
```

---

### ✅ 4. **ACID & Transactions**
```php
DB::beginTransaction();
try {
    DB::table('accounts')->decrement('balance', 100);
    DB::table('transactions')->insert(['amount' => 100]);
    DB::commit(); // ✅ Success
} catch (\Exception $e) {
    DB::rollBack(); // ❌ Failed — rollback everything
}
```

---

### ✅ 5. **Check Table/Column Existence**
```php
// Table check
$tableExists = DB::select("SHOW TABLES LIKE ?", ['users']);
// Column check
$columnExists = DB::select("SHOW COLUMNS FROM users LIKE 'email'");
```

---

### ✅ 6. **Create / Drop Table / Column**
```php
// Create table
DB::statement("CREATE TABLE IF NOT EXISTS logs (id INT AUTO_INCREMENT PRIMARY KEY)");
// Drop table
DB::statement("DROP TABLE IF EXISTS logs");
// Add column
DB::statement("ALTER TABLE users ADD COLUMN status VARCHAR(50)");
// Drop column (careful!)
DB::statement("ALTER TABLE users DROP COLUMN status");
```

---

### ✅ 7. **Custom Queries or Stored Procedures**
```php
DB::unprepared("CALL SomeProcedure()");
```

---

### ✅ 8. **Error Handling for DB:: Operations**

#### Common Database Errors and Handling:
```php
use Illuminate\Database\QueryException;
use Illuminate\Database\ConnectionException;
use PDOException;

class DatabaseErrorHandler
{
    public function handleDatabaseOperation($callback)
    {
        try {
            return $callback();
        } catch (QueryException $e) {
            $errorCode = $e->errorInfo[1];
            
            switch ($errorCode) {
                case 1062: // Duplicate entry
                    throw new \Exception('Duplicate entry found: ' . $e->getMessage());
                    
                case 1451: // Foreign key constraint
                    throw new \Exception('Cannot delete - record has related data');
                    
                case 1054: // Unknown column
                    throw new \Exception('Column not found: ' . $e->getMessage());
                    
                case 1146: // Table doesn't exist
                    throw new \Exception('Table not found: ' . $e->getMessage());
                    
                case 2002: // Connection refused
                    throw new \Exception('Database connection failed');
                    
                default:
                    \Log::error('Database error: ' . $e->getMessage());
                    throw new \Exception('Database operation failed');
            }
        } catch (PDOException $e) {
            \Log::error('PDO Error: ' . $e->getMessage());
            throw new \Exception('Database connection error');
        }
    }
}

// Usage:
$handler = new DatabaseErrorHandler();
$result = $handler->handleDatabaseOperation(function() {
    return DB::table('users')->insert(['email' => 'duplicate@email.com']);
});
```

#### Checking Before Operations:
```php
class SafeDatabaseOperations
{
    // Check if table exists before querying
    public static function tableExists($tableName)
    {
        try {
            return Schema::hasTable($tableName);
        } catch (\Exception $e) {
            return false;
        }
    }
    
    // Check if column exists before querying
    public static function columnExists($table, $column)
    {
        try {
            return Schema::hasColumn($table, $column);
        } catch (\Exception $e) {
            return false;
        }
    }
    
    // Safe insert with duplicate handling
    public static function safeInsert($table, array $data)
    {
        try {
            return DB::table($table)->insert($data);
        } catch (QueryException $e) {
            if ($e->errorInfo[1] == 1062) {
                // Handle duplicate entry
                return DB::table($table)->updateOrInsert(
                    ['email' => $data['email']], // Unique identifier
                    $data
                );
            }
            throw $e;
        }
    }
    
    // Safe delete with foreign key handling
    public static function safeDelete($table, $id)
    {
        try {
            return DB::table($table)->where('id', $id)->delete();
        } catch (QueryException $e) {
            if ($e->errorInfo[1] == 1451) {
                // Foreign key constraint violation
                return ['error' => 'Cannot delete: Record has related data'];
            }
            throw $e;
        }
    }
}

// Usage:
if (SafeDatabaseOperations::tableExists('users')) {
    if (SafeDatabaseOperations::columnExists('users', 'email')) {
        $result = SafeDatabaseOperations::safeInsert('users', [
            'name' => 'John',
            'email' => 'john@example.com'
        ]);
    }
}
```

#### Transaction Error Handling:
```php
class TransactionManager
{
    public static function executeInTransaction(callable $callback)
    {
        DB::beginTransaction();
        
        try {
            $result = $callback();
            DB::commit();
            return $result;
            
        } catch (QueryException $e) {
            DB::rollBack();
            
            // Log the specific error
            \Log::error('Transaction failed', [
                'message' => $e->getMessage(),
                'code' => $e->errorInfo[1] ?? null,
                'sql' => $e->getSql(),
                'bindings' => $e->getBindings()
            ]);
            
            throw new \Exception('Transaction failed: ' . $e->getMessage());
            
        } catch (\Exception $e) {
            DB::rollBack();
            throw $e;
        }
    }
}

// Usage:
try {
    $result = TransactionManager::executeInTransaction(function() {
        DB::table('accounts')->decrement('balance', 100);
        DB::table('transactions')->insert(['amount' => 100]);
        return 'Transaction completed';
    });
} catch (\Exception $e) {
    // Handle error
    return response()->json(['error' => $e->getMessage()], 500);
}
```

#### Custom Error Messages:
```php
trait DatabaseErrorMessages
{
    protected function getDatabaseErrorMessage(QueryException $e)
    {
        $errorCode = $e->errorInfo[1] ?? null;
        
        $errorMessages = [
            1062 => 'This record already exists',
            1451 => 'Cannot delete this record as it has related data',
            1054 => 'Invalid column name specified',
            1146 => 'The requested table does not exist',
            1064 => 'SQL syntax error',
            1040 => 'Too many database connections',
            1045 => 'Access denied for database user',
            2002 => 'Cannot connect to database server',
            2006 => 'Database server has gone away',
        ];
        
        return $errorMessages[$errorCode] ?? 'Database operation failed';
    }
}
```

---

### ✅ 9. **Advanced Failover Strategies**

#### Retry Logic with Exponential Backoff:
```php
class DatabaseRetryService
{
    public static function retryWithBackoff($callback, $maxAttempts = 3)
    {
        $attempt = 1;
        $delay = 100; // Start with 100ms
        
        while ($attempt <= $maxAttempts) {
            try {
                return $callback();
            } catch (QueryException $e) {
                if ($attempt === $maxAttempts) {
                    throw $e;
                }
                
                usleep($delay * 1000); // Convert to microseconds
                $delay *= 2; // Exponential backoff
                $attempt++;
            }
        }
    }
}

// Usage:
$users = DatabaseRetryService::retryWithBackoff(function() {
    return DB::table('users')->get();
});
```

#### Connection Pool Manager:
```php
class ConnectionPoolManager
{
    protected static $activeConnection = null;
    
    public static function getHealthyConnection()
    {
        $connections = ['primary', 'backup1', 'backup2'];
        
        // Return cached healthy connection if available
        if (self::$activeConnection && self::isHealthy(self::$activeConnection)) {
            return self::$activeConnection;
        }
        
        // Find a new healthy connection
        foreach ($connections as $conn) {
            if (self::isHealthy($conn)) {
                self::$activeConnection = $conn;
                return $conn;
            }
        }
        
        throw new \Exception('No healthy database connections available');
    }
    
    protected static function isHealthy($connection)
    {
        try {
            DB::connection($connection)->select('SELECT 1');
            return true;
        } catch (\Exception $e) {
            return false;
        }
    }
}
```

---

### 🟡 When Should You Use `DB::`?

| Use Case                    | Recommended?                   |
| --------------------------- | ------------------------------ |
| Complex raw SQL             | ✅ Yes                          |
| Simple queries              | ✅ Ok                           |
| Large logic, reusable model | ❌ Use Eloquent or Repositories |
| Migrations & structure      | ❌ Use `Schema::` or migrations |
| Failover & high availability| ✅ Yes (with custom wrapper)    |

---

### ✅ 9. **Eloquent & Repositories for Large Logic**

#### Why Use Eloquent Instead of DB::
```php
// ❌ Bad: Using DB:: for complex business logic
$user = DB::table('users')->where('id', 1)->first();
$posts = DB::table('posts')->where('user_id', $user->id)->get();
$comments = DB::table('comments')->whereIn('post_id', $posts->pluck('id'))->get();

// ✅ Good: Using Eloquent with relationships
$user = User::with('posts.comments')->find(1);
```

#### Eloquent Model Example:
```php
namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\SoftDeletes;

class User extends Model
{
    use SoftDeletes;
    
    protected $fillable = ['name', 'email', 'password'];
    protected $hidden = ['password', 'remember_token'];
    protected $casts = [
        'email_verified_at' => 'datetime',
        'is_active' => 'boolean',
    ];
    
    // Relationships
    public function posts()
    {
        return $this->hasMany(Post::class);
    }
    
    public function profile()
    {
        return $this->hasOne(Profile::class);
    }
    
    // Scopes
    public function scopeActive($query)
    {
        return $query->where('is_active', true);
    }
    
    // Accessors & Mutators
    public function getFullNameAttribute()
    {
        return "{$this->first_name} {$this->last_name}";
    }
    
    // Business Logic
    public function canPublishPosts()
    {
        return $this->is_active && $this->email_verified_at !== null;
    }
}

// Usage:
$activeUsers = User::active()->with('posts')->get();
$user = User::find(1);
if ($user->canPublishPosts()) {
    // Business logic here
}
```

#### Repository Pattern for Complex Logic:
```php
namespace App\Repositories;

interface UserRepositoryInterface
{
    public function findById($id);
    public function findByEmail($email);
    public function createUser(array $data);
    public function updateUser($id, array $data);
    public function getActiveUsersWithPosts();
}

class UserRepository implements UserRepositoryInterface
{
    protected $model;
    
    public function __construct(User $model)
    {
        $this->model = $model;
    }
    
    public function findById($id)
    {
        return $this->model->with('profile')->find($id);
    }
    
    public function findByEmail($email)
    {
        return $this->model->where('email', $email)->first();
    }
    
    public function createUser(array $data)
    {
        return DB::transaction(function () use ($data) {
            $user = $this->model->create($data);
            $user->profile()->create($data['profile'] ?? []);
            return $user;
        });
    }
    
    public function updateUser($id, array $data)
    {
        $user = $this->findById($id);
        $user->update($data);
        return $user;
    }
    
    public function getActiveUsersWithPosts()
    {
        return $this->model
            ->active()
            ->with(['posts' => function ($query) {
                $query->published()->latest();
            }])
            ->paginate(20);
    }
}

// Service Provider Registration:
namespace App\Providers;

class RepositoryServiceProvider extends ServiceProvider
{
    public function register()
    {
        $this->app->bind(
            UserRepositoryInterface::class,
            UserRepository::class
        );
    }
}

// Controller Usage:
class UserController extends Controller
{
    protected $userRepository;
    
    public function __construct(UserRepositoryInterface $userRepository)
    {
        $this->userRepository = $userRepository;
    }
    
    public function show($id)
    {
        $user = $this->userRepository->findById($id);
        return view('users.show', compact('user'));
    }
}
```

#### Service Layer for Business Logic:
```php
namespace App\Services;

class UserService
{
    protected $userRepository;
    protected $emailService;
    
    public function __construct(
        UserRepositoryInterface $userRepository,
        EmailService $emailService
    ) {
        $this->userRepository = $userRepository;
        $this->emailService = $emailService;
    }
    
    public function registerUser(array $data)
    {
        DB::beginTransaction();
        try {
            // Create user
            $user = $this->userRepository->createUser($data);
            
            // Send welcome email
            $this->emailService->sendWelcomeEmail($user);
            
            // Log registration
            activity()
                ->performedOn($user)
                ->log('User registered');
            
            DB::commit();
            return $user;
            
        } catch (\Exception $e) {
            DB::rollBack();
            throw $e;
        }
    }
    
    public function deactivateInactiveUsers()
    {
        $inactiveUsers = User::where('last_login_at', '<', now()->subMonths(6))
            ->where('is_active', true)
            ->chunk(100, function ($users) {
                foreach ($users as $user) {
                    $user->update(['is_active' => false]);
                    $this->emailService->sendReactivationEmail($user);
                }
            });
    }
}
```

---

### ✅ 10. **Schema Builder & Migrations for Database Structure**

#### Why Use Schema:: Instead of DB::
```php
// ❌ Bad: Using raw SQL for structure changes
DB::statement("CREATE TABLE users (id INT, name VARCHAR(255))");

// ✅ Good: Using Schema Builder
Schema::create('users', function (Blueprint $table) {
    $table->id();
    $table->string('name');
    $table->timestamps();
});
```

#### Migration Examples:
```php
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

class CreateUsersTable extends Migration
{
    public function up()
    {
        Schema::create('users', function (Blueprint $table) {
            $table->id();
            $table->string('name');
            $table->string('email')->unique();
            $table->timestamp('email_verified_at')->nullable();
            $table->string('password');
            $table->boolean('is_active')->default(true);
            $table->rememberToken();
            $table->timestamps();
            $table->softDeletes();
            
            // Indexes
            $table->index('email');
            $table->index(['is_active', 'created_at']);
        });
    }
    
    public function down()
    {
        Schema::dropIfExists('users');
    }
}
```

#### Complex Migration with Foreign Keys:
```php
class CreateBlogTables extends Migration
{
    public function up()
    {
        // Create posts table
        Schema::create('posts', function (Blueprint $table) {
            $table->id();
            $table->foreignId('user_id')->constrained()->onDelete('cascade');
            $table->string('title');
            $table->string('slug')->unique();
            $table->text('content');
            $table->enum('status', ['draft', 'published', 'archived'])
                  ->default('draft');
            $table->timestamp('published_at')->nullable();
            $table->timestamps();
            
            $table->index(['user_id', 'status']);
            $table->fullText(['title', 'content']); // MySQL 5.7+
        });
        
        // Create categories table
        Schema::create('categories', function (Blueprint $table) {
            $table->id();
            $table->string('name');
            $table->string('slug')->unique();
            $table->text('description')->nullable();
            $table->timestamps();
        });
        
        // Create pivot table
        Schema::create('post_categories', function (Blueprint $table) {
            $table->id();
            $table->foreignId('post_id')->constrained()->onDelete('cascade');
            $table->foreignId('category_id')->constrained()->onDelete('cascade');
            $table->timestamps();
            
            $table->unique(['post_id', 'category_id']);
        });
    }
    
    public function down()
    {
        Schema::dropIfExists('post_categories');
        Schema::dropIfExists('categories');
        Schema::dropIfExists('posts');
    }
}
```

#### Modifying Existing Tables:
```php
class AddFieldsToUsersTable extends Migration
{
    public function up()
    {
        Schema::table('users', function (Blueprint $table) {
            // Add columns
            $table->string('phone')->nullable()->after('email');
            $table->date('birth_date')->nullable();
            $table->json('preferences')->nullable();
            
            // Modify columns (requires doctrine/dbal)
            $table->string('name', 100)->change();
            
            // Add indexes
            $table->index('phone');
        });
    }
    
    public function down()
    {
        Schema::table('users', function (Blueprint $table) {
            $table->dropIndex(['phone']);
            $table->dropColumn(['phone', 'birth_date', 'preferences']);
        });
    }
}
```

#### Advanced Schema Operations:
```php
class AdvancedSchemaOperations extends Migration
{
    public function up()
    {
        // Rename table
        Schema::rename('old_users', 'users');
        
        // Check if table exists
        if (!Schema::hasTable('logs')) {
            Schema::create('logs', function (Blueprint $table) {
                $table->id();
                $table->string('message');
                $table->timestamps();
            });
        }
        
        // Check if column exists
        if (!Schema::hasColumn('users', 'avatar')) {
            Schema::table('users', function (Blueprint $table) {
                $table->string('avatar')->nullable();
            });
        }
        
        // Raw index creation for complex cases
        Schema::table('posts', function (Blueprint $table) {
            $table->rawIndex('(created_at DESC)', 'posts_created_at_desc');
        });
        
        // Spatial indexes (MySQL)
        Schema::table('locations', function (Blueprint $table) {
            $table->point('coordinates');
            $table->spatialIndex('coordinates');
        });
    }
}
```

#### Database Seeding:
```php
namespace Database\Seeders;

use Illuminate\Database\Seeder;
use App\Models\User;
use App\Models\Post;

class DatabaseSeeder extends Seeder
{
    public function run()
    {
        // Using Factories
        User::factory(10)->create()->each(function ($user) {
            Post::factory(rand(5, 10))->create([
                'user_id' => $user->id
            ]);
        });
        
        // Direct seeding
        User::create([
            'name' => 'Admin User',
            'email' => 'admin@example.com',
            'password' => bcrypt('password'),
            'is_admin' => true
        ]);
        
        // Bulk insert for performance
        $categories = collect(['Technology', 'Business', 'Health'])
            ->map(fn($name) => [
                'name' => $name,
                'slug' => Str::slug($name),
                'created_at' => now(),
                'updated_at' => now()
            ]);
        
        DB::table('categories')->insert($categories->toArray());
    }
}
```

### ✅ 11. **Schema Error Handling & Migration Safety**

#### Safe Migration Practices:
```php
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

class SafeMigrationExample extends Migration
{
    public function up()
    {
        try {
            // Check if table already exists
            if (Schema::hasTable('users')) {
                $this->updateExistingTable();
            } else {
                $this->createNewTable();
            }
        } catch (\Exception $e) {
            \Log::error('Migration failed: ' . $e->getMessage());
            throw $e;
        }
    }
    
    protected function createNewTable()
    {
        Schema::create('users', function (Blueprint $table) {
            $table->id();
            $table->string('email')->unique();
            $table->timestamps();
        });
    }
    
    protected function updateExistingTable()
    {
        Schema::table('users', function (Blueprint $table) {
            // Check before adding column
            if (!Schema::hasColumn('users', 'phone')) {
                $table->string('phone')->nullable();
            }
            
            // Check before adding index
            $sm = Schema::getConnection()->getDoctrineSchemaManager();
            $indexes = $sm->listTableIndexes('users');
            
            if (!array_key_exists('users_email_index', $indexes)) {
                $table->index('email');
            }
        });
    }
    
    public function down()
    {
        // Safe rollback
        Schema::table('users', function (Blueprint $table) {
            if (Schema::hasColumn('users', 'phone')) {
                $table->dropColumn('phone');
            }
        });
    }
}
```

#### Migration Error Handler:
```php
abstract class SafeMigration extends Migration
{
    public function up()
    {
        try {
            DB::beginTransaction();
            $this->safeUp();
            DB::commit();
        } catch (\Exception $e) {
            DB::rollBack();
            $this->handleMigrationError($e);
        }
    }
    
    public function down()
    {
        try {
            DB::beginTransaction();
            $this->safeDown();
            DB::commit();
        } catch (\Exception $e) {
            DB::rollBack();
            $this->handleMigrationError($e);
        }
    }
    
    abstract protected function safeUp();
    abstract protected function safeDown();
    
    protected function handleMigrationError(\Exception $e)
    {
        \Log::error('Migration error', [
            'migration' => get_class($this),
            'message' => $e->getMessage(),
            'trace' => $e->getTraceAsString()
        ]);
        
        // Send notification to dev team
        // Notification::send(...);
        
        throw $e;
    }
}

// Usage:
class AddUserFieldsMigration extends SafeMigration
{
    protected function safeUp()
    {
        Schema::table('users', function (Blueprint $table) {
            $table->string('address')->nullable();
        });
    }
    
    protected function safeDown()
    {
        Schema::table('users', function (Blueprint $table) {
            $table->dropColumn('address');
        });
    }
}
```

#### Schema Validation Helpers:
```php
class SchemaValidator
{
    public static function validateTableStructure($table, array $expectedColumns)
    {
        if (!Schema::hasTable($table)) {
            throw new \Exception("Table {$table} does not exist");
        }
        
        $actualColumns = Schema::getColumnListing($table);
        $missingColumns = array_diff($expectedColumns, $actualColumns);
        
        if (!empty($missingColumns)) {
            throw new \Exception("Missing columns in {$table}: " . implode(', ', $missingColumns));
        }
        
        return true;
    }
    
    public static function safeDropColumn($table, $column)
    {
        if (Schema::hasColumn($table, $column)) {
            // Check if column has foreign key
            $foreignKeys = Schema::getConnection()
                ->getDoctrineSchemaManager()
                ->listTableForeignKeys($table);
                
            foreach ($foreignKeys as $foreignKey) {
                if (in_array($column, $foreignKey->getLocalColumns())) {
                    throw new \Exception("Cannot drop column {$column}: has foreign key constraint");
                }
            }
            
            Schema::table($table, function (Blueprint $table) use ($column) {
                $table->dropColumn($column);
            });
        }
    }
    
    public static function safeRenameTable($from, $to)
    {
        if (!Schema::hasTable($from)) {
            throw new \Exception("Source table {$from} does not exist");
        }
        
        if (Schema::hasTable($to)) {
            throw new \Exception("Target table {$to} already exists");
        }
        
        Schema::rename($from, $to);
    }
}
```

---

### ✅ 12. **When to Use DB:: vs Schema::**

#### Use DB:: When:
```php
// ✅ 1. Performing CRUD operations
DB::table('users')->insert(['name' => 'John']);
DB::table('users')->where('id', 1)->update(['status' => 'active']);

// ✅ 2. Running complex queries
DB::select("
    SELECT u.*, COUNT(p.id) as post_count 
    FROM users u 
    LEFT JOIN posts p ON u.id = p.user_id 
    GROUP BY u.id
");

// ✅ 3. Executing stored procedures
DB::statement('CALL calculate_user_statistics(?)', [1]);

// ✅ 4. Working with transactions
DB::transaction(function () {
    DB::table('orders')->insert([...]);
    DB::table('inventory')->decrement('quantity', 1);
});

// ✅ 5. Temporary data operations
DB::statement('SET @rank := 0');
DB::select('SELECT @rank := @rank + 1 as rank, name FROM users ORDER BY score DESC');
```

#### Use Schema:: When:
```php
// ✅ 1. Creating/modifying table structure
Schema::create('products', function (Blueprint $table) {
    $table->id();
    $table->string('name');
    $table->decimal('price', 10, 2);
    $table->timestamps();
});

// ✅ 2. Managing indexes
Schema::table('users', function (Blueprint $table) {
    $table->index(['email', 'created_at']);
});

// ✅ 3. Setting up relationships
Schema::table('posts', function (Blueprint $table) {
    $table->foreignId('user_id')->constrained()->onDelete('cascade');
});

// ✅ 4. Checking database structure
if (Schema::hasTable('users') && Schema::hasColumn('users', 'email')) {
    // Safe to proceed
}

// ✅ 5. Database-agnostic operations
Schema::create('settings', function (Blueprint $table) {
    $table->string('key')->primary();
    $table->json('value'); // Works across MySQL, PostgreSQL, etc.
});
```

#### Comparison Table:
| Operation | DB:: | Schema:: |
|-----------|------|----------|
| SELECT queries | ✅ Use DB:: | ❌ Not applicable |
| INSERT/UPDATE/DELETE | ✅ Use DB:: | ❌ Not applicable |
| CREATE TABLE | ⚠️ Possible but not recommended | ✅ Use Schema:: |
| ALTER TABLE | ⚠️ Possible but not recommended | ✅ Use Schema:: |
| Add/Drop Columns | ❌ Don't use | ✅ Use Schema:: |
| Manage Indexes | ❌ Don't use | ✅ Use Schema:: |
| Foreign Keys | ❌ Don't use | ✅ Use Schema:: |
| Check Table/Column Exists | ✅ Can use | ✅ Preferred |
| Raw SQL execution | ✅ Use DB:: | ❌ Not applicable |
| Database agnostic code | ⚠️ Limited | ✅ Full support |

#### Best Practice Example:
```php
// In Migrations (database structure) - Use Schema::
public function up()
{
    Schema::create('orders', function (Blueprint $table) {
        $table->id();
        $table->foreignId('user_id')->constrained();
        $table->decimal('total', 10, 2);
        $table->enum('status', ['pending', 'completed', 'cancelled']);
        $table->timestamps();
    });
}

// In Application Code (data operations) - Use DB:: or Eloquent
public function processOrder($userId, $items)
{
    return DB::transaction(function () use ($userId, $items) {
        $orderId = DB::table('orders')->insertGetId([
            'user_id' => $userId,
            'total' => collect($items)->sum('price'),
            'status' => 'pending',
            'created_at' => now(),
            'updated_at' => now()
        ]);
        
        DB::table('order_items')->insert(
            collect($items)->map(fn($item) => [
                'order_id' => $orderId,
                'product_id' => $item['id'],
                'quantity' => $item['quantity'],
                'price' => $item['price']
            ])->toArray()
        );
        
        return $orderId;
    });
}
```

---

### 📝 Best Practices Summary:

#### For Database Queries:
- **Simple queries**: DB:: is fine
- **Complex relationships**: Use Eloquent
- **Business logic**: Implement in Models/Services
- **Data access patterns**: Use Repositories

#### For Database Structure:
- **Table creation/modification**: Always use migrations
- **Schema changes**: Use Schema:: builder
- **Production changes**: Test migrations in staging first
- **Rollback plan**: Always implement down() method

#### For Failover Management:
1. **Monitor Connection Health**: Implement regular health checks
2. **Log Failures**: Track which connections fail and when
3. **Circuit Breaker Pattern**: Temporarily skip known-bad connections
4. **Load Balancing**: Distribute read queries across healthy replicas
5. **Graceful Degradation**: Have a plan when all connections fail
