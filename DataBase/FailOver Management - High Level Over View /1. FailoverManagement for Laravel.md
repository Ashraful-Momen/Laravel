# Laravel Database Failover & Master-Slave Replication Complete Guide

## üìñ Table of Contents
1. [Laravel Database Architecture](#laravel-database-architecture)
2. [Environment Configuration](#environment-configuration)
3. [Laravel Database Configuration](#laravel-database-configuration)
4. [Model Configuration](#model-configuration)
5. [Service Layer Implementation](#service-layer-implementation)
6. [Middleware for Connection Management](#middleware-for-connection-management)
7. [Queue Configuration](#queue-configuration)
8. [Health Monitoring](#health-monitoring)
9. [Failover Implementation](#failover-implementation)
10. [Testing & Validation](#testing--validation)

---

## üéØ Laravel Database Architecture

### Laravel Read/Write Separation
```
Laravel Application
       ‚îÇ
       ‚îú‚îÄ‚îÄ Write Operations (INSERT, UPDATE, DELETE)
       ‚îÇ   ‚îî‚îÄ‚îÄ Master DB (10.0.1.10)
       ‚îÇ       ‚îî‚îÄ‚îÄ Binary Log
       ‚îÇ           ‚îî‚îÄ‚îÄ Slave DB (10.0.1.20)
       ‚îÇ               ‚îî‚îÄ‚îÄ Backup DB (10.0.1.30)
       ‚îÇ
       ‚îî‚îÄ‚îÄ Read Operations (SELECT)
           ‚îî‚îÄ‚îÄ Slave DB (10.0.1.20) [Load Balanced]
```

### Laravel Connection Benefits
- **Automatic Read/Write Separation**: Laravel handles connection routing
- **Connection Pooling**: Efficient database connection management
- **Transaction Safety**: Ensures data consistency across operations
- **Eloquent Integration**: Seamless ORM support with replication
- **Queue System Support**: Distributed queue processing across databases

---

## üîß Environment Configuration

### Laravel .env Configuration
```env
# Application Settings
APP_NAME="Laravel App with DB Replication"
APP_ENV=production
APP_DEBUG=false
APP_URL=https://myapp.com

# Master Database (Write Operations)
DB_CONNECTION=mysql
DB_WRITE_HOST=10.0.1.10
DB_WRITE_PORT=3306
DB_WRITE_DATABASE=laravel_production
DB_WRITE_USERNAME=laravel_user
DB_WRITE_PASSWORD=StrongPassword123!

# Slave Database (Read Operations)
DB_READ_HOST=10.0.1.20
DB_READ_PORT=3306
DB_READ_DATABASE=laravel_production
DB_READ_USERNAME=laravel_reader
DB_READ_PASSWORD=StrongPassword123!

# Backup Database (Disaster Recovery)
DB_BACKUP_HOST=10.0.1.30
DB_BACKUP_PORT=3306
DB_BACKUP_DATABASE=laravel_production
DB_BACKUP_USERNAME=laravel_backup
DB_BACKUP_PASSWORD=StrongPassword123!

# Connection Pool Settings
DB_POOL_MIN=5
DB_POOL_MAX=20
DB_TIMEOUT=30

# Replication Settings
DB_READ_WEIGHT=100
DB_WRITE_WEIGHT=0
DB_STICKY=true

# Queue Database Settings
QUEUE_CONNECTION=database
QUEUE_DB_CONNECTION=mysql_write

# Cache Database Settings
CACHE_DRIVER=database
CACHE_DB_CONNECTION=mysql_read

# Session Database Settings
SESSION_DRIVER=database
SESSION_DB_CONNECTION=mysql_write
```

---

## üìä Laravel Database Configuration

### config/database.php - Complete Configuration
```php
<?php

return [
    'default' => env('DB_CONNECTION', 'mysql'),

    'connections' => [
        
        // ===================================
        // MASTER DATABASE (WRITE OPERATIONS)
        // ===================================
        'mysql_write' => [
            'driver' => 'mysql',
            'host' => env('DB_WRITE_HOST', '10.0.1.10'),
            'port' => env('DB_WRITE_PORT', '3306'),
            'database' => env('DB_WRITE_DATABASE', 'laravel_production'),
            'username' => env('DB_WRITE_USERNAME', 'laravel_user'),
            'password' => env('DB_WRITE_PASSWORD', ''),
            'unix_socket' => env('DB_SOCKET', ''),
            'charset' => 'utf8mb4',
            'collation' => 'utf8mb4_unicode_ci',
            'prefix' => '',
            'prefix_indexes' => true,
            'strict' => true,
            'engine' => null,
            'options' => [
                PDO::ATTR_TIMEOUT => 30,                    // Connection timeout
                PDO::ATTR_PERSISTENT => true,               // Use persistent connections
                PDO::MYSQL_ATTR_USE_BUFFERED_QUERY => true, // Buffer query results
            ],
            // Write-specific settings
            'sticky' => true,                               // Stick to master after write
            'read_write_timeout' => 60,                     // Read/write timeout
        ],

        // ==================================
        // SLAVE DATABASE (READ OPERATIONS)
        // ==================================
        'mysql_read' => [
            'driver' => 'mysql',
            'host' => env('DB_READ_HOST', '10.0.1.20'),
            'port' => env('DB_READ_PORT', '3306'),
            'database' => env('DB_READ_DATABASE', 'laravel_production'),
            'username' => env('DB_READ_USERNAME', 'laravel_reader'),
            'password' => env('DB_READ_PASSWORD', ''),
            'unix_socket' => env('DB_SOCKET', ''),
            'charset' => 'utf8mb4',
            'collation' => 'utf8mb4_unicode_ci',
            'prefix' => '',
            'prefix_indexes' => true,
            'strict' => true,
            'engine' => null,
            'options' => [
                PDO::ATTR_TIMEOUT => 30,
                PDO::ATTR_PERSISTENT => true,
                PDO::MYSQL_ATTR_USE_BUFFERED_QUERY => true,
            ],
            // Read-specific settings
            'read_timeout' => 15,                           // Shorter timeout for reads
        ],

        // =====================================
        // BACKUP DATABASE (DISASTER RECOVERY)
        // =====================================
        'mysql_backup' => [
            'driver' => 'mysql',
            'host' => env('DB_BACKUP_HOST', '10.0.1.30'),
            'port' => env('DB_BACKUP_PORT', '3306'),
            'database' => env('DB_BACKUP_DATABASE', 'laravel_production'),
            'username' => env('DB_BACKUP_USERNAME', 'laravel_backup'),
            'password' => env('DB_BACKUP_PASSWORD', ''),
            'unix_socket' => env('DB_SOCKET', ''),
            'charset' => 'utf8mb4',
            'collation' => 'utf8mb4_unicode_ci',
            'prefix' => '',
            'prefix_indexes' => true,
            'strict' => true,
            'engine' => null,
            'options' => [
                PDO::ATTR_TIMEOUT => 60,                    // Longer timeout for backup
            ],
        ],

        // ===============================================
        // COMBINED CONNECTION (AUTOMATIC READ/WRITE SEPARATION)
        // ===============================================
        'mysql' => [
            'read' => [
                'host' => [
                    env('DB_READ_HOST', '10.0.1.20'),       // Primary read server
                    // Add more read slaves here for load balancing
                    // 'slave2.example.com',
                    // 'slave3.example.com',
                ],
                'port' => env('DB_READ_PORT', '3306'),
                'database' => env('DB_READ_DATABASE', 'laravel_production'),
                'username' => env('DB_READ_USERNAME', 'laravel_reader'),
                'password' => env('DB_READ_PASSWORD', ''),
            ],
            'write' => [
                'host' => [
                    env('DB_WRITE_HOST', '10.0.1.10'),      // Primary write server
                ],
                'port' => env('DB_WRITE_PORT', '3306'),
                'database' => env('DB_WRITE_DATABASE', 'laravel_production'),
                'username' => env('DB_WRITE_USERNAME', 'laravel_user'),
                'password' => env('DB_WRITE_PASSWORD', ''),
            ],
            'driver' => 'mysql',
            'unix_socket' => env('DB_SOCKET', ''),
            'charset' => 'utf8mb4',
            'collation' => 'utf8mb4_unicode_ci',
            'prefix' => '',
            'prefix_indexes' => true,
            'strict' => true,
            'engine' => null,
            'options' => [
                PDO::ATTR_TIMEOUT => 30,
                PDO::ATTR_PERSISTENT => false,              // Don't use persistent for load balanced
                PDO::MYSQL_ATTR_USE_BUFFERED_QUERY => true,
            ],
            // Laravel read/write separation settings
            'sticky' => env('DB_STICKY', true),             // Stick to master after write
        ],
    ],

    'migrations' => 'migrations',

    'redis' => [
        'client' => env('REDIS_CLIENT', 'phpredis'),
        'options' => [
            'cluster' => env('REDIS_CLUSTER', 'redis'),
            'prefix' => env('REDIS_PREFIX', Str::slug(env('APP_NAME', 'laravel'), '_').'_database_'),
        ],
        'default' => [
            'url' => env('REDIS_URL'),
            'host' => env('REDIS_HOST', '127.0.0.1'),
            'password' => env('REDIS_PASSWORD', null),
            'port' => env('REDIS_PORT', '6379'),
            'database' => env('REDIS_DB', '0'),
        ],
        'cache' => [
            'url' => env('REDIS_URL'),
            'host' => env('REDIS_HOST', '127.0.0.1'),
            'password' => env('REDIS_PASSWORD', null),
            'port' => env('REDIS_PORT', '6379'),
            'database' => env('REDIS_CACHE_DB', '1'),
        ],
    ],
];
```

---

## üèóÔ∏è Model Configuration

### Base Model for Database Replication
```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Model;
use Illuminate\Support\Facades\DB;

abstract class ReplicatedModel extends Model
{
    /**
     * Force read operations to use slave database
     */
    protected $connection = 'mysql'; // Uses automatic read/write separation

    /**
     * Explicitly read from slave database
     */
    public static function readFromSlave()
    {
        return (new static)->setConnection('mysql_read');
    }

    /**
     * Explicitly write to master database
     */
    public static function writeToMaster()
    {
        return (new static)->setConnection('mysql_write');
    }

    /**
     * Read from backup database (for reporting/analytics)
     */
    public static function readFromBackup()
    {
        return (new static)->setConnection('mysql_backup');
    }

    /**
     * Force fresh read from master (avoid read-after-write issues)
     */
    public static function freshFromMaster()
    {
        return (new static)->setConnection('mysql_write');
    }

    /**
     * Override save to ensure writes go to master
     */
    public function save(array $options = [])
    {
        // Temporarily switch to master for write operations
        $originalConnection = $this->getConnectionName();
        $this->setConnection('mysql_write');
        
        $result = parent::save($options);
        
        // Switch back to original connection
        $this->setConnection($originalConnection);
        
        return $result;
    }

    /**
     * Override delete to ensure deletes go to master
     */
    public function delete()
    {
        $originalConnection = $this->getConnectionName();
        $this->setConnection('mysql_write');
        
        $result = parent::delete();
        
        $this->setConnection($originalConnection);
        
        return $result;
    }
}
```

### User Model with Replication Support
```php
<?php

namespace App\Models;

use Illuminate\Contracts\Auth\MustVerifyEmail;
use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Foundation\Auth\User as Authenticatable;
use Illuminate\Notifications\Notifiable;
use Laravel\Sanctum\HasApiTokens;

class User extends ReplicatedModel implements MustVerifyEmail
{
    use HasApiTokens, HasFactory, Notifiable;

    protected $fillable = [
        'name',
        'email',
        'password',
        'email_verified_at',
    ];

    protected $hidden = [
        'password',
        'remember_token',
    ];

    protected $casts = [
        'email_verified_at' => 'datetime',
        'password' => 'hashed',
    ];

    /**
     * Get all users for dashboard (read from slave)
     */
    public static function getAllForDashboard()
    {
        return static::readFromSlave()
            ->select('id', 'name', 'email', 'created_at')
            ->orderBy('created_at', 'desc')
            ->get();
    }

    /**
     * Get user immediately after creation (read from master)
     */
    public static function getAfterCreation($id)
    {
        return static::freshFromMaster()
            ->where('id', $id)
            ->first();
    }

    /**
     * Analytics query (read from backup to reduce load)
     */
    public static function getAnalyticsData($startDate, $endDate)
    {
        return static::readFromBackup()
            ->whereBetween('created_at', [$startDate, $endDate])
            ->selectRaw('DATE(created_at) as date, COUNT(*) as count')
            ->groupBy('date')
            ->orderBy('date')
            ->get();
    }

    /**
     * Search users (can use slave for better performance)
     */
    public static function searchUsers($query)
    {
        return static::readFromSlave()
            ->where('name', 'LIKE', "%{$query}%")
            ->orWhere('email', 'LIKE', "%{$query}%")
            ->limit(50)
            ->get();
    }
}
```

### Product Model Example
```php
<?php

namespace App\Models;

class Product extends ReplicatedModel
{
    protected $fillable = [
        'name',
        'description',
        'price',
        'category_id',
        'stock_quantity',
        'is_active',
    ];

    protected $casts = [
        'price' => 'decimal:2',
        'is_active' => 'boolean',
    ];

    /**
     * Get products for catalog (read from slave)
     */
    public static function getCatalogProducts($categoryId = null)
    {
        $query = static::readFromSlave()
            ->where('is_active', true)
            ->where('stock_quantity', '>', 0);

        if ($categoryId) {
            $query->where('category_id', $categoryId);
        }

        return $query->orderBy('name')->paginate(20);
    }

    /**
     * Update stock quantity (write to master)
     */
    public function updateStock($newQuantity)
    {
        return static::writeToMaster()
            ->where('id', $this->id)
            ->update(['stock_quantity' => $newQuantity]);
    }

    /**
     * Get sales analytics (read from backup)
     */
    public static function getSalesAnalytics($startDate, $endDate)
    {
        return static::readFromBackup()
            ->join('order_items', 'products.id', '=', 'order_items.product_id')
            ->join('orders', 'order_items.order_id', '=', 'orders.id')
            ->whereBetween('orders.created_at', [$startDate, $endDate])
            ->selectRaw('
                products.name,
                SUM(order_items.quantity) as total_sold,
                SUM(order_items.quantity * order_items.price) as total_revenue
            ')
            ->groupBy('products.id', 'products.name')
            ->orderBy('total_revenue', 'desc')
            ->get();
    }
}
```

---

## üîß Service Layer Implementation

### Database Service Provider
```php
<?php

namespace App\Providers;

use Illuminate\Support\ServiceProvider;
use Illuminate\Database\Events\ConnectionFailed;
use Illuminate\Support\Facades\Event;
use Illuminate\Support\Facades\Log;
use App\Services\DatabaseHealthService;
use App\Services\DatabaseFailoverService;

class DatabaseServiceProvider extends ServiceProvider
{
    /**
     * Register services.
     */
    public function register()
    {
        $this->app->singleton(DatabaseHealthService::class);
        $this->app->singleton(DatabaseFailoverService::class);
    }

    /**
     * Bootstrap services.
     */
    public function boot()
    {
        // Listen for database connection failures
        Event::listen(ConnectionFailed::class, function ($event) {
            Log::error('Database connection failed', [
                'connection' => $event->connectionName,
                'exception' => $event->exception->getMessage()
            ]);

            // Trigger failover if master fails
            if ($event->connectionName === 'mysql_write') {
                app(DatabaseFailoverService::class)->handleMasterFailure();
            }
        });

        // Monitor database health every 5 minutes
        if ($this->app->runningInConsole()) {
            $this->commands([
                \App\Console\Commands\MonitorDatabaseHealth::class,
                \App\Console\Commands\TestDatabaseConnections::class,
            ]);
        }
    }
}
```

### Database Health Service
```php
<?php

namespace App\Services;

use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Cache;

class DatabaseHealthService
{
    protected $connections = ['mysql_write', 'mysql_read', 'mysql_backup'];

    /**
     * Check health of all database connections
     */
    public function checkAllConnections()
    {
        $results = [];

        foreach ($this->connections as $connection) {
            $results[$connection] = $this->checkConnection($connection);
        }

        return $results;
    }

    /**
     * Check health of specific database connection
     */
    public function checkConnection($connectionName)
    {
        try {
            $startTime = microtime(true);
            
            // Simple health check query
            DB::connection($connectionName)->select('SELECT 1 as health_check');
            
            $responseTime = round((microtime(true) - $startTime) * 1000, 2);

            // Cache healthy status
            Cache::put("db_health_{$connectionName}", true, 300); // 5 minutes

            return [
                'status' => 'healthy',
                'response_time_ms' => $responseTime,
                'timestamp' => now(),
                'connection' => $connectionName
            ];

        } catch (\Exception $e) {
            // Cache unhealthy status
            Cache::put("db_health_{$connectionName}", false, 60); // 1 minute

            Log::error("Database health check failed for {$connectionName}", [
                'connection' => $connectionName,
                'error' => $e->getMessage(),
                'trace' => $e->getTraceAsString()
            ]);

            return [
                'status' => 'unhealthy',
                'error' => $e->getMessage(),
                'timestamp' => now(),
                'connection' => $connectionName
            ];
        }
    }

    /**
     * Check replication lag on slave
     */
    public function checkReplicationLag($slaveConnection = 'mysql_read')
    {
        try {
            $result = DB::connection($slaveConnection)
                ->select('SHOW SLAVE STATUS')[0];

            $lag = $result->Seconds_Behind_Master ?? null;

            if ($lag === null) {
                return [
                    'status' => 'error',
                    'message' => 'Replication not running'
                ];
            }

            if ($lag > 60) {
                Log::warning("High replication lag detected", [
                    'lag_seconds' => $lag,
                    'connection' => $slaveConnection
                ]);
            }

            return [
                'status' => 'ok',
                'lag_seconds' => $lag,
                'io_running' => $result->Slave_IO_Running === 'Yes',
                'sql_running' => $result->Slave_SQL_Running === 'Yes',
            ];

        } catch (\Exception $e) {
            Log::error("Failed to check replication lag", [
                'connection' => $slaveConnection,
                'error' => $e->getMessage()
            ]);

            return [
                'status' => 'error',
                'message' => $e->getMessage()
            ];
        }
    }

    /**
     * Get database connection statistics
     */
    public function getConnectionStats($connectionName)
    {
        try {
            $stats = DB::connection($connectionName)->select('
                SELECT 
                    VARIABLE_NAME,
                    VARIABLE_VALUE 
                FROM information_schema.GLOBAL_STATUS 
                WHERE VARIABLE_NAME IN (
                    "Connections",
                    "Max_used_connections",
                    "Threads_connected",
                    "Threads_running",
                    "Queries",
                    "Slow_queries",
                    "Uptime"
                )
            ');

            return collect($stats)->mapWithKeys(function ($stat) {
                return [$stat->VARIABLE_NAME => $stat->VARIABLE_VALUE];
            })->toArray();

        } catch (\Exception $e) {
            Log::error("Failed to get connection stats", [
                'connection' => $connectionName,
                'error' => $e->getMessage()
            ]);

            return [];
        }
    }

    /**
     * Check if connection is healthy (cached result)
     */
    public function isConnectionHealthy($connectionName)
    {
        return Cache::get("db_health_{$connectionName}", false);
    }
}
```

### Database Failover Service
```php
<?php

namespace App\Services;

use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Artisan;

class DatabaseFailoverService
{
    protected $healthService;

    public function __construct(DatabaseHealthService $healthService)
    {
        $this->healthService = $healthService;
    }

    /**
     * Handle master database failure
     */
    public function handleMasterFailure()
    {
        Log::critical('Master database failure detected - initiating failover');

        // Check if slave is healthy
        if (!$this->healthService->isConnectionHealthy('mysql_read')) {
            $this->handleCriticalFailure();
            return;
        }

        // Promote slave to master
        $this->promoteSlaveToMaster();
        
        // Update application configuration
        $this->updateApplicationConfig();
        
        // Notify administrators
        $this->notifyAdministrators('master_failed');
    }

    /**
     * Promote slave to master
     */
    protected function promoteSlaveToMaster()
    {
        try {
            // Stop replication on slave
            DB::connection('mysql_read')->statement('STOP SLAVE');
            
            // Make slave writable
            DB::connection('mysql_read')->statement('SET GLOBAL read_only = OFF');
            
            // Update environment configuration
            $this->swapMasterSlaveConfig();
            
            Log::info('Slave successfully promoted to master');
            
        } catch (\Exception $e) {
            Log::error('Failed to promote slave to master', [
                'error' => $e->getMessage()
            ]);
        }
    }

    /**
     * Update application configuration for failover
     */
    protected function updateApplicationConfig()
    {
        // Update .env file to swap master/slave IPs
        $envPath = base_path('.env');
        $envContent = file_get_contents($envPath);
        
        // Backup original .env
        file_put_contents($envPath . '.backup', $envContent);
        
        // Swap master and slave hosts
        $originalMaster = env('DB_WRITE_HOST');
        $originalSlave = env('DB_READ_HOST');
        
        $envContent = str_replace(
            "DB_WRITE_HOST={$originalMaster}",
            "DB_WRITE_HOST={$originalSlave}",
            $envContent
        );
        
        $envContent = str_replace(
            "DB_READ_HOST={$originalSlave}",
            "DB_READ_HOST={$originalMaster}",
            $envContent
        );
        
        file_put_contents($envPath, $envContent);
        
        // Clear configuration cache
        Artisan::call('config:clear');
        Artisan::call('config:cache');
        
        Log::info('Application configuration updated for failover');
    }

    /**
     * Handle critical failure (both master and slave down)
     */
    protected function handleCriticalFailure()
    {
        Log::critical('CRITICAL: Both master and slave databases are down');
        
        // Check if backup is available
        if ($this->healthService->isConnectionHealthy('mysql_backup')) {
            Log::info('Backup database is available - attempting emergency failover');
            $this->emergencyFailoverToBackup();
        } else {
            Log::critical('ALL databases are down - manual intervention required');
            $this->notifyAdministrators('critical_failure');
        }
    }

    /**
     * Emergency failover to backup database
     */
    protected function emergencyFailoverToBackup()
    {
        try {
            // Update configuration to use backup as master
            $this->updateConfigForBackupFailover();
            
            // Clear caches
            Artisan::call('config:clear');
            Artisan::call('config:cache');
            
            Log::info('Emergency failover to backup database completed');
            $this->notifyAdministrators('backup_failover');
            
        } catch (\Exception $e) {
            Log::error('Emergency failover failed', [
                'error' => $e->getMessage()
            ]);
        }
    }

    /**
     * Notify administrators of database issues
     */
    protected function notifyAdministrators($type)
    {
        $messages = [
            'master_failed' => 'Master database failed - slave promoted to master',
            'critical_failure' => 'CRITICAL: All databases are down - immediate action required',
            'backup_failover' => 'Emergency failover to backup database completed'
        ];

        $message = $messages[$type] ?? 'Database issue detected';

        // Send notifications (email, Slack, etc.)
        // You can implement your preferred notification method here
        
        Log::critical($message);
        
        // Example: Send email notification
        // Mail::to('admin@yourapp.com')->send(new DatabaseFailoverAlert($message));
    }
}
```

---

## üö¶ Middleware for Connection Management

### Database Connection Middleware
```php
<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\DB;
use App\Services\DatabaseHealthService;

class DatabaseConnectionMiddleware
{
    protected $healthService;

    public function __construct(DatabaseHealthService $healthService)
    {
        $this->healthService = $healthService;
    }

    /**
     * Handle an incoming request.
     */
    public function handle(Request $request, Closure $next)
    {
        // Check if we should force master connection
        if ($this->shouldForceMaster($request)) {
            $this->forceMasterConnection();
        }

        // Check database health before processing request
        if (!$this->healthService->isConnectionHealthy('mysql')) {
            return response()->json([
                'error' => 'Database temporarily unavailable',
                'message' => 'Please try again in a few moments'
            ], 503);
        }

        $response = $next($request);

        // Log slow database queries
        $this->logSlowQueries();

        return $response;
    }

    /**
     * Determine if we should force master connection
     */
    protected function shouldForceMaster(Request $request)
    {
        // Force master for write operations
        if (in_array($request->method(), ['POST', 'PUT', 'PATCH', 'DELETE'])) {
            return true;
        }

        // Force master for specific routes that need fresh data
        $masterRoutes = [
            'user.profile',
            'orders.recent',
            'payments.confirm'
        ];

        return in_array($request->route()->getName(), $masterRoutes);
    }

    /**
     * Force connection to master database
     */
    protected function forceMasterConnection()
    {
        config(['database.default' => 'mysql_write']);
    }

    /**
     * Log slow database queries
     */
    protected function logSlowQueries()
    {
        foreach (DB::getQueryLog() as $query) {
            if ($query['time'] > 1000) { // Log queries taking more than 1 second
                \Log::warning('Slow database query detected', [
                    'query' => $query['query'],
                    'bindings' => $query['bindings'],
                    'time' => $query['time'] . 'ms'
                ]);
            }
        }
    }
}
```

### Read-Only Middleware
```php
<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;

class ReadOnlyMiddleware
{
    /**
     * Handle an incoming request.
     */
    public function handle(Request $request, Closure $next)
    {
        // Force read connection for GET requests to specific routes
        if ($request->isMethod('GET')) {
            config(['database.default' => 'mysql_read']);
        }

        $response = $next($request);

        // Reset to default connection
        config(['database.default' => 'mysql']);

        return $response;
    }
}
```

---

## üì° Queue Configuration

### Queue Service for Database Replication
```php
<?php

namespace App\Services;

use Illuminate\Queue\SerializesModels;
use Illuminate\Bus\Queueable;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Foundation\Bus\Dispatchable;

class DatabaseReplicationJob implements ShouldQueue
{
    use Dispatchable, Queueable, SerializesModels;

    protected $operation;
    protected $data;

    public function __construct($operation, $data)
    {
        $this->operation = $operation;
        $this->data = $data;
        
        // Use master database connection for queue
        $this->connection = 'mysql_write';
    }

    /**
     * Execute the job.
     */
    public function handle()
    {
        switch ($this->operation) {
            case 'sync_user_data':
                $this->syncUserData();
                break;
            case 'verify_replication':
                $this->verifyReplication();
                break;
            case 'cleanup_old_data':
                $this->cleanupOldData();
                break;
        }
    }

    /**
     * Sync user data across databases
     */
    protected function syncUserData()
    {
        try {
            // Get data from master
            $masterData = DB::connection('mysql_write')
                ->table('users')
                ->where('updated_at', '>', now()->subMinutes(5))
                ->get();

            // Verify data exists on slave
            foreach ($masterData as $record) {
                $slaveRecord = DB::connection('mysql_read')
                    ->table('users')
                    ->where('id', $record->id)
                    ->where('updated_at', $record->updated_at)
                    ->first();

                if (!$slaveRecord) {
                    \Log::warning('Data sync issue detected', [
                        'table' => 'users',
                        'record_id' => $record->id,
                        'master_updated_at' => $record->updated_at
                    ]);
                }
            }

        } catch (\Exception $e) {
            \Log::error('Failed to sync user data', [
                'error' => $e->getMessage()
            ]);
        }
    }

    /**
     * Verify replication is working
     */
    protected function verifyReplication()
    {
        try {
            // Insert test record on master
            $testId = DB::connection('mysql_write')
                ->table('replication_test')
                ->insertGetId([
                    'test_data' => 'replication_check_' . time(),
                    'created_at' => now(),
                    'updated_at' => now()
                ]);

            // Wait a few seconds for replication
            sleep(3);

            // Check if record exists on slave
            $slaveRecord = DB::connection('mysql_read')
                ->table('replication_test')
                ->where('id', $testId)
                ->first();

            if ($slaveRecord) {
                \Log::info('Replication test passed', ['test_id' => $testId]);
                
                // Cleanup test record
                DB::connection('mysql_write')
                    ->table('replication_test')
                    ->where('id', $testId)
                    ->delete();
            } else {
                \Log::error('Replication test failed', [
                    'test_id' => $testId,
                    'message' => 'Record not found on slave'
                ]);
            }

        } catch (\Exception $e) {
            \Log::error('Replication verification failed', [
                'error' => $e->getMessage()
            ]);
        }
    }

    /**
     * Cleanup old data from all databases
     */
    protected function cleanupOldData()
    {
        try {
            $connections = ['mysql_write', 'mysql_read', 'mysql_backup'];
            
            foreach ($connections as $connection) {
                // Delete old log entries (older than 30 days)
                DB::connection($connection)
                    ->table('activity_logs')
                    ->where('created_at', '<', now()->subDays(30))
                    ->delete();

                // Delete old temporary files
                DB::connection($connection)
                    ->table('temporary_files')
                    ->where('created_at', '<', now()->subHours(24))
                    ->delete();
            }

            \Log::info('Old data cleanup completed');

        } catch (\Exception $e) {
            \Log::error('Data cleanup failed', [
                'error' => $e->getMessage()
            ]);
        }
    }
}
```

### Queue Configuration for Database Connections
```php
// config/queue.php

'connections' => [
    'database' => [
        'driver' => 'database',
        'table' => 'jobs',
        'queue' => 'default',
        'retry_after' => 90,
        'after_commit' => false,
        // Use master database for queue operations
        'connection' => 'mysql_write',
    ],

    'database_read' => [
        'driver' => 'database',
        'table' => 'jobs',
        'queue' => 'read_operations',
        'retry_after' => 90,
        'after_commit' => false,
        // Use slave database for read-heavy queue operations
        'connection' => 'mysql_read',
    ],
],
```

---

## üéØ Health Monitoring

### Console Command for Database Health Monitoring
```php
<?php

namespace App\Console\Commands;

use Illuminate\Console\Command;
use App\Services\DatabaseHealthService;
use App\Services\DatabaseFailoverService;

class MonitorDatabaseHealth extends Command
{
    protected $signature = 'db:monitor {--notify : Send notifications on issues}';
    protected $description = 'Monitor database health and replication status';

    protected $healthService;
    protected $failoverService;

    public function __construct(DatabaseHealthService $healthService, DatabaseFailoverService $failoverService)
    {
        parent::__construct();
        $this->healthService = $healthService;
        $this->failoverService = $failoverService;
    }

    public function handle()
    {
        $this->info('üîç Monitoring database health...');

        // Check all database connections
        $healthResults = $this->healthService->checkAllConnections();

        foreach ($healthResults as $connection => $result) {
            if ($result['status'] === 'healthy') {
                $this->info("‚úÖ {$connection}: Healthy ({$result['response_time_ms']}ms)");
            } else {
                $this->error("‚ùå {$connection}: {$result['error']}");
                
                if ($connection === 'mysql_write') {
                    $this->warn('üö® Master database issue detected - checking failover options...');
                    // Trigger failover process
                    $this->failoverService->handleMasterFailure();
                }
            }
        }

        // Check replication lag
        $replicationStatus = $this->healthService->checkReplicationLag();
        
        if ($replicationStatus['status'] === 'ok') {
            $lag = $replicationStatus['lag_seconds'];
            if ($lag > 30) {
                $this->warn("‚ö†Ô∏è  High replication lag: {$lag} seconds");
            } else {
                $this->info("üîÑ Replication lag: {$lag} seconds");
            }
        } else {
            $this->error("‚ùå Replication issue: {$replicationStatus['message']}");
        }

        // Display connection statistics
        $this->displayConnectionStats();

        $this->info('‚úÖ Database health monitoring completed');
    }

    protected function displayConnectionStats()
    {
        $this->info("\nüìä Database Connection Statistics:");
        
        $connections = ['mysql_write', 'mysql_read', 'mysql_backup'];
        
        foreach ($connections as $connection) {
            $stats = $this->healthService->getConnectionStats($connection);
            
            if (!empty($stats)) {
                $this->table(
                    ['Connection', 'Metric', 'Value'],
                    collect($stats)->map(function ($value, $key) use ($connection) {
                        return [$connection, $key, $value];
                    })->toArray()
                );
            }
        }
    }
}
```

### Test Database Connections Command
```php
<?php

namespace App\Console\Commands;

use Illuminate\Console\Command;
use Illuminate\Support\Facades\DB;

class TestDatabaseConnections extends Command
{
    protected $signature = 'db:test {--connection=* : Specific connections to test}';
    protected $description = 'Test all database connections and replication';

    public function handle()
    {
        $this->info('üß™ Testing database connections...');

        $connections = $this->option('connection') 
            ? $this->option('connection')
            : ['mysql_write', 'mysql_read', 'mysql_backup', 'mysql'];

        foreach ($connections as $connection) {
            $this->testConnection($connection);
        }

        // Test read/write separation
        $this->testReadWriteSeparation();

        // Test replication
        $this->testReplication();

        $this->info('‚úÖ Database connection testing completed');
    }

    protected function testConnection($connectionName)
    {
        try {
            $startTime = microtime(true);
            
            $result = DB::connection($connectionName)->select('SELECT CONNECTION_ID() as id, DATABASE() as db');
            
            $responseTime = round((microtime(true) - $startTime) * 1000, 2);
            
            $this->info("‚úÖ {$connectionName}: Connected (ID: {$result[0]->id}, DB: {$result[0]->db}, {$responseTime}ms)");
            
        } catch (\Exception $e) {
            $this->error("‚ùå {$connectionName}: {$e->getMessage()}");
        }
    }

    protected function testReadWriteSeparation()
    {
        $this->info("\nüîÑ Testing read/write separation...");

        try {
            // Test write operation (should go to master)
            $testData = 'test_' . time();
            
            DB::table('connection_tests')->insert([
                'test_data' => $testData,
                'created_at' => now(),
                'updated_at' => now()
            ]);

            $this->info("‚úÖ Write operation completed");

            // Test read operation (should come from slave)
            $readResult = DB::table('connection_tests')
                ->where('test_data', $testData)
                ->first();

            if ($readResult) {
                $this->info("‚úÖ Read operation completed - data found");
                
                // Cleanup
                DB::table('connection_tests')
                    ->where('test_data', $testData)
                    ->delete();
            } else {
                $this->warn("‚ö†Ô∏è  Read operation completed - data not yet replicated");
            }

        } catch (\Exception $e) {
            $this->error("‚ùå Read/write separation test failed: {$e->getMessage()}");
        }
    }

    protected function testReplication()
    {
        $this->info("\nüîÑ Testing replication status...");

        try {
            $slaveStatus = DB::connection('mysql_read')->select('SHOW SLAVE STATUS');
            
            if (empty($slaveStatus)) {
                $this->warn("‚ö†Ô∏è  No slave status found - replication may not be configured");
                return;
            }

            $status = $slaveStatus[0];
            
            $this->table(
                ['Metric', 'Value'],
                [
                    ['Slave_IO_Running', $status->Slave_IO_Running],
                    ['Slave_SQL_Running', $status->Slave_SQL_Running],
                    ['Seconds_Behind_Master', $status->Seconds_Behind_Master ?? 'NULL'],
                    ['Master_Host', $status->Master_Host],
                    ['Master_Log_File', $status->Master_Log_File],
                    ['Read_Master_Log_Pos', $status->Read_Master_Log_Pos],
                    ['Last_Error', $status->Last_Error ?: 'None'],
                ]
            );

            if ($status->Slave_IO_Running === 'Yes' && $status->Slave_SQL_Running === 'Yes') {
                $this->info("‚úÖ Replication is running properly");
            } else {
                $this->error("‚ùå Replication has issues");
            }

        } catch (\Exception $e) {
            $this->error("‚ùå Replication test failed: {$e->getMessage()}");
        }
    }
}
```

### Scheduling Database Monitoring
```php
// app/Console/Kernel.php

protected function schedule(Schedule $schedule)
{
    // Monitor database health every 5 minutes
    $schedule->command('db:monitor --notify')
        ->everyFiveMinutes()
        ->withoutOverlapping()
        ->runInBackground();

    // Test connections every hour
    $schedule->command('db:test')
        ->hourly()
        ->withoutOverlapping();

    // Run replication verification job every 15 minutes
    $schedule->job(new DatabaseReplicationJob('verify_replication', []))
        ->everyFifteenMinutes();

    // Daily data cleanup
    $schedule->job(new DatabaseReplicationJob('cleanup_old_data', []))
        ->daily()
        ->at('02:00');

    // Sync user data every 10 minutes
    $schedule->job(new DatabaseReplicationJob('sync_user_data', []))
        ->everyTenMinutes();
}
```

---

## üîß Controller Examples

### User Controller with Database Replication
```php
<?php

namespace App\Http\Controllers;

use App\Models\User;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\DB;

class UserController extends Controller
{
    /**
     * Display users list (read from slave)
     */
    public function index(Request $request)
    {
        // Use slave database for reading user list
        $users = User::readFromSlave()
            ->when($request->search, function ($query, $search) {
                return $query->where('name', 'like', "%{$search}%")
                           ->orWhere('email', 'like', "%{$search}%");
            })
            ->orderBy('created_at', 'desc')
            ->paginate(20);

        return response()->json([
            'users' => $users,
            'connection_used' => 'slave'
        ]);
    }

    /**
     * Create new user (write to master)
     */
    public function store(Request $request)
    {
        $validated = $request->validate([
            'name' => 'required|string|max:255',
            'email' => 'required|string|email|unique:users',
            'password' => 'required|string|min:8',
        ]);

        // Use master database for creating user
        $user = User::writeToMaster()->create([
            'name' => $validated['name'],
            'email' => $validated['email'],
            'password' => bcrypt($validated['password']),
        ]);

        // Read the created user from master to ensure we get fresh data
        $freshUser = User::freshFromMaster()->find($user->id);

        return response()->json([
            'user' => $freshUser,
            'message' => 'User created successfully',
            'connection_used' => 'master'
        ], 201);
    }

    /**
     * Show user details (read from master for fresh data)
     */
    public function show($id)
    {
        // Use master for user profile to ensure fresh data
        $user = User::freshFromMaster()
            ->with(['profile', 'orders'])
            ->findOrFail($id);

        return response()->json([
            'user' => $user,
            'connection_used' => 'master'
        ]);
    }

    /**
     * Update user (write to master, then read fresh data)
     */
    public function update(Request $request, $id)
    {
        $validated = $request->validate([
            'name' => 'sometimes|string|max:255',
            'email' => 'sometimes|string|email|unique:users,email,' . $id,
        ]);

        // Update on master
        $user = User::writeToMaster()->findOrFail($id);
        $user->update($validated);

        // Read fresh data from master
        $updatedUser = User::freshFromMaster()->find($id);

        return response()->json([
            'user' => $updatedUser,
            'message' => 'User updated successfully',
            'connection_used' => 'master'
        ]);
    }

    /**
     * Get analytics data (read from backup to reduce load)
     */
    public function analytics(Request $request)
    {
        $startDate = $request->input('start_date', now()->subDays(30));
        $endDate = $request->input('end_date', now());

        // Use backup database for analytics to avoid impacting main operations
        $analytics = User::getAnalyticsData($startDate, $endDate);

        // Get additional stats from backup
        $totalUsers = User::readFromBackup()->count();
        $activeUsers = User::readFromBackup()
            ->where('last_login_at', '>', now()->subDays(30))
            ->count();

        return response()->json([
            'analytics' => $analytics,
            'total_users' => $totalUsers,
            'active_users' => $activeUsers,
            'connection_used' => 'backup'
        ]);
    }
}
```

### Order Controller Example
```php
<?php

namespace App\Http\Controllers;

use App\Models\Order;
use App\Models\Product;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\DB;

class OrderController extends Controller
{
    /**
     * Get user orders (read from slave)
     */
    public function index(Request $request)
    {
        $orders = Order::readFromSlave()
            ->where('user_id', $request->user()->id)
            ->with(['items.product'])
            ->orderBy('created_at', 'desc')
            ->paginate(10);

        return response()->json([
            'orders' => $orders,
            'connection_used' => 'slave'
        ]);
    }

    /**
     * Create new order (write to master with transaction)
     */
    public function store(Request $request)
    {
        $validated = $request->validate([
            'items' => 'required|array',
            'items.*.product_id' => 'required|exists:products,id',
            'items.*.quantity' => 'required|integer|min:1',
        ]);

        // Use database transaction on master
        return DB::connection('mysql_write')->transaction(function () use ($validated, $request) {
            
            // Create order
            $order = Order::writeToMaster()->create([
                'user_id' => $request->user()->id,
                'status' => 'pending',
                'total_amount' => 0,
            ]);

            $totalAmount = 0;

            // Process order items
            foreach ($validated['items'] as $item) {
                $product = Product::writeToMaster()->findOrFail($item['product_id']);
                
                // Check stock
                if ($product->stock_quantity < $item['quantity']) {
                    throw new \Exception("Insufficient stock for product: {$product->name}");
                }

                // Create order item
                $orderItem = $order->items()->create([
                    'product_id' => $product->id,
                    'quantity' => $item['quantity'],
                    'price' => $product->price,
                    'total' => $product->price * $item['quantity'],
                ]);

                // Update product stock
                $product->decrement('stock_quantity', $item['quantity']);

                $totalAmount += $orderItem->total;
            }

            // Update order total
            $order->update(['total_amount' => $totalAmount]);

            // Read fresh order data from master
            $freshOrder = Order::freshFromMaster()
                ->with(['items.product', 'user'])
                ->find($order->id);

            return response()->json([
                'order' => $freshOrder,
                'message' => 'Order created successfully',
                'connection_used' => 'master'
            ], 201);
        });
    }

    /**
     * Get order reports (read from backup)
     */
    public function reports(Request $request)
    {
        $startDate = $request->input('start_date', now()->subDays(30));
        $endDate = $request->input('end_date', now());

        // Use backup database for heavy reporting queries
        $reports = DB::connection('mysql_backup')
            ->table('orders')
            ->selectRaw('
                DATE(created_at) as date,
                COUNT(*) as total_orders,
                SUM(total_amount) as total_revenue,
                AVG(total_amount) as avg_order_value
            ')
            ->whereBetween('created_at', [$startDate, $endDate])
            ->where('status', 'completed')
            ->groupBy('date')
            ->orderBy('date')
            ->get();

        return response()->json([
            'reports' => $reports,
            'connection_used' => 'backup'
        ]);
    }
}
```

---

## üß™ Testing & Validation

### Feature Test for Database Replication
```php
<?php

namespace Tests\Feature;

use Tests\TestCase;
use App\Models\User;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Support\Facades\DB;

class DatabaseReplicationTest extends TestCase
{
    /**
     * Test read/write separation
     */
    public function test_read_write_separation()
    {
        // Create user (should go to master)
        $user = User::create([
            'name' => 'Test User',
            'email' => 'test@example.com',
            'password' => bcrypt('password'),
        ]);

        $this->assertDatabaseHas('users', [
            'email' => 'test@example.com'
        ]);

        // Test explicit read from slave
        $slaveUser = User::readFromSlave()
            ->where('email', 'test@example.com')
            ->first();

        // Note: In testing, slave might be the same as master
        $this->assertNotNull($slaveUser);
        $this->assertEquals($user->id, $slaveUser->id);
    }

    /**
     * Test connection health
     */
    public function test_database_connections()
    {
        $connections = ['mysql_write', 'mysql_read', 'mysql_backup'];

        foreach ($connections as $connection) {
            try {
                $result = DB::connection($connection)->select('SELECT 1 as test');
                $this->assertEquals(1, $result[0]->test);
            } catch (\Exception $e) {
                // In testing environment, some connections might not be available
                $this->markTestSkipped("Connection {$connection} not available in test environment");
            }
        }
    }

    /**
     * Test failover scenario
     */
    public function test_failover_handling()
    {
        // Mock master failure
        config(['database.connections.mysql_write.host' => 'invalid_host']);

        // Application should gracefully handle the failure
        $response = $this->get('/api/users');
        
        // Depending on your failover implementation, this might return 503 or fallback data
        $this->assertTrue(in_array($response->status(), [200, 503]));
    }

    /**
     * Test transaction rollback across connections
     */
    public function test_transaction_rollback()
    {
        DB::connection('mysql_write')->beginTransaction();

        try {
            User::writeToMaster()->create([
                'name' => 'Transaction Test',
                'email' => 'transaction@example.com',
                'password' => bcrypt('password'),
            ]);

            // Force an error
            throw new \Exception('Test rollback');

        } catch (\Exception $e) {
            DB::connection('mysql_write')->rollBack();
        }

        // User should not exist due to rollback
        $this->assertDatabaseMissing('users', [
            'email' => 'transaction@example.com'
        ]);
    }
}
```

### Performance Test
```php
<?php

namespace Tests\Performance;

use Tests\TestCase;
use App\Models\User;
use Illuminate\Support\Facades\DB;

class DatabasePerformanceTest extends TestCase
{
    /**
     * Test read performance on slave
     */
    public function test_read_performance()
    {
        $startTime = microtime(true);

        // Create test data
        User::factory()->count(1000)->create();

        // Test read performance on slave
        $users = User::readFromSlave()
            ->orderBy('created_at', 'desc')
            ->limit(100)
            ->get();

        $endTime = microtime(true);
        $executionTime = ($endTime - $startTime) * 1000; // Convert to milliseconds

        $this->assertLessThan(500, $executionTime, 'Read query took too long'); // Should be under 500ms
        $this->assertCount(100, $users);
    }

    /**
     * Test write performance on master
     */
    public function test_write_performance()
    {
        $startTime = microtime(true);

        // Batch insert test
        $users = [];
        for ($i = 0; $i < 100; $i++) {
            $users[] = [
                'name' => "User {$i}",
                'email' => "user{$i}@example.com",
                'password' => bcrypt('password'),
                'created_at' => now(),
                'updated_at' => now(),
            ];
        }

        DB::connection('mysql_write')->table('users')->insert($users);

        $endTime = microtime(true);
        $executionTime = ($endTime - $startTime) * 1000;

        $this->assertLessThan(1000, $executionTime, 'Batch insert took too long'); // Should be under 1 second
    }

    /**
     * Test connection pooling
     */
    public function test_connection_pooling()
    {
        $connections = [];
        
        // Create multiple connections
        for ($i = 0; $i < 10; $i++) {
            $connections[] = DB::connection('mysql_read')->getPdo();
        }

        // All connections should be valid PDO instances
        foreach ($connections as $connection) {
            $this->assertInstanceOf(\PDO::class, $connection);
        }
    }
}
```

---

## üìö Best Practices & Tips

### Laravel-Specific Best Practices

#### 1. Model Configuration
```php
// Always extend ReplicatedModel for models that need replication
class YourModel extends ReplicatedModel
{
    // Use explicit connections when needed
    public function scopeAnalytics($query)
    {
        return $query->setConnection('mysql_backup');
    }
}
```

#### 2. Service Layer Pattern
```php
// Use services to encapsulate database logic
class UserService
{
    public function createUser($data)
    {
        return DB::connection('mysql_write')->transaction(function () use ($data) {
            // All writes in this transaction will use master
            return User::create($data);
        });
    }
}
```

#### 3. Cache Configuration
```php
// config/cache.php - Use read connection for cache
'database' => [
    'driver' => 'database',
    'table' => 'cache',
    'connection' => 'mysql_read', // Use slave for cache reads
],
```

#### 4. Session Configuration
```php
// config/session.php - Use write connection for sessions
'connection' => 'mysql_write', // Sessions need to be written to master
```

### Monitoring Dashboard
```php
// Create a dashboard route for monitoring
Route::get('/admin/database-status', function () {
    $healthService = app(DatabaseHealthService::class);
    
    return response()->json([
        'connections' => $healthService->checkAllConnections(),
        'replication' => $healthService->checkReplicationLag(),
        'stats' => [
            'master' => $healthService->getConnectionStats('mysql_write'),
            'slave' => $healthService->getConnectionStats('mysql_read'),
            'backup' => $healthService->getConnectionStats('mysql_backup'),
        ]
    ]);
})->middleware('auth:admin');
```

### Emergency Procedures
```bash
# Quick commands for emergency situations

# 1. Switch all traffic to backup database
php artisan config:set database.default mysql_backup

# 2. Clear all caches
php artisan config:clear
php artisan cache:clear
php artisan route:clear
php artisan view:clear

# 3. Test all connections
php artisan db:test

# 4. Monitor health
php artisan db:monitor --notify

# 5. Queue restart (if using database queues)
php artisan queue:restart
```

**üéØ Remember: Always test your replication setup thoroughly in staging before deploying to production!**
