In Laravel, you can queue event listeners to improve application performance by processing them asynchronously. Here's how to implement queued event listeners:

## 1. Basic Setup

### Create a Queued Event Listener

Use the `--queued` flag when generating a listener:

```bash
php artisan make:listener SendNotificationListener --event=UserRegistered --queued
```

This automatically implements the `ShouldQueue` interface.

### Manual Implementation

If you already have a listener, implement the `ShouldQueue` interface:

```php
<?php

namespace App\Listeners;

use App\Events\UserRegistered;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Queue\InteractsWithQueue;

class SendNotificationListener implements ShouldQueue
{
    use InteractsWithQueue;

    public function handle(UserRegistered $event)
    {
        // Your queued logic here
        // This will run in the background
    }
}
```

## 2. Configure Queue Connection

### Set Default Queue Connection

In your `.env` file:

```env
QUEUE_CONNECTION=database
# or redis, sqs, etc.
```

### Specify Queue Connection for Listener

```php
class SendNotificationListener implements ShouldQueue
{
    public $connection = 'redis';
    public $queue = 'notifications';
    
    public function handle(UserRegistered $event)
    {
        // Logic here
    }
}
```

## 3. Event Registration

Register your listener in `EventServiceProvider`:

```php
<?php

namespace App\Providers;

use App\Events\UserRegistered;
use App\Listeners\SendNotificationListener;
use Illuminate\Foundation\Support\Providers\EventServiceProvider as ServiceProvider;

class EventServiceProvider extends ServiceProvider
{
    protected $listen = [
        UserRegistered::class => [
            SendNotificationListener::class,
        ],
    ];
}
```

## 4. Advanced Queue Configuration

### Delay Execution

```php
class SendNotificationListener implements ShouldQueue
{
    public $delay = 60; // Delay by 60 seconds
    
    public function handle(UserRegistered $event)
    {
        // This will run after 60 seconds
    }
}
```

### Set Priority

```php
class SendNotificationListener implements ShouldQueue
{
    public $priority = 1; // Lower number = higher priority
    
    public function handle(UserRegistered $event)
    {
        // High priority job
    }
}
```

### Handle Failures

```php
class SendNotificationListener implements ShouldQueue
{
    public $tries = 3;
    public $maxExceptions = 2;
    
    public function handle(UserRegistered $event)
    {
        // Your logic that might fail
    }
    
    public function failed(UserRegistered $event, Throwable $exception)
    {
        // Handle failure
        Log::error('Listener failed: ' . $exception->getMessage());
    }
}
```

## 5. Dispatching Events

Dispatch your event normally - Laravel will automatically queue the listener:

```php
// In your controller or service
use App\Events\UserRegistered;

// This will trigger the queued listener
event(new UserRegistered($user));

// Or using the helper
broadcast(new UserRegistered($user));
```

## 6. Running Queue Workers

Start the queue worker to process queued listeners:

```bash
# Process jobs continuously
php artisan queue:work

# Process a specific queue
php artisan queue:work --queue=notifications

# Process only one job then exit
php artisan queue:work --once
```

## 7. Queue-Specific Configuration

### Custom Queue Name

```php
class SendNotificationListener implements ShouldQueue
{
    public function viaQueue()
    {
        return 'high-priority';
    }
    
    // Or set as property
    public $queue = 'high-priority';
}
```

### Custom Connection

```php
class SendNotificationListener implements ShouldQueue
{
    public function viaConnection()
    {
        return 'redis';
    }
    
    // Or set as property
    public $connection = 'redis';
}
```

## 8. Testing Queued Listeners

### In Feature Tests

```php
<?php

namespace Tests\Feature;

use App\Events\UserRegistered;
use Illuminate\Support\Facades\Event;
use Illuminate\Support\Facades\Queue;
use Tests\TestCase;

class UserRegistrationTest extends TestCase
{
    public function test_user_registration_queues_notification()
    {
        Queue::fake();
        
        // Trigger the event
        event(new UserRegistered($user));
        
        // Assert that the listener was queued
        Queue::assertPushed(SendNotificationListener::class);
    }
}
```

## 9. Important Notes

- **Serialization**: Ensure all data passed to the event is serializable
- **Database Transactions**: Be careful with database transactions - queued jobs run outside the original transaction
- **Error Handling**: Always implement proper error handling for queued listeners
- **Monitoring**: Use Laravel Horizon for Redis queues to monitor performance

## Example Complete Implementation

**Event:**
```php
<?php

namespace App\Events;

use App\Models\User;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Queue\SerializesModels;

class UserRegistered
{
    use Dispatchable, InteractsWithSockets, SerializesModels;
    
    public $user;
    
    public function __construct(User $user)
    {
        $this->user = $user;
    }
}
```

**Listener:**
```php
<?php

namespace App\Listeners;

use App\Events\UserRegistered;
use Illuminate\Contracts\Queue\ShouldQueue;
use Illuminate\Queue\InteractsWithQueue;
use Illuminate\Support\Facades\Mail;

class SendWelcomeEmailListener implements ShouldQueue
{
    use InteractsWithQueue;
    
    public $connection = 'redis';
    public $queue = 'emails';
    public $tries = 3;
    
    public function handle(UserRegistered $event)
    {
        Mail::to($event->user->email)->send(new WelcomeEmail($event->user));
    }
    
    public function failed(UserRegistered $event, Throwable $exception)
    {
        // Log the failure or notify admin
        \Log::error('Failed to send welcome email: ' . $exception->getMessage());
    }
}
```

This setup will automatically queue the welcome email sending process, improving your application's response time while ensuring the email is still sent reliably.
