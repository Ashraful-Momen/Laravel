# Laravel WebRTC Video Streaming with Redis Tutorial

In this tutorial, I'll guide you through creating a video streaming application using WebRTC, Laravel, and Redis. We'll build a system that allows users to create video rooms, join them, and communicate in real-time.

## Understanding the Technologies

- **WebRTC**: A free, open-source project providing web browsers with real-time communication capabilities via simple APIs
- **Laravel**: The PHP framework we'll use for our backend
- **Redis**: Used for pub/sub capabilities to manage signaling between WebRTC peers
- **Laravel WebSockets**: A WebSocket server implementation for Laravel

## Step 1: Setup Your Laravel Project

Let's start by creating a new Laravel project:

```bash
composer create-project laravel/laravel webrtc-video-streaming
cd webrtc-video-streaming
```

## Step 2: Install Required Dependencies

```bash
# Install Redis for Laravel
composer require predis/predis

# Install Laravel WebSockets package
composer require beyondcode/laravel-websockets

# Publish WebSockets configuration
php artisan vendor:publish --provider="BeyondCode\LaravelWebSockets\WebSocketsServiceProvider" --tag="migrations"
php artisan migrate
php artisan vendor:publish --provider="BeyondCode\LaravelWebSockets\WebSocketsServiceProvider" --tag="config"
```

## Step 3: Configure Broadcasting and Redis

Update your `.env` file:

```
BROADCAST_DRIVER=pusher
PUSHER_APP_ID=local
PUSHER_APP_KEY=local
PUSHER_APP_SECRET=local
PUSHER_HOST=127.0.0.1
PUSHER_PORT=6001
PUSHER_SCHEME=http
PUSHER_APP_CLUSTER=mt1

REDIS_HOST=127.0.0.1
REDIS_PASSWORD=null
REDIS_PORT=6379
```

Configure WebSockets in `config/websockets.php`:

```php
'apps' => [
    [
        'id' => env('PUSHER_APP_ID'),
        'name' => env('APP_NAME'),
        'key' => env('PUSHER_APP_KEY'),
        'secret' => env('PUSHER_APP_SECRET'),
        'path' => env('PUSHER_APP_PATH'),
        'capacity' => null,
        'enable_client_messages' => true, // Important for WebRTC signaling
        'enable_statistics' => true,
    ],
],
```

## Step 4: Create Room Model and Migration

Let's create a model for our video rooms:

```bash
php artisan make:model Room -m
```

Edit the migration file:

```php
// database/migrations/xxxx_xx_xx_create_rooms_table.php
public function up()
{
    Schema::create('rooms', function (Blueprint $table) {
        $table->id();
        $table->string('name');
        $table->string('slug')->unique();
        $table->foreignId('user_id')->constrained()->onDelete('cascade');
        $table->boolean('is_private')->default(false);
        $table->string('password')->nullable();
        $table->timestamps();
    });
}
```

Update the Room model:

```php
// app/Models/Room.php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Support\Str;

class Room extends Model
{
    use HasFactory;

    protected $fillable = [
        'name',
        'slug',
        'user_id',
        'is_private',
        'password',
    ];

    protected $casts = [
        'is_private' => 'boolean',
    ];

    protected static function boot()
    {
        parent::boot();

        static::creating(function ($room) {
            if (empty($room->slug)) {
                $room->slug = Str::slug($room->name) . '-' . Str::random(6);
            }
        });
    }

    public function user()
    {
        return $this->belongsTo(User::class);
    }

    public function getRouteKeyName()
    {
        return 'slug';
    }
}
```

## Step 5: Create WebRTC Signaling Events

Create the necessary events for WebRTC signaling:

```bash
php artisan make:event WebRTCOffer
php artisan make:event WebRTCAnswer
php artisan make:event WebRTCIceCandidate
php artisan make:event JoinRoom
php artisan make:event LeaveRoom
```

Let's implement these events:

```php
// app/Events/WebRTCOffer.php
<?php

namespace App\Events;

use Illuminate\Broadcasting\Channel;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Broadcasting\PresenceChannel;
use Illuminate\Contracts\Broadcasting\ShouldBroadcast;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Queue\SerializesModels;

class WebRTCOffer implements ShouldBroadcast
{
    use Dispatchable, InteractsWithSockets, SerializesModels;

    public $roomId;
    public $userId;
    public $targetUserId;
    public $sdp;

    /**
     * Create a new event instance.
     *
     * @return void
     */
    public function __construct($roomId, $userId, $targetUserId, $sdp)
    {
        $this->roomId = $roomId;
        $this->userId = $userId;
        $this->targetUserId = $targetUserId;
        $this->sdp = $sdp;
    }

    /**
     * Get the channels the event should broadcast on.
     *
     * @return \Illuminate\Broadcasting\Channel|array
     */
    public function broadcastOn()
    {
        return new PresenceChannel('room.' . $this->roomId);
    }
}
```

```php
// app/Events/WebRTCAnswer.php
<?php

namespace App\Events;

use Illuminate\Broadcasting\Channel;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Broadcasting\PresenceChannel;
use Illuminate\Contracts\Broadcasting\ShouldBroadcast;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Queue\SerializesModels;

class WebRTCAnswer implements ShouldBroadcast
{
    use Dispatchable, InteractsWithSockets, SerializesModels;

    public $roomId;
    public $userId;
    public $targetUserId;
    public $sdp;

    /**
     * Create a new event instance.
     *
     * @return void
     */
    public function __construct($roomId, $userId, $targetUserId, $sdp)
    {
        $this->roomId = $roomId;
        $this->userId = $userId;
        $this->targetUserId = $targetUserId;
        $this->sdp = $sdp;
    }

    /**
     * Get the channels the event should broadcast on.
     *
     * @return \Illuminate\Broadcasting\Channel|array
     */
    public function broadcastOn()
    {
        return new PresenceChannel('room.' . $this->roomId);
    }
}
```

```php
// app/Events/WebRTCIceCandidate.php
<?php

namespace App\Events;

use Illuminate\Broadcasting\Channel;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Broadcasting\PresenceChannel;
use Illuminate\Contracts\Broadcasting\ShouldBroadcast;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Queue\SerializesModels;

class WebRTCIceCandidate implements ShouldBroadcast
{
    use Dispatchable, InteractsWithSockets, SerializesModels;

    public $roomId;
    public $userId;
    public $targetUserId;
    public $candidate;

    /**
     * Create a new event instance.
     *
     * @return void
     */
    public function __construct($roomId, $userId, $targetUserId, $candidate)
    {
        $this->roomId = $roomId;
        $this->userId = $userId;
        $this->targetUserId = $targetUserId;
        $this->candidate = $candidate;
    }

    /**
     * Get the channels the event should broadcast on.
     *
     * @return \Illuminate\Broadcasting\Channel|array
     */
    public function broadcastOn()
    {
        return new PresenceChannel('room.' . $this->roomId);
    }
}
```

```php
// app/Events/JoinRoom.php
<?php

namespace App\Events;

use Illuminate\Broadcasting\Channel;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Broadcasting\PresenceChannel;
use Illuminate\Contracts\Broadcasting\ShouldBroadcast;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Queue\SerializesModels;

class JoinRoom implements ShouldBroadcast
{
    use Dispatchable, InteractsWithSockets, SerializesModels;

    public $roomId;
    public $userId;
    public $userName;

    /**
     * Create a new event instance.
     *
     * @return void
     */
    public function __construct($roomId, $userId, $userName)
    {
        $this->roomId = $roomId;
        $this->userId = $userId;
        $this->userName = $userName;
    }

    /**
     * Get the channels the event should broadcast on.
     *
     * @return \Illuminate\Broadcasting\Channel|array
     */
    public function broadcastOn()
    {
        return new PresenceChannel('room.' . $this->roomId);
    }
}
```

```php
// app/Events/LeaveRoom.php
<?php

namespace App\Events;

use Illuminate\Broadcasting\Channel;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Broadcasting\PresenceChannel;
use Illuminate\Contracts\Broadcasting\ShouldBroadcast;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Queue\SerializesModels;

class LeaveRoom implements ShouldBroadcast
{
    use Dispatchable, InteractsWithSockets, SerializesModels;

    public $roomId;
    public $userId;

    /**
     * Create a new event instance.
     *
     * @return void
     */
    public function __construct($roomId, $userId)
    {
        $this->roomId = $roomId;
        $this->userId = $userId;
    }

    /**
     * Get the channels the event should broadcast on.
     *
     * @return \Illuminate\Broadcasting\Channel|array
     */
    public function broadcastOn()
    {
        return new PresenceChannel('room.' . $this->roomId);
    }
}
```

## Step 6: Create Controller for WebRTC Signaling

```bash
php artisan make:controller WebRTCController
```

```php
// app/Http/Controllers/WebRTCController.php
<?php

namespace App\Http\Controllers;

use App\Events\WebRTCOffer;
use App\Events\WebRTCAnswer;
use App\Events\WebRTCIceCandidate;
use App\Events\JoinRoom;
use App\Events\LeaveRoom;
use Illuminate\Http\Request;

class WebRTCController extends Controller
{
    /**
     * Send WebRTC offer to a peer.
     *
     * @param  \Illuminate\Http\Request  $request
     * @return \Illuminate\Http\Response
     */
    public function offer(Request $request)
    {
        $request->validate([
            'room_id' => 'required|string',
            'target_user_id' => 'required|string',
            'sdp' => 'required',
        ]);

        broadcast(new WebRTCOffer(
            $request->room_id,
            auth()->id(),
            $request->target_user_id,
            $request->sdp
        ));

        return response()->json(['success' => true]);
    }

    /**
     * Send WebRTC answer to a peer.
     *
     * @param  \Illuminate\Http\Request  $request
     * @return \Illuminate\Http\Response
     */
    public function answer(Request $request)
    {
        $request->validate([
            'room_id' => 'required|string',
            'target_user_id' => 'required|string',
            'sdp' => 'required',
        ]);

        broadcast(new WebRTCAnswer(
            $request->room_id,
            auth()->id(),
            $request->target_user_id,
            $request->sdp
        ));

        return response()->json(['success' => true]);
    }

    /**
     * Send ICE candidate to a peer.
     *
     * @param  \Illuminate\Http\Request  $request
     * @return \Illuminate\Http\Response
     */
    public function iceCandidate(Request $request)
    {
        $request->validate([
            'room_id' => 'required|string',
            'target_user_id' => 'required|string',
            'candidate' => 'required',
        ]);

        broadcast(new WebRTCIceCandidate(
            $request->room_id,
            auth()->id(),
            $request->target_user_id,
            $request->candidate
        ));

        return response()->json(['success' => true]);
    }

    /**
     * Join a room.
     *
     * @param  \Illuminate\Http\Request  $request
     * @return \Illuminate\Http\Response
     */
    public function join(Request $request)
    {
        $request->validate([
            'room_id' => 'required|string',
        ]);

        broadcast(new JoinRoom(
            $request->room_id,
            auth()->id(),
            auth()->user()->name
        ));

        return response()->json(['success' => true]);
    }

    /**
     * Leave a room.
     *
     * @param  \Illuminate\Http\Request  $request
     * @return \Illuminate\Http\Response
     */
    public function leave(Request $request)
    {
        $request->validate([
            'room_id' => 'required|string',
        ]);

        broadcast(new LeaveRoom(
            $request->room_id,
            auth()->id()
        ));

        return response()->json(['success' => true]);
    }
}
```

## Step 7: Create Room Controller

```bash
php artisan make:controller RoomController
```

```php
// app/Http/Controllers/RoomController.php
<?php

namespace App\Http\Controllers;

use App\Models\Room;
use Illuminate\Http\Request;
use Illuminate\Support\Str;

class RoomController extends Controller
{
    /**
     * Display a listing of the rooms.
     *
     * @return \Illuminate\Http\Response
     */
    public function index()
    {
        $rooms = Room::where('is_private', false)
            ->orWhere('user_id', auth()->id())
            ->latest()
            ->get();
            
        return view('rooms.index', compact('rooms'));
    }

    /**
     * Show the form for creating a new room.
     *
     * @return \Illuminate\Http\Response
     */
    public function create()
    {
        return view('rooms.create');
    }

    /**
     * Store a newly created room in storage.
     *
     * @param  \Illuminate\Http\Request  $request
     * @return \Illuminate\Http\Response
     */
    public function store(Request $request)
    {
        $request->validate([
            'name' => 'required|string|max:255',
            'is_private' => 'sometimes|boolean',
            'password' => 'nullable|string|min:6|required_if:is_private,1',
        ]);

        $room = Room::create([
            'name' => $request->name,
            'slug' => Str::slug($request->name) . '-' . Str::random(6),
            'user_id' => auth()->id(),
            'is_private' => $request->has('is_private'),
            'password' => $request->is_private ? bcrypt($request->password) : null,
        ]);

        return redirect()->route('rooms.show', $room->slug)
            ->with('success', 'Room created successfully!');
    }

    /**
     * Display the specified room.
     *
     * @param  \App\Models\Room  $room
     * @return \Illuminate\Http\Response
     */
    public function show(Room $room)
    {
        // Check if user is allowed to join the room
        if ($room->is_private && $room->user_id !== auth()->id()) {
            return redirect()->route('rooms.join', $room->slug);
        }

        return view('rooms.show', compact('room'));
    }

    /**
     * Show the join room form.
     *
     * @param  \App\Models\Room  $room
     * @return \Illuminate\Http\Response
     */
    public function joinForm(Room $room)
    {
        if (!$room->is_private || $room->user_id === auth()->id()) {
            return redirect()->route('rooms.show', $room->slug);
        }

        return view('rooms.join', compact('room'));
    }

    /**
     * Process the join room request.
     *
     * @param  \Illuminate\Http\Request  $request
     * @param  \App\Models\Room  $room
     * @return \Illuminate\Http\Response
     */
    public function join(Request $request, Room $room)
    {
        $request->validate([
            'password' => 'required|string',
        ]);

        if (!password_verify($request->password, $room->password)) {
            return back()->withErrors(['password' => 'The password is incorrect.']);
        }

        return redirect()->route('rooms.show', $room->slug);
    }
}
```

## Step 8: Setup Authentication Routes and Channel Authorization

First, let's ensure we have authentication setup:

```bash
# Using Laravel Breeze for simple auth scaffolding
composer require laravel/breeze --dev
php artisan breeze:install blade
php artisan migrate
```

Now, configure channel authorization:

```php
// routes/channels.php
use Illuminate\Support\Facades\Broadcast;

Broadcast::channel('room.{roomId}', function ($user, $roomId) {
    // Check if the room exists and if the user is allowed to join
    $room = \App\Models\Room::where('id', $roomId)->first();
    
    if (!$room) {
        return false;
    }
    
    // Allow the room creator or users with the password
    if (!$room->is_private || $room->user_id === $user->id) {
        return [
            'id' => $user->id,
            'name' => $user->name
        ];
    }
    
    // For private rooms, we'd need a more complex authorization system
    // This is just a simplified example
    return false;
});
```

## Step 9: Create Routes

```php
// routes/web.php
use App\Http\Controllers\RoomController;
use App\Http\Controllers\WebRTCController;
use Illuminate\Support\Facades\Route;

Route::get('/', function () {
    return view('welcome');
});

Route::middleware(['auth'])->group(function () {
    // Room routes
    Route::get('/rooms', [RoomController::class, 'index'])->name('rooms.index');
    Route::get('/rooms/create', [RoomController::class, 'create'])->name('rooms.create');
    Route::post('/rooms', [RoomController::class, 'store'])->name('rooms.store');
    Route::get('/rooms/{room}', [RoomController::class, 'show'])->name('rooms.show');
    Route::get('/rooms/{room}/join', [RoomController::class, 'joinForm'])->name('rooms.join.form');
    Route::post('/rooms/{room}/join', [RoomController::class, 'join'])->name('rooms.join');

    // WebRTC signaling routes
    Route::post('/webrtc/offer', [WebRTCController::class, 'offer']);
    Route::post('/webrtc/answer', [WebRTCController::class, 'answer']);
    Route::post('/webrtc/ice-candidate', [WebRTCController::class, 'iceCandidate']);
    Route::post('/webrtc/join', [WebRTCController::class, 'join']);
    Route::post('/webrtc/leave', [WebRTCController::class, 'leave']);
});
```

## Step 10: Create Views

Let's create the necessary Blade views:

**resources/views/rooms/index.blade.php**

```html
<x-app-layout>
    <x-slot name="header">
        <h2 class="font-semibold text-xl text-gray-800 leading-tight">
            {{ __('Video Rooms') }}
        </h2>
    </x-slot>

    <div class="py-12">
        <div class="max-w-7xl mx-auto sm:px-6 lg:px-8">
            <div class="bg-white overflow-hidden shadow-sm sm:rounded-lg">
                <div class="p-6 bg-white border-b border-gray-200">
                    <div class="flex justify-between items-center mb-6">
                        <h3 class="text-lg font-semibold">Available Rooms</h3>
                        <a href="{{ route('rooms.create') }}" class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">
                            Create New Room
                        </a>
                    </div>

                    @if (session('success'))
                        <div class="mb-4 px-4 py-2 bg-green-100 border border-green-400 text-green-700 rounded">
                            {{ session('success') }}
                        </div>
                    @endif

                    @if (count($rooms) > 0)
                        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                            @foreach ($rooms as $room)
                                <div class="border rounded p-4 hover:shadow-md">
                                    <h4 class="text-lg font-medium">{{ $room->name }}</h4>
                                    <p class="text-sm text-gray-500">Created by: {{ $room->user->name }}</p>
                                    <p class="text-sm text-gray-500">Created: {{ $room->created_at->diffForHumans() }}</p>
                                    
                                    @if ($room->is_private)
                                        <span class="inline-block mt-2 px-2 py-1 text-xs bg-yellow-100 text-yellow-800 rounded">Private</span>
                                    @else
                                        <span class="inline-block mt-2 px-2 py-1 text-xs bg-green-100 text-green-800 rounded">Public</span>
                                    @endif
                                    
                                    <div class="mt-4">
                                        <a href="{{ route('rooms.show', $room->slug) }}" class="px-3 py-1 bg-blue-500 text-white rounded text-sm hover:bg-blue-600">
                                            Join Room
                                        </a>
                                    </div>
                                </div>
                            @endforeach
                        </div>
                    @else
                        <p class="text-gray-500">No rooms available. Create one to get started!</p>
                    @endif
                </div>
            </div>
        </div>
    </div>
</x-app-layout>
```

**resources/views/rooms/create.blade.php**

```html
<x-app-layout>
    <x-slot name="header">
        <h2 class="font-semibold text-xl text-gray-800 leading-tight">
            {{ __('Create Video Room') }}
        </h2>
    </x-slot>

    <div class="py-12">
        <div class="max-w-7xl mx-auto sm:px-6 lg:px-8">
            <div class="bg-white overflow-hidden shadow-sm sm:rounded-lg">
                <div class="p-6 bg-white border-b border-gray-200">
                    <form method="POST" action="{{ route('rooms.store') }}">
                        @csrf

                        <div class="mb-4">
                            <label for="name" class="block text-gray-700 text-sm font-bold mb-2">Room Name</label>
                            <input type="text" name="name" id="name" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline @error('name') border-red-500 @enderror" value="{{ old('name') }}" required>
                            @error('name')
                                <p class="text-red-500 text-xs italic mt-1">{{ $message }}</p>
                            @enderror
                        </div>

                        <div class="mb-4">
                            <div class="flex items-center">
                                <input type="checkbox" name="is_private" id="is_private" class="mr-2" {{ old('is_private') ? 'checked' : '' }}>
                                <label for="is_private" class="text-gray-700 text-sm font-bold">Private Room</label>
                            </div>
                        </div>

                        <div id="password-container" class="mb-4 {{ old('is_private') ? '' : 'hidden' }}">
                            <label for="password" class="block text-gray-700 text-sm font-bold mb-2">Password</label>
                            <input type="password" name="password" id="password" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline @error('password') border-red-500 @enderror">
                            @error('password')
                                <p class="text-red-500 text-xs italic mt-1">{{ $message }}</p>
                            @enderror
                        </div>

                        <div class="flex items-center justify-between">
                            <button type="submit" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline">
                                Create Room
                            </button>
                            <a href="{{ route('rooms.index') }}" class="inline-block align-baseline font-bold text-sm text-blue-500 hover:text-blue-800">
                                Cancel
                            </a>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    </div>

    <script>
        const isPrivateCheckbox = document.getElementById('is_private');
        const passwordContainer = document.getElementById('password-container');

        isPrivateCheckbox.addEventListener('change', function() {
            if (this.checked) {
                passwordContainer.classList.remove('hidden');
            } else {
                passwordContainer.classList.add('hidden');
            }
        });
    </script>
</x-app-layout>
```

**resources/views/rooms/join.blade.php**

```html
<x-app-layout>
    <x-slot name="header">
        <h2 class="font-semibold text-xl text-gray-800 leading-tight">
            {{ __('Join Private Room') }}
        </h2>
    </x-slot>

    <div class="py-12">
        <div class="max-w-7xl mx-auto sm:px-6 lg:px-8">
            <div class="bg-white overflow-hidden shadow-sm sm:rounded-lg">
                <div class="p-6 bg-white border-b border-gray-200">
                    <h3 class="text-lg font-semibold mb-4">Join: {{ $room->name }}</h3>
                    
                    <form method="POST" action="{{ route('rooms.join', $room->slug) }}">
                        @csrf

                        <div class="mb-4">
                            <label for="password" class="block text-gray-700 text-sm font-bold mb-2">Room Password</label>
                            <input type="password" name="password" id="password" class="shadow appearance-none border rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:shadow-outline @error('password') border-red-500 @enderror" required>
                            @error('password')
                                <p class="text-red-500 text-xs italic mt-1">{{ $message }}</p>
                            @enderror
                        </div>

                        <div class="flex items-center justify-between">
                            <button type="submit" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline">
                                Join Room
                            </button>
                            <a href="{{ route('rooms.index') }}" class="inline-block align-baseline font-bold text-sm text-blue-500 hover:text-blue-800">
                                Cancel
                            </a>
                        </div>
                    </form>
                </div>
            </div>
        </div>
    </div>
</x-app-layout>
```

**resources/views/rooms/show.blade.php**

```html
<x-app-layout>
    <x-slot name="header">
        <div class="flex justify-between items-center">
            <h2 class="font-semibold text-xl text-gray-800 leading-tight">
                {{ $room->name }}
            </h2>
            <div>
                <span id="participants-count" class="px-2 py-1 bg-blue-100 text-blue-800 rounded text-sm">
                    0 Participants
                </span>
                <a href="{{ route('rooms.index') }}" class="ml-4 px-3 py-1 bg-gray-200 text-gray-700 rounded text-sm hover:bg-gray-300">
                    Leave Room
                </a>
            </div>
        </div>
    </x-slot>

    <div class="py-12">
        <div class="max-w-7xl mx-auto sm:px-6 lg:px-8">
            <div class="bg-white overflow-hidden shadow-sm sm:rounded-lg">
                <div class="p-6 bg-white border-b border-gray-200">
                    <!-- Video grid -->
                    <div id="video-grid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 mb-6">
                        <!-- Local video will be inserted here -->
                        <div id="local-video-container" class="relative bg-black rounded overflow-hidden aspect-video">
                            <video id="local-video" autoplay muted playsinline class="w-full h-full object-cover"></video>
                            <div class="absolute bottom-2 left-2 px-2 py-1 bg-black bg-opacity-50 text-white text-sm rounded">
                                You
                            </div>
                        </div>
                        
                        <!-- Remote videos will be added dynamically -->
                    </div>

                    <!-- Controls -->
                    <div class="flex justify-center space-x-4 mb-6">
                        <button id="toggle-video" class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">
                            <i class="fas fa-video"></i> Toggle Video
                        </button>

Let me continue with the controls section of the room view template:

```html
                        <button id="toggle-audio" class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">
                            <i class="fas fa-microphone"></i> Toggle Audio
                        </button>
                        <button id="toggle-screen-share" class="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600">
                            <i class="fas fa-desktop"></i> Share Screen
                        </button>
                    </div>

                    <!-- Room info -->
                    <div class="mt-6 p-4 bg-gray-50 rounded">
                        <h3 class="text-lg font-semibold mb-2">Room Information</h3>
                        <p><strong>Room ID:</strong> {{ $room->id }}</p>
                        <p><strong>Created by:</strong> {{ $room->user->name }}</p>
                        <p><strong>Share URL:</strong> <span id="room-url" class="text-blue-500">{{ url()->current() }}</span></p>
                        <button id="copy-url" class="mt-2 px-3 py-1 bg-gray-200 text-gray-700 rounded text-sm hover:bg-gray-300">
                            Copy URL
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Include JavaScript libraries -->
    <script src="https://js.pusher.com/7.0/pusher.min.js"></script>
    <script src="https://webrtc.github.io/adapter/adapter-latest.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/simple-peer@9.11.0/simplepeer.min.js"></script>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Room and user data
            const roomId = {{ $room->id }};
            const currentUserId = {{ auth()->id() }};
            const currentUserName = "{{ auth()->user()->name }}";
            
            // UI elements
            const videoGrid = document.getElementById('video-grid');
            const localVideo = document.getElementById('local-video');
            const toggleVideoBtn = document.getElementById('toggle-video');
            const toggleAudioBtn = document.getElementById('toggle-audio');
            const toggleScreenShareBtn = document.getElementById('toggle-screen-share');
            const copyUrlBtn = document.getElementById('copy-url');
            const participantsCount = document.getElementById('participants-count');
            
            // WebRTC variables
            let localStream = null;
            let screenStream = null;
            let isScreenSharing = false;
            let peers = {};
            
            // Configuration options
            const iceServers = {
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                    { urls: 'stun:stun1.l.google.com:19302' }
                ]
            };
            
            // Initialize Pusher
            const pusher = new Pusher('{{ env('PUSHER_APP_KEY') }}', {
                cluster: '{{ env('PUSHER_APP_CLUSTER') }}',
                forceTLS: {{ env('PUSHER_SCHEME') === 'https' ? 'true' : 'false' }},
                authEndpoint: '/broadcasting/auth',
                auth: {
                    headers: {
                        'X-CSRF-Token': "{{ csrf_token() }}",
                    }
                }
            });
            
            // Join the presence channel
            const channel = pusher.subscribe('presence-room.' + roomId);
            
            // Handle presence events
            channel.bind('pusher:subscription_succeeded', (members) => {
                updateParticipantCount(members.count);
                
                // Let existing members know that we've joined
                fetch('/webrtc/join', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRF-TOKEN': "{{ csrf_token() }}"
                    },
                    body: JSON.stringify({
                        room_id: roomId
                    })
                });
                
                // Call each existing member
                members.each((member) => {
                    if (member.id !== currentUserId.toString()) {
                        createPeerConnection(member.id, true);
                    }
                });
            });
            
            channel.bind('pusher:member_added', (member) => {
                updateParticipantCount(channel.members.count);
            });
            
            channel.bind('pusher:member_removed', (member) => {
                updateParticipantCount(channel.members.count);
                
                // Remove peer connection and video element
                if (peers[member.id]) {
                    peers[member.id].destroy();
                    delete peers[member.id];
                    
                    const videoElement = document.getElementById(`remote-video-${member.id}`);
                    if (videoElement) {
                        videoElement.parentElement.remove();
                    }
                }
            });
            
            // Listen for WebRTC signaling events
            channel.bind('WebRTCOffer', (data) => {
                if (data.targetUserId == currentUserId) {
                    handleOffer(data.userId, data.sdp);
                }
            });
            
            channel.bind('WebRTCAnswer', (data) => {
                if (data.targetUserId == currentUserId) {
                    handleAnswer(data.userId, data.sdp);
                }
            });
            
            channel.bind('WebRTCIceCandidate', (data) => {
                if (data.targetUserId == currentUserId) {
                    handleIceCandidate(data.userId, data.candidate);
                }
            });
            
            channel.bind('JoinRoom', (data) => {
                // Create peer connection with the new user
                if (data.userId != currentUserId) {
                    createPeerConnection(data.userId, false);
                }
            });
            
            // Get local media stream
            async function initLocalStream() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: true,
                        audio: true
                    });
                    
                    localStream = stream;
                    localVideo.srcObject = stream;
                    
                    // Set up event listeners for media control buttons
                    setupControls();
                    
                } catch (err) {
                    console.error('Error accessing media devices:', err);
                    alert('Could not access camera and microphone. Please check your permissions.');
                }
            }
            
            // Create a peer connection with another user
            function createPeerConnection(userId, isInitiator) {
                console.log(`Creating ${isInitiator ? 'initiator' : 'receiver'} peer connection with user ${userId}`);
                
                // Create a new peer
                const peer = new SimplePeer({
                    initiator: isInitiator,
                    stream: localStream,
                    trickle: true,
                    config: iceServers
                });
                
                // Store the peer
                peers[userId] = peer;
                
                // Handle peer events
                peer.on('signal', (data) => {
                    // Send the signaling data to the remote peer
                    if (data.type === 'offer') {
                        fetch('/webrtc/offer', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRF-TOKEN': "{{ csrf_token() }}"
                            },
                            body: JSON.stringify({
                                room_id: roomId,
                                target_user_id: userId,
                                sdp: data
                            })
                        });
                    } else if (data.type === 'answer') {
                        fetch('/webrtc/answer', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRF-TOKEN': "{{ csrf_token() }}"
                            },
                            body: JSON.stringify({
                                room_id: roomId,
                                target_user_id: userId,
                                sdp: data
                            })
                        });
                    } else if (data.candidate) {
                        fetch('/webrtc/ice-candidate', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-CSRF-TOKEN': "{{ csrf_token() }}"
                            },
                            body: JSON.stringify({
                                room_id: roomId,
                                target_user_id: userId,
                                candidate: data
                            })
                        });
                    }
                });
                
                peer.on('stream', (stream) => {
                    // Create a video element for the remote stream
                    addRemoteVideo(userId, stream);
                });
                
                peer.on('error', (err) => {
                    console.error('Peer error:', err);
                });
                
                return peer;
            }
            
            // Add a remote video to the grid
            function addRemoteVideo(userId, stream) {
                // Create container
                const container = document.createElement('div');
                container.className = 'relative bg-black rounded overflow-hidden aspect-video';
                container.id = `remote-container-${userId}`;
                
                // Create video element
                const video = document.createElement('video');
                video.id = `remote-video-${userId}`;
                video.className = 'w-full h-full object-cover';
                video.autoplay = true;
                video.playsInline = true;
                video.srcObject = stream;
                
                // Create label
                const label = document.createElement('div');
                label.className = 'absolute bottom-2 left-2 px-2 py-1 bg-black bg-opacity-50 text-white text-sm rounded';
                label.textContent = `User ${userId}`;
                
                // Add elements to the DOM
                container.appendChild(video);
                container.appendChild(label);
                videoGrid.appendChild(container);
            }
            
            // Handle incoming WebRTC offer
            function handleOffer(userId, sdp) {
                if (!peers[userId]) {
                    createPeerConnection(userId, false);
                }
                
                peers[userId].signal(sdp);
            }
            
            // Handle incoming WebRTC answer
            function handleAnswer(userId, sdp) {
                if (peers[userId]) {
                    peers[userId].signal(sdp);
                }
            }
            
            // Handle incoming ICE candidate
            function handleIceCandidate(userId, candidate) {
                if (peers[userId]) {
                    peers[userId].signal({ candidate });
                }
            }
            
            // Update participant count
            function updateParticipantCount(count) {
                participantsCount.textContent = `${count} Participants`;
            }
            
            // Set up controls
            function setupControls() {
                // Toggle video
                toggleVideoBtn.addEventListener('click', () => {
                    const videoTracks = localStream.getVideoTracks();
                    if (videoTracks.length > 0) {
                        const isEnabled = videoTracks[0].enabled;
                        videoTracks[0].enabled = !isEnabled;
                        toggleVideoBtn.textContent = isEnabled ? 'Enable Video' : 'Disable Video';
                    }
                });
                
                // Toggle audio
                toggleAudioBtn.addEventListener('click', () => {
                    const audioTracks = localStream.getAudioTracks();
                    if (audioTracks.length > 0) {
                        const isEnabled = audioTracks[0].enabled;
                        audioTracks[0].enabled = !isEnabled;
                        toggleAudioBtn.textContent = isEnabled ? 'Enable Audio' : 'Disable Audio';
                    }
                });
                
                // Screen sharing
                toggleScreenShareBtn.addEventListener('click', async () => {
                    if (!isScreenSharing) {
                        try {
                            // Get screen stream
                            screenStream = await navigator.mediaDevices.getDisplayMedia({
                                video: true
                            });
                            
                            // Replace video tracks for all peers
                            const videoTrack = screenStream.getVideoTracks()[0];
                            
                            Object.values(peers).forEach(peer => {
                                const sender = peer.getSenders().find(s => s.track.kind === 'video');
                                if (sender) {
                                    sender.replaceTrack(videoTrack);
                                }
                            });
                            
                            // Update local video
                            localVideo.srcObject = screenStream;
                            
                            // Set flag
                            isScreenSharing = true;
                            toggleScreenShareBtn.textContent = 'Stop Sharing';
                            
                            // Listen for screen share stop
                            videoTrack.onended = () => {
                                stopScreenSharing();
                            };
                            
                        } catch (err) {
                            console.error('Error sharing screen:', err);
                            alert('Could not share screen. Please check your permissions.');
                        }
                    } else {
                        stopScreenSharing();
                    }
                });
                
                // Copy room URL
                copyUrlBtn.addEventListener('click', () => {
                    const roomUrl = document.getElementById('room-url').textContent;
                    navigator.clipboard.writeText(roomUrl).then(() => {
                        alert('Room URL copied to clipboard');
                    });
                });
            }
            
            // Stop screen sharing
            function stopScreenSharing() {
                if (isScreenSharing && screenStream) {
                    // Stop all tracks in the screen stream
                    screenStream.getTracks().forEach(track => track.stop());
                    
                    // Replace video tracks for all peers with camera video
                    const videoTrack = localStream.getVideoTracks()[0];
                    
                    Object.values(peers).forEach(peer => {
                        const sender = peer.getSenders().find(s => s.track.kind === 'video');
                        if (sender && videoTrack) {
                            sender.replaceTrack(videoTrack);
                        }
                    });
                    
                    // Update local video
                    localVideo.srcObject = localStream;
                    
                    // Reset flag
                    isScreenSharing = false;
                    toggleScreenShareBtn.textContent = 'Share Screen';
                }
            }
            
            // Listen for page unload to clean up
            window.addEventListener('beforeunload', () => {
                // Notify others that we're leaving
                fetch('/webrtc/leave', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRF-TOKEN': "{{ csrf_token() }}"
                    },
                    body: JSON.stringify({
                        room_id: roomId
                    })
                });
                
                // Close all peer connections
                Object.values(peers).forEach(peer => peer.destroy());
                
                // Stop local stream tracks
                if (localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                }
                
                // Stop screen sharing if active
                if (screenStream) {
                    screenStream.getTracks().forEach(track => track.stop());
                }
            });
            
            // Initialize
            initLocalStream();
        });
    </script>
</x-app-layout>
```

## Step 11: Install Redis and Configure Docker

If you're using Docker, update your `docker-compose.yml` file to include Redis:

```yaml
version: '3'
services:
  app:
    build:
      context: .
      dockerfile: Dockerfile
    restart: unless-stopped
    volumes:
      - ./:/var/www/html
    depends_on:
      - mysql
      - redis

  mysql:
    image: mysql:8.0
    restart: unless-stopped
    environment:
      MYSQL_DATABASE: ${DB_DATABASE}
      MYSQL_ROOT_PASSWORD: ${DB_PASSWORD}
      MYSQL_PASSWORD: ${DB_PASSWORD}
      MYSQL_USER: ${DB_USERNAME}
    volumes:
      - mysql:/var/lib/mysql

  redis:
    image: redis:alpine
    restart: unless-stopped
    volumes:
      - redis:/data
    ports:
      - "${REDIS_PORT:-6379}:6379"

  nginx:
    image: nginx:alpine
    restart: unless-stopped
    ports:
      - "${APP_PORT:-80}:80"
      - "${WEBSOCKET_PORT:-6001}:6001"
    volumes:
      - ./:/var/www/html
      - ./docker/nginx/default.conf:/etc/nginx/conf.d/default.conf
    depends_on:
      - app

volumes:
  mysql:
  redis:
```

Create a Nginx configuration file:

```
# docker/nginx/default.conf
server {
    listen 80;
    index index.php index.html;
    server_name localhost;
    root /var/www/html/public;

    location / {
        try_files $uri $uri/ /index.php?$query_string;
    }

    location ~ \.php$ {
        try_files $uri =404;
        fastcgi_pass app:9000;
        fastcgi_index index.php;
        include fastcgi_params;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
    }
}

server {
    listen 6001;

    location / {
        proxy_pass http://app:6001;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
    }
}
```

## Step 12: Start the WebSockets Server

```bash
php artisan websockets:serve
```

This will start the WebSockets server that handles the real-time communication.

## Step 13: Run Your Application

```bash
# If using Docker
docker-compose up -d

# If running locally
php artisan serve
```

## How It Works

1. **User Connection Flow**:
   - User creates or joins a room
   - User's browser requests camera and microphone access
   - User joins the presence channel for the room
   - Other users in the room get notified of the new participant
   - WebRTC connections are established between all participants

2. **Signaling Process**:
   - WebRTC requires a signaling process to exchange connection information
   - Laravel handles this with events broadcasted over WebSockets
   - The events include: offers, answers, and ICE candidates

3. **Redis Role**:
   - Redis serves as a pub/sub system for the WebSockets server
   - It allows scaling the application across multiple servers
   - It efficiently manages presence information about who's in each room

4. **WebRTC Media Flow**:
   - After signaling, media flows directly between browsers (peer-to-peer)
   - This reduces server load since media doesn't go through the server
   - For screen sharing, we replace the video track with screen content

## Troubleshooting

1. **WebSocket Connection Issues**:
   - Check that the WebSockets server is running
   - Verify your CORS settings in `config/cors.php`
   - Make sure your firewall allows WebSocket connections

2. **Camera/Microphone Access Denied**:
   - Ensure your site is using HTTPS in production (required for WebRTC)
   - Check browser permissions

3. **WebRTC Connection Failures**:
   - Add more STUN/TURN servers to improve connectivity behind firewalls
   - Implement a fallback mechanism when direct peer connections fail

4. **High CPU Usage**:
   - Consider limiting video resolution for better performance
   - Implement bandwidth management for large rooms

## Scaling Considerations

As your application grows, consider these scaling strategies:

1. **Selective Forwarding Unit (SFU)**:
   - For large rooms (>5-10 participants), a pure peer-to-peer model becomes inefficient
   - Consider using an SFU like mediasoup or Janus Gateway

2. **Redis Cluster**:
   - As you scale, you may need to set up a Redis cluster
   - Update your Laravel configuration accordingly

3. **Load Balancing**:
   - Set up multiple WebSocket servers behind a load balancer
   - Ensure sticky sessions are enabled

4. **Recording**:
   - For recording functionality, you'll need a media server
   - Consider using a service like Twilio or Amazon Kinesis Video Streams

## Conclusion

You've built a functional video streaming application with WebRTC, Laravel, and Redis! This implementation demonstrates the power of modern web technologies for real-time communication.

The application supports:
- Creating and joining video rooms
- Real-time audio/video communication
- Screen sharing
- Room access control with passwords
- Participant tracking

This tutorial provides a solid foundation that you can extend with additional features like chat functionality, recording, virtual backgrounds, or integration with other services.
