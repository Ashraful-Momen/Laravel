# Laravel Broadcasting with Redis - Real-Time Messaging App Guide

## üìã Overview
Laravel Broadcasting allows you to broadcast server-side events to client-side JavaScript applications using WebSockets. This guide demonstrates building a real-time messaging application using Redis and Soketi (open-source Pusher alternative).

**Use Case:** Build a real-time chat/messaging application where messages appear instantly without page refresh.

---

## üéØ Architecture Flow
```
User Sends Message ‚Üí Controller Saves & Broadcasts Event ‚Üí Redis Pub/Sub ‚Üí 
Soketi WebSocket Server ‚Üí Laravel Echo (Frontend) ‚Üí Real-time UI Update
```

---

## üõ†Ô∏è Technology Stack

| Component | Technology | Purpose |
|-----------|------------|---------|
| Backend | Laravel | API & Event Broadcasting |
| Database | MySQL/PostgreSQL | Message Storage |
| Cache/Queue | Redis | Pub/Sub & Queue Driver |
| WebSocket Server | Soketi | Open-source Pusher alternative |
| Frontend | Laravel Echo + Vue.js | Real-time client library |

---

## üöÄ Step-by-Step Implementation

### Step 1: Install Required Dependencies

```bash
# Install Laravel (if starting fresh)
composer create-project laravel/laravel realtime-chat
cd realtime-chat

# Install Predis (PHP Redis client)
composer require predis/predis

# Install Laravel Broadcasting
# (Already included in Laravel, just need to configure)

# Install Laravel Echo and Socket.io client (Frontend)
npm install --save laravel-echo socket.io-client

# Install development dependencies
npm install --save-dev vite
```

---

### Step 2: Install Redis Server

**For Ubuntu/Debian:**
```bash
sudo apt update
sudo apt install redis-server
sudo systemctl start redis
sudo systemctl enable redis

# Verify Redis is running
redis-cli ping
# Should return: PONG
```

**For macOS:**
```bash
brew install redis
brew services start redis

# Verify
redis-cli ping
```

**For Windows:**
Download from: https://github.com/microsoftarchive/redis/releases

---

### Step 3: Install Soketi (Pusher Alternative)

**Option 1: NPM Global Installation**
```bash
npm install -g @soketi/soketi

# Start Soketi server
soketi start
```

**Option 2: Docker (Recommended for Production)**
```bash
docker run -p 6001:6001 -p 9601:9601 quay.io/soketi/soketi:latest-16-alpine
```

**Option 3: Using Configuration File**

Create `soketi.json`:
```json
{
    "debug": true,
    "host": "0.0.0.0",
    "port": 6001,
    "metrics": {
        "enabled": true,
        "port": 9601
    },
    "adapter": {
        "driver": "redis",
        "redis": {
            "host": "127.0.0.1",
            "port": 6379
        }
    },
    "database": {
        "driver": "redis",
        "redis": {
            "host": "127.0.0.1",
            "port": 6379
        }
    },
    "appManager": {
        "driver": "array",
        "array": {
            "apps": [
                {
                    "id": "app-id",
                    "key": "app-key",
                    "secret": "app-secret",
                    "maxConnections": 100,
                    "enableClientMessages": true,
                    "enabled": true
                }
            ]
        }
    }
}
```

Start with config:
```bash
soketi start --config=soketi.json
```

---

### Step 4: Configure Environment Variables

**File:** `.env`

```env
# Application
APP_NAME="RealTime Chat"
APP_ENV=local
APP_DEBUG=true
APP_URL=http://localhost:8000

# Database
DB_CONNECTION=mysql
DB_HOST=127.0.0.1
DB_PORT=3306
DB_DATABASE=realtime_chat
DB_USERNAME=root
DB_PASSWORD=

# Broadcasting
BROADCAST_DRIVER=redis
QUEUE_CONNECTION=redis

# Redis Configuration
REDIS_HOST=127.0.0.1
REDIS_PASSWORD=null
REDIS_PORT=6379
REDIS_DB=0
REDIS_CACHE_DB=1

# Pusher/Soketi Configuration
PUSHER_APP_ID=app-id
PUSHER_APP_KEY=app-key
PUSHER_APP_SECRET=app-secret
PUSHER_HOST=127.0.0.1
PUSHER_PORT=6001
PUSHER_SCHEME=http
PUSHER_APP_CLUSTER=mt1

# Enable broadcasting
VITE_PUSHER_APP_KEY="${PUSHER_APP_KEY}"
VITE_PUSHER_HOST="${PUSHER_HOST}"
VITE_PUSHER_PORT="${PUSHER_PORT}"
VITE_PUSHER_SCHEME="${PUSHER_SCHEME}"
VITE_PUSHER_APP_CLUSTER="${PUSHER_APP_CLUSTER}"
```

---

### Step 5: Configure Broadcasting

**File:** `config/broadcasting.php`

```php
<?php

return [
    'default' => env('BROADCAST_DRIVER', 'null'),

    'connections' => [
        'pusher' => [
            'driver' => 'pusher',
            'key' => env('PUSHER_APP_KEY'),
            'secret' => env('PUSHER_APP_SECRET'),
            'app_id' => env('PUSHER_APP_ID'),
            'options' => [
                'host' => env('PUSHER_HOST', '127.0.0.1'),
                'port' => env('PUSHER_PORT', 6001),
                'scheme' => env('PUSHER_SCHEME', 'http'),
                'encrypted' => true,
                'useTLS' => env('PUSHER_SCHEME', 'http') === 'https',
                'cluster' => env('PUSHER_APP_CLUSTER', 'mt1'),
            ],
            'client_options' => [
                // Guzzle client options: https://docs.guzzlephp.org/en/stable/request-options.html
            ],
        ],

        'redis' => [
            'driver' => 'redis',
            'connection' => 'default',
        ],

        'log' => [
            'driver' => 'log',
        ],

        'null' => [
            'driver' => 'null',
        ],
    ],
];
```

---

### Step 6: Uncomment Broadcasting Service Provider

**File:** `config/app.php`

```php
'providers' => [
    // ... other providers
    App\Providers\BroadcastServiceProvider::class,
],
```

---

### Step 7: Database Setup

**Create Migration:**
```bash
php artisan make:migration create_messages_table --create=messages
php artisan make:migration create_conversations_table --create=conversations
```

**File:** `database/migrations/xxxx_xx_xx_create_conversations_table.php`

```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up()
    {
        Schema::create('conversations', function (Blueprint $table) {
            $table->id();
            $table->string('name')->nullable();
            $table->enum('type', ['private', 'group'])->default('private');
            $table->timestamps();
        });

        // Pivot table for users in conversations
        Schema::create('conversation_user', function (Blueprint $table) {
            $table->id();
            $table->foreignId('conversation_id')->constrained()->onDelete('cascade');
            $table->foreignId('user_id')->constrained()->onDelete('cascade');
            $table->timestamp('last_read_at')->nullable();
            $table->timestamps();
            
            $table->unique(['conversation_id', 'user_id']);
        });
    }

    public function down()
    {
        Schema::dropIfExists('conversation_user');
        Schema::dropIfExists('conversations');
    }
};
```

**File:** `database/migrations/xxxx_xx_xx_create_messages_table.php`

```php
<?php

use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

return new class extends Migration
{
    public function up()
    {
        Schema::create('messages', function (Blueprint $table) {
            $table->id();
            $table->foreignId('conversation_id')->constrained()->onDelete('cascade');
            $table->foreignId('user_id')->constrained()->onDelete('cascade');
            $table->text('message');
            $table->boolean('is_read')->default(false);
            $table->timestamps();
            
            $table->index(['conversation_id', 'created_at']);
        });
    }

    public function down()
    {
        Schema::dropIfExists('messages');
    }
};
```

**Run Migrations:**
```bash
php artisan migrate
```

---

### Step 8: Create Models

**File:** `app/Models/Conversation.php`

```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsToMany;
use Illuminate\Database\Eloquent\Relations\HasMany;

class Conversation extends Model
{
    use HasFactory;

    protected $fillable = ['name', 'type'];

    public function users(): BelongsToMany
    {
        return $this->belongsToMany(User::class)
            ->withPivot('last_read_at')
            ->withTimestamps();
    }

    public function messages(): HasMany
    {
        return $this->hasMany(Message::class)->latest();
    }

    public function latestMessage()
    {
        return $this->hasOne(Message::class)->latestOfMany();
    }
}
```

**File:** `app/Models/Message.php`

```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;

class Message extends Model
{
    use HasFactory;

    protected $fillable = [
        'conversation_id',
        'user_id',
        'message',
        'is_read'
    ];

    protected $casts = [
        'is_read' => 'boolean',
        'created_at' => 'datetime',
    ];

    protected $with = ['user'];

    public function conversation(): BelongsTo
    {
        return $this->belongsTo(Conversation::class);
    }

    public function user(): BelongsTo
    {
        return $this->belongsTo(User::class);
    }
}
```

**Update User Model:** `app/Models/User.php`

```php
public function conversations()
{
    return $this->belongsToMany(Conversation::class)
        ->withPivot('last_read_at')
        ->withTimestamps();
}

public function messages()
{
    return $this->hasMany(Message::class);
}
```

---

### Step 9: Create Broadcasting Event

```bash
php artisan make:event MessageSent
```

**File:** `app/Events/MessageSent.php`

```php
<?php

namespace App\Events;

use App\Models\Message;
use Illuminate\Broadcasting\Channel;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Broadcasting\PresenceChannel;
use Illuminate\Broadcasting\PrivateChannel;
use Illuminate\Contracts\Broadcasting\ShouldBroadcast;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Queue\SerializesModels;

class MessageSent implements ShouldBroadcast
{
    use Dispatchable, InteractsWithSockets, SerializesModels;

    public $message;

    /**
     * Create a new event instance.
     */
    public function __construct(Message $message)
    {
        $this->message = $message;
    }

    /**
     * Get the channels the event should broadcast on.
     */
    public function broadcastOn(): Channel|array
    {
        return new PrivateChannel('conversation.' . $this->message->conversation_id);
    }

    /**
     * The event's broadcast name.
     */
    public function broadcastAs(): string
    {
        return 'message.sent';
    }

    /**
     * Get the data to broadcast.
     */
    public function broadcastWith(): array
    {
        return [
            'id' => $this->message->id,
            'conversation_id' => $this->message->conversation_id,
            'user_id' => $this->message->user_id,
            'user' => [
                'id' => $this->message->user->id,
                'name' => $this->message->user->name,
            ],
            'message' => $this->message->message,
            'created_at' => $this->message->created_at->toISOString(),
        ];
    }
}
```

---

### Step 10: Create Additional Events

**User Typing Event:**
```bash
php artisan make:event UserTyping
```

**File:** `app/Events/UserTyping.php`

```php
<?php

namespace App\Events;

use App\Models\User;
use Illuminate\Broadcasting\Channel;
use Illuminate\Broadcasting\InteractsWithSockets;
use Illuminate\Broadcasting\PrivateChannel;
use Illuminate\Contracts\Broadcasting\ShouldBroadcast;
use Illuminate\Foundation\Events\Dispatchable;
use Illuminate\Queue\SerializesModels;

class UserTyping implements ShouldBroadcast
{
    use Dispatchable, InteractsWithSockets, SerializesModels;

    public $user;
    public $conversationId;
    public $isTyping;

    public function __construct(User $user, int $conversationId, bool $isTyping = true)
    {
        $this->user = $user;
        $this->conversationId = $conversationId;
        $this->isTyping = $isTyping;
    }

    public function broadcastOn(): Channel
    {
        return new PrivateChannel('conversation.' . $this->conversationId);
    }

    public function broadcastAs(): string
    {
        return 'user.typing';
    }

    public function broadcastWith(): array
    {
        return [
            'user_id' => $this->user->id,
            'user_name' => $this->user->name,
            'is_typing' => $this->isTyping,
        ];
    }
}
```

---

### Step 11: Define Broadcast Routes

**File:** `routes/channels.php`

```php
<?php

use Illuminate\Support\Facades\Broadcast;
use App\Models\Conversation;

/*
|--------------------------------------------------------------------------
| Broadcast Channels
|--------------------------------------------------------------------------
*/

// Authenticate user for their private channel
Broadcast::channel('user.{userId}', function ($user, $userId) {
    return (int) $user->id === (int) $userId;
});

// Authenticate user for conversation channels
Broadcast::channel('conversation.{conversationId}', function ($user, $conversationId) {
    return $user->conversations()
        ->where('conversation_id', $conversationId)
        ->exists();
});

// Presence channel for online users in conversation
Broadcast::channel('conversation-presence.{conversationId}', function ($user, $conversationId) {
    if ($user->conversations()->where('conversation_id', $conversationId)->exists()) {
        return [
            'id' => $user->id,
            'name' => $user->name,
            'avatar' => $user->avatar ?? null,
        ];
    }
});
```

---

### Step 12: Create Controllers

```bash
php artisan make:controller MessageController
php artisan make:controller ConversationController
```

**File:** `app/Http/Controllers/MessageController.php`

```php
<?php

namespace App\Http\Controllers;

use App\Models\Message;
use App\Models\Conversation;
use App\Events\MessageSent;
use App\Events\UserTyping;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;

class MessageController extends Controller
{
    /**
     * Get messages for a conversation
     */
    public function index(Conversation $conversation)
    {
        // Verify user is part of conversation
        if (!$conversation->users()->where('user_id', Auth::id())->exists()) {
            abort(403, 'Unauthorized');
        }

        $messages = $conversation->messages()
            ->with('user')
            ->orderBy('created_at', 'asc')
            ->paginate(50);

        return response()->json($messages);
    }

    /**
     * Send a new message
     */
    public function store(Request $request, Conversation $conversation)
    {
        // Verify user is part of conversation
        if (!$conversation->users()->where('user_id', Auth::id())->exists()) {
            abort(403, 'Unauthorized');
        }

        $validated = $request->validate([
            'message' => 'required|string|max:1000',
        ]);

        $message = $conversation->messages()->create([
            'user_id' => Auth::id(),
            'message' => $validated['message'],
        ]);

        // Load the user relationship
        $message->load('user');

        // Broadcast the message
        broadcast(new MessageSent($message))->toOthers();

        return response()->json($message, 201);
    }

    /**
     * Mark messages as read
     */
    public function markAsRead(Conversation $conversation)
    {
        $conversation->messages()
            ->where('user_id', '!=', Auth::id())
            ->where('is_read', false)
            ->update(['is_read' => true]);

        // Update last read timestamp
        $conversation->users()
            ->updateExistingPivot(Auth::id(), [
                'last_read_at' => now()
            ]);

        return response()->json(['message' => 'Messages marked as read']);
    }

    /**
     * Handle typing indicator
     */
    public function typing(Request $request, Conversation $conversation)
    {
        $validated = $request->validate([
            'is_typing' => 'required|boolean',
        ]);

        broadcast(new UserTyping(
            Auth::user(),
            $conversation->id,
            $validated['is_typing']
        ))->toOthers();

        return response()->json(['status' => 'broadcasted']);
    }
}
```

**File:** `app/Http/Controllers/ConversationController.php`

```php
<?php

namespace App\Http\Controllers;

use App\Models\Conversation;
use App\Models\User;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Auth;
use Illuminate\Support\Facades\DB;

class ConversationController extends Controller
{
    /**
     * Get all conversations for authenticated user
     */
    public function index()
    {
        $conversations = Auth::user()
            ->conversations()
            ->with(['users', 'latestMessage.user'])
            ->withCount(['messages as unread_count' => function ($query) {
                $query->where('user_id', '!=', Auth::id())
                    ->where('is_read', false);
            }])
            ->latest('updated_at')
            ->get();

        return response()->json($conversations);
    }

    /**
     * Create a new conversation
     */
    public function store(Request $request)
    {
        $validated = $request->validate([
            'user_id' => 'required|exists:users,id',
            'type' => 'in:private,group',
        ]);

        // Check if private conversation already exists
        if ($validated['type'] === 'private') {
            $existingConversation = Conversation::where('type', 'private')
                ->whereHas('users', function ($query) use ($validated) {
                    $query->where('user_id', $validated['user_id']);
                })
                ->whereHas('users', function ($query) {
                    $query->where('user_id', Auth::id());
                })
                ->first();

            if ($existingConversation) {
                return response()->json($existingConversation);
            }
        }

        // Create new conversation
        $conversation = DB::transaction(function () use ($validated) {
            $conversation = Conversation::create([
                'type' => $validated['type'] ?? 'private',
            ]);

            // Attach users to conversation
            $conversation->users()->attach([
                Auth::id(),
                $validated['user_id']
            ]);

            return $conversation->load('users');
        });

        return response()->json($conversation, 201);
    }

    /**
     * Show a specific conversation
     */
    public function show(Conversation $conversation)
    {
        // Verify user is part of conversation
        if (!$conversation->users()->where('user_id', Auth::id())->exists()) {
            abort(403, 'Unauthorized');
        }

        $conversation->load(['users', 'messages.user']);

        return response()->json($conversation);
    }
}
```

---

### Step 13: Define API Routes

**File:** `routes/api.php`

```php
<?php

use Illuminate\Http\Request;
use Illuminate\Support\Facades\Route;
use App\Http\Controllers\ConversationController;
use App\Http\Controllers\MessageController;

Route::middleware('auth:sanctum')->group(function () {
    // User info
    Route::get('/user', function (Request $request) {
        return $request->user();
    });

    // Conversations
    Route::get('/conversations', [ConversationController::class, 'index']);
    Route::post('/conversations', [ConversationController::class, 'store']);
    Route::get('/conversations/{conversation}', [ConversationController::class, 'show']);

    // Messages
    Route::get('/conversations/{conversation}/messages', [MessageController::class, 'index']);
    Route::post('/conversations/{conversation}/messages', [MessageController::class, 'store']);
    Route::post('/conversations/{conversation}/read', [MessageController::class, 'markAsRead']);
    Route::post('/conversations/{conversation}/typing', [MessageController::class, 'typing']);
});
```

---

### Step 14: Configure Laravel Echo (Frontend)

**File:** `resources/js/bootstrap.js`

```javascript
import axios from 'axios';
window.axios = axios;

window.axios.defaults.headers.common['X-Requested-With'] = 'XMLHttpRequest';

/**
 * Echo exposes an expressive API for subscribing to channels and listening
 * for events that are broadcast by Laravel. Echo and event broadcasting
 * allows your team to easily build robust real-time web applications.
 */

import Echo from 'laravel-echo';
import io from 'socket.io-client';

window.io = io;

window.Echo = new Echo({
    broadcaster: 'socket.io',
    host: `${import.meta.env.VITE_PUSHER_HOST}:${import.meta.env.VITE_PUSHER_PORT}`,
    auth: {
        headers: {
            Authorization: `Bearer ${localStorage.getItem('token')}`,
        },
    },
    transports: ['websocket', 'polling'],
});
```

---

### Step 15: Create Vue.js Chat Component

**File:** `resources/js/components/ChatComponent.vue`

```vue
<template>
    <div class="chat-container">
        <!-- Sidebar: Conversations List -->
        <div class="conversations-sidebar">
            <div class="sidebar-header">
                <h3>Messages</h3>
                <button @click="showNewConversation = true" class="btn-new">
                    <i class="icon-plus"></i> New Chat
                </button>
            </div>

            <div class="conversations-list">
                <div
                    v-for="conversation in conversations"
                    :key="conversation.id"
                    @click="selectConversation(conversation)"
                    :class="['conversation-item', { active: activeConversation?.id === conversation.id }]"
                >
                    <div class="conversation-avatar">
                        {{ getConversationName(conversation).charAt(0) }}
                    </div>
                    <div class="conversation-info">
                        <div class="conversation-name">
                            {{ getConversationName(conversation) }}
                        </div>
                        <div class="conversation-last-message">
                            {{ conversation.latest_message?.message || 'No messages yet' }}
                        </div>
                    </div>
                    <div v-if="conversation.unread_count > 0" class="unread-badge">
                        {{ conversation.unread_count }}
                    </div>
                </div>
            </div>
        </div>

        <!-- Main Chat Area -->
        <div class="chat-main">
            <div v-if="activeConversation" class="chat-content">
                <!-- Chat Header -->
                <div class="chat-header">
                    <div class="chat-user-info">
                        <div class="chat-avatar">
                            {{ getConversationName(activeConversation).charAt(0) }}
                        </div>
                        <div>
                            <h4>{{ getConversationName(activeConversation) }}</h4>
                            <span v-if="typingUsers.length > 0" class="typing-indicator">
                                {{ typingUsers.join(', ') }} {{ typingUsers.length > 1 ? 'are' : 'is' }} typing...
                            </span>
                            <span v-else class="online-status">
                                {{ onlineUsers.length }} online
                            </span>
                        </div>
                    </div>
                </div>

                <!-- Messages -->
                <div ref="messagesContainer" class="messages-container">
                    <div
                        v-for="message in messages"
                        :key="message.id"
                        :class="['message', { 'message-sent': message.user_id === currentUser.id, 'message-received': message.user_id !== currentUser.id }]"
                    >
                        <div v-if="message.user_id !== currentUser.id" class="message-avatar">
                            {{ message.user.name.charAt(0) }}
                        </div>
                        <div class="message-content">
                            <div v-if="message.user_id !== currentUser.id" class="message-author">
                                {{ message.user.name }}
                            </div>
                            <div class="message-bubble">
                                {{ message.message }}
                            </div>
                            <div class="message-time">
                                {{ formatTime(message.created_at) }}
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Message Input -->
                <div class="message-input-container">
                    <form @submit.prevent="sendMessage">
                        <input
                            v-model="newMessage"
                            @input="handleTyping"
                            type="text"
                            placeholder="Type a message..."
                            class="message-input"
                        />
                        <button type="submit" class="send-button" :disabled="!newMessage.trim()">
                            Send
                        </button>
                    </form>
                </div>
            </div>

            <!-- Empty State -->
            <div v-else class="empty-state">
                <h3>Select a conversation to start messaging</h3>
            </div>
        </div>
    </div>
</template>

<script>
export default {
    data() {
        return {
            conversations: [],
            activeConversation: null,
            messages: [],
            newMessage: '',
            currentUser: null,
            typingUsers: [],
            onlineUsers: [],
            typingTimeout: null,
            showNewConversation: false,
        };
    },

    async mounted() {
        await this.loadCurrentUser();
        await this.loadConversations();
        this.setupEchoListeners();
    },

    methods: {
        async loadCurrentUser() {
            try {
                const response = await axios.get('/api/user');
                this.currentUser = response.data;
            } catch (error) {
                console.error('Error loading user:', error);
            }
        },

        async loadConversations() {
            try {
                const response = await axios.get('/api/conversations');
                this.conversations = response.data;
            } catch (error) {
                console.error('Error loading conversations:', error);
            }
        },

        async selectConversation(conversation) {
            this.activeConversation = conversation;
            await this.loadMessages(conversation.id);
            this.subscribeToConversation(conversation.id);
            this.markAsRead(conversation.id);
        },

        async loadMessages(conversationId) {
            try {
                const response = await axios.get(`/api/conversations/${conversationId}/messages`);
                this.messages = response.data.data;
                this.$nextTick(() => {
                    this.scrollToBottom();
                });
            } catch (error) {
                console.error('Error loading messages:', error);
            }
        },

        async sendMessage() {
            if (!this.newMessage.trim()) return;

            try {
                const response = await axios.post(
                    `/api/conversations/${this.activeConversation.id}/messages`,
                    { message: this.newMessage }
                );

                this.messages.push(response.data);
                this.newMessage = '';
                this.scrollToBottom();

                // Stop typing indicator
                this.broadcastTyping(false);
            } catch (error) {
                console.error('Error sending message:', error);
            }
        },

        async markAsRead(conversationId) {
            try {
                await axios.post(`/api/conversations/${conversationId}/read`);
                
                // Update unread count in sidebar
                const conversation = this.conversations.find(c => c.id === conversationId);
                if (conversation) {
                    conversation.unread_count = 0;
                }
            } catch (error) {
                console.error('Error marking as read:', error);
            }
        },

        handleTyping() {
            this.broadcastTyping(true);

            // Clear previous timeout
            if (this.typingTimeout) {
                clearTimeout(this.typingTimeout);
            }

            // Set new timeout to stop typing indicator
            this.typingTimeout = setTimeout(() => {
                this.broadcastTyping(false);
            }, 2000);
        },

        async broadcastTyping(isTyping) {
            if (!this.activeConversation) return;

            try {
                await axios.post(
                    `/api/conversations/${this.activeConversation.id}/typing`,
                    { is_typing: isTyping }
                );
            } catch (error) {
                console.error('Error broadcasting typing:', error);
            }
        },

        setupEchoListeners() {
            // Global presence channel (optional - for online users)
            window.Echo.join('online')
                .here((users) => {
                    this.onlineUsers = users;
                })
                .joining((user) => {
                    this.onlineUsers.push(user);
                })
                .leaving((user) => {
                    this.onlineUsers = this.onlineUsers.filter(u => u.id !== user.id);
                });
        },

        subscribeToConversation(conversationId) {
            // Leave previous channel
            if (this.currentChannel) {
                window.Echo.leave(this.currentChannel);
            }

            this.currentChannel = `conversation.${conversationId}`;

            // Subscribe to private conversation channel
            window.Echo.private(this.currentChannel)
                .listen('.message.sent', (event) => {
                    this.messages.push(event);
                    this.scrollToBottom();
                    
                    // Update conversation in sidebar
                    const conversation = this.conversations.find(c => c.id === conversationId);
                    if (conversation) {
                        conversation.latest_message = event;
                        if (this.activeConversation?.id !== conversationId) {
                            conversation.unread_count++;
                        }
                    }
                })
                .listen('.user.typing', (event) => {
                    if (event.is_typing) {
                        if (!this.typingUsers.includes(event.user_name)) {
                            this.typingUsers.push(event.user_name);
                        }
                    } else {
                        this.typingUsers = this.typingUsers.filter(name => name !== event.user_name);
                    }
                });

            // Join presence channel to see who's online
            window.Echo.join(`conversation-presence.${conversationId}`)
                .here((users) => {
                    this.onlineUsers = users;
                })
                .joining((user) => {
                    this.onlineUsers.push(user);
                })
                .leaving((user) => {
                    this.onlineUsers = this.onlineUsers.filter(u => u.id !== user.id);
                });
        },

        scrollToBottom() {
            this.$nextTick(() => {
                const container = this.$refs.messagesContainer;
                if (container) {
                    container.scrollTop = container.scrollHeight;
                }
            });
        },

        formatTime(timestamp) {
            const date = new Date(timestamp);
            const now = new Date();
            const diff = now - date;

            // Less than 1 minute
            if (diff < 60000) {
                return 'Just now';
            }

            // Less than 1 hour
            if (diff < 3600000) {
                const minutes = Math.floor(diff / 60000);
                return `${minutes}m ago`;
            }

            // Today
            if (date.toDateString() === now.toDateString()) {
                return date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
            }

            // This week
            if (diff < 604800000) {
                return date.toLocaleDateString('en-US', { weekday: 'short', hour: '2-digit', minute: '2-digit' });
            }

            // Older
            return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        },

        getConversationName(conversation) {
            if (conversation.name) {
                return conversation.name;
            }

            const otherUser = conversation.users.find(u => u.id !== this.currentUser?.id);
            return otherUser?.name || 'Unknown User';
        },
    },

    beforeUnmount() {
        // Leave all channels when component unmounts
        if (this.currentChannel) {
            window.Echo.leave(this.currentChannel);
        }
        window.Echo.leave('online');
    },
};
</script>

<style scoped>
.chat-container {
    display: flex;
    height: 100vh;
    background: #f5f7fb;
}

/* Sidebar Styles */
.conversations-sidebar {
    width: 350px;
    background: white;
    border-right: 1px solid #e5e7eb;
    display: flex;
    flex-direction: column;
}

.sidebar-header {
    padding: 20px;
    border-bottom: 1px solid #e5e7eb;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.sidebar-header h3 {
    margin: 0;
    font-size: 24px;
    color: #1f2937;
}

.btn-new {
    background: #4f46e5;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 6px;
    cursor: pointer;
    font-size: 14px;
}

.btn-new:hover {
    background: #4338ca;
}

.conversations-list {
    flex: 1;
    overflow-y: auto;
}

.conversation-item {
    display: flex;
    align-items: center;
    padding: 16px 20px;
    cursor: pointer;
    border-bottom: 1px solid #f3f4f6;
    transition: background 0.2s;
}

.conversation-item:hover {
    background: #f9fafb;
}

.conversation-item.active {
    background: #eff6ff;
    border-left: 3px solid #4f46e5;
}

.conversation-avatar {
    width: 48px;
    height: 48px;
    border-radius: 50%;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    font-size: 18px;
    margin-right: 12px;
    flex-shrink: 0;
}

.conversation-info {
    flex: 1;
    min-width: 0;
}

.conversation-name {
    font-weight: 600;
    color: #1f2937;
    margin-bottom: 4px;
}

.conversation-last-message {
    font-size: 14px;
    color: #6b7280;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.unread-badge {
    background: #ef4444;
    color: white;
    border-radius: 12px;
    padding: 2px 8px;
    font-size: 12px;
    font-weight: 600;
    min-width: 20px;
    text-align: center;
}

/* Chat Main Area */
.chat-main {
    flex: 1;
    display: flex;
    flex-direction: column;
}

.chat-content {
    display: flex;
    flex-direction: column;
    height: 100%;
}

.chat-header {
    background: white;
    padding: 16px 24px;
    border-bottom: 1px solid #e5e7eb;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.chat-user-info {
    display: flex;
    align-items: center;
}

.chat-avatar {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    margin-right: 12px;
}

.chat-header h4 {
    margin: 0 0 4px 0;
    color: #1f2937;
}

.typing-indicator {
    font-size: 13px;
    color: #4f46e5;
    font-style: italic;
}

.online-status {
    font-size: 13px;
    color: #10b981;
}

/* Messages Container */
.messages-container {
    flex: 1;
    overflow-y: auto;
    padding: 24px;
    background: #f9fafb;
}

.message {
    display: flex;
    margin-bottom: 16px;
    animation: slideIn 0.2s ease-out;
}

@keyframes slideIn {
    from {
        opacity: 0;
        transform: translateY(10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.message-sent {
    justify-content: flex-end;
}

.message-received {
    justify-content: flex-start;
}

.message-avatar {
    width: 32px;
    height: 32px;
    border-radius: 50%;
    background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
    color: white;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: bold;
    font-size: 14px;
    margin-right: 8px;
    flex-shrink: 0;
}

.message-content {
    max-width: 60%;
}

.message-author {
    font-size: 12px;
    color: #6b7280;
    margin-bottom: 4px;
    font-weight: 500;
}

.message-bubble {
    padding: 10px 16px;
    border-radius: 12px;
    word-wrap: break-word;
}

.message-sent .message-bubble {
    background: #4f46e5;
    color: white;
    border-bottom-right-radius: 4px;
}

.message-received .message-bubble {
    background: white;
    color: #1f2937;
    border-bottom-left-radius: 4px;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
}

.message-time {
    font-size: 11px;
    color: #9ca3af;
    margin-top: 4px;
}

.message-sent .message-time {
    text-align: right;
}

/* Message Input */
.message-input-container {
    background: white;
    padding: 16px 24px;
    border-top: 1px solid #e5e7eb;
}

.message-input-container form {
    display: flex;
    gap: 12px;
}

.message-input {
    flex: 1;
    padding: 12px 16px;
    border: 1px solid #e5e7eb;
    border-radius: 24px;
    font-size: 14px;
    outline: none;
    transition: border-color 0.2s;
}

.message-input:focus {
    border-color: #4f46e5;
}

.send-button {
    padding: 12px 24px;
    background: #4f46e5;
    color: white;
    border: none;
    border-radius: 24px;
    font-weight: 600;
    cursor: pointer;
    transition: background 0.2s;
}

.send-button:hover:not(:disabled) {
    background: #4338ca;
}

.send-button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

/* Empty State */
.empty-state {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 100%;
    color: #9ca3af;
}

/* Scrollbar Styles */
.conversations-list::-webkit-scrollbar,
.messages-container::-webkit-scrollbar {
    width: 6px;
}

.conversations-list::-webkit-scrollbar-track,
.messages-container::-webkit-scrollbar-track {
    background: #f3f4f6;
}

.conversations-list::-webkit-scrollbar-thumb,
.messages-container::-webkit-scrollbar-thumb {
    background: #d1d5db;
    border-radius: 3px;
}

.conversations-list::-webkit-scrollbar-thumb:hover,
.messages-container::-webkit-scrollbar-thumb:hover {
    background: #9ca3af;
}
</style>
```

---

### Step 16: Update Vite Configuration

**File:** `vite.config.js`

```javascript
import { defineConfig } from 'vite';
import laravel from 'laravel-vite-plugin';
import vue from '@vitejs/plugin-vue';

export default defineConfig({
    plugins: [
        laravel({
            input: ['resources/css/app.css', 'resources/js/app.js'],
            refresh: true,
        }),
        vue(),
    ],
    resolve: {
        alias: {
            vue: 'vue/dist/vue.esm-bundler.js',
        },
    },
});
```

---

### Step 17: Main App JavaScript

**File:** `resources/js/app.js`

```javascript
import './bootstrap';
import { createApp } from 'vue';
import ChatComponent from './components/ChatComponent.vue';

const app = createApp({});

app.component('chat-component', ChatComponent);

app.mount('#app');
```

---

### Step 18: Main View

**File:** `resources/views/chat.blade.php`

```blade
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="csrf-token" content="{{ csrf_token() }}">
    <title>{{ config('app.name') }} - Chat</title>
    @vite(['resources/css/app.css', 'resources/js/app.js'])
</head>
<body>
    <div id="app">
        <chat-component></chat-component>
    </div>
</body>
</html>
```

---

## üö¶ Running the Application

### Terminal 1: Start Laravel Server
```bash
php artisan serve
```

### Terminal 2: Start Queue Worker
```bash
php artisan queue:work
```

### Terminal 3: Start Soketi WebSocket Server
```bash
soketi start --config=soketi.json
```

### Terminal 4: Start Vite Dev Server
```bash
npm run dev
```

---

## üß™ Testing the Setup

### 1. Test Redis Connection
```bash
redis-cli ping
# Should return: PONG

# Monitor Redis activity
redis-cli monitor
```

### 2. Test Soketi Connection
```bash
# Visit Soketi metrics
curl http://localhost:9601/metrics
```

### 3. Test Broadcasting
```bash
php artisan tinker

# Broadcast a test event
$user = User::first();
$conversation = Conversation::first();
$message = Message::create([
    'conversation_id' => $conversation->id,
    'user_id' => $user->id,
    'message' => 'Test message'
]);

broadcast(new App\Events\MessageSent($message));
```

### 4. Debug Broadcasting
**Enable debug mode in Soketi:**
```json
{
    "debug": true,
    ...
}
```

**Check Laravel logs:**
```bash
tail -f storage/logs/laravel.log
```

---

## üìä Channel Types Explained

| Channel Type | Authentication | Use Case | Example |
|-------------|----------------|----------|---------|
| **Public** | None | Public data | `news-feed` |
| **Private** | Required | User-specific data | `conversation.123` |
| **Presence** | Required | Online users tracking | `conversation-presence.123` |

### Public Channel
```php
public function broadcastOn()
{
    return new Channel('public-announcements');
}
```

### Private Channel
```php
public function broadcastOn()
{
    return new PrivateChannel('conversation.' . $this->conversationId);
}
```

### Presence Channel
```php
public function broadcastOn()
{
    return new PresenceChannel('chat-room.' . $this->roomId);
}
```

---

## üîí Security Best Practices

### 1. Channel Authorization
Always verify users have permission to join channels:

```php
// routes/channels.php
Broadcast::channel('conversation.{id}', function ($user, $id) {
    return $user->conversations()
        ->where('conversation_id', $id)
        ->exists();
});
```

### 2. Rate Limiting
```php
// app/Http/Kernel.php
'api' => [
    'throttle:60,1', // 60 requests per minute
    \Illuminate\Routing\Middleware\SubstituteBindings::class,
],
```

### 3. Input Validation
Always validate broadcast data:

```php
public function broadcastWith()
{
    return [
        'id' => $this->message->id,
        'message' => strip_tags($this->message->message),
        // Never send sensitive data
    ];
}
```

---

## ‚ö° Performance Optimization

### 1. Use Queue for Broadcasting
```php
class MessageSent implements ShouldBroadcast, ShouldQueue
{
    use Dispatchable, InteractsWithSockets, SerializesModels;
    
    public $queue = 'broadcasts';
}
```

### 2. Redis Optimization
**File:** `config/database.php`

```php
'redis' => [
    'client' => env('REDIS_CLIENT', 'predis'),
    
    'options' => [
        'cluster' => env('REDIS_CLUSTER', 'redis'),
        'prefix' => env('REDIS_PREFIX', Str::slug(env('APP_NAME', 'laravel'), '_').'_database_'),
    ],
    
    'default' => [
        'url' => env('REDIS_URL'),
        'host' => env('REDIS_HOST', '127.0.0.1'),
        'password' => env('REDIS_PASSWORD'),
        'port' => env('REDIS_PORT', '6379'),
        'database' => env('REDIS_DB', '0'),
        'read_timeout' => 60,
        'persistent' => true, // Persistent connections
    ],
],
```

### 3. Message Pagination
```php
public function index(Conversation $conversation)
{
    return $conversation->messages()
        ->with('user:id,name,avatar')
        ->latest()
        ->paginate(50);
}
```

### 4. Eager Loading
```php
$conversations = Conversation::with([
    'users:id,name,avatar',
    'latestMessage.user:id,name'
])->get();
```

---

## üêõ Common Issues & Solutions

| Issue | Cause | Solution |
|-------|-------|----------|
| "Connection refused" | Soketi not running | Start Soketi: `soketi start` |
| "401 Unauthorized" | Auth token missing | Add token to Echo config |
| Events not broadcasting | Wrong channel name | Check channel authorization |
| Redis connection failed | Redis not running | Start Redis: `redis-server` |
| CORS errors | Missing CORS config | Add CORS middleware |

---

## üì± Production Deployment

### 1. Soketi with PM2
```bash
npm install -g pm2

# Create ecosystem file
pm2 ecosystem

# Edit ecosystem.config.js
module.exports = {
  apps: [{
    name: 'soketi',
    script: 'soketi',
    args: 'start --config=soketi.json',
    instances: 2,
    autorestart: true,
    watch: false,
    max_memory_restart: '1G',
  }]
};

# Start
pm2 start ecosystem.config.js
pm2 save
pm2 startup
```

### 2. Supervisor for Queue Workers
```ini
[program:chat-queue-worker]
process_name=%(program_name)s_%(process_num)02d
command=php /var/www/html/artisan queue:work redis --sleep=3 --tries=3 --max-time=3600
autostart=true
autorestart=true
stopasgroup=true
killasgroup=true
user=www-data
numprocs=3
redirect_stderr=true
stdout_logfile=/var/www/html/storage/logs/worker.log
stopwaitsecs=3600
```

### 3. Nginx Configuration
```nginx
# WebSocket proxy for Soketi
location /socket.io/ {
    proxy_pass http://127.0.0.1:6001;
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "Upgrade";
    proxy_set_header Host $host;
    proxy_cache_bypass $http_upgrade;
}
```

### 4. SSL/TLS Configuration
```env
PUSHER_SCHEME=https
PUSHER_PORT=443

# In soketi.json
{
    "ssl": {
        "certPath": "/path/to/cert.pem",
        "keyPath": "/path/to/key.pem"
    }
}
```

---

## üìö Additional Features

### Typing Indicator
```javascript
let typingTimer;
const doneTypingInterval = 1000;

input.addEventListener('keyup', () => {
    clearTimeout(typingTimer);
    broadcast.typing(true);
    
    typingTimer = setTimeout(() => {
        broadcast.typing(false);
    }, doneTypingInterval);
});
```

### Read Receipts
```php
public function markAsRead(Message $message)
{
    $message->update(['read_at' => now()]);
    
    broadcast(new MessageRead($message))->toOthers();
}
```

### File Attachments
```php
public function store(Request $request, Conversation $conversation)
{
    $validated = $request->validate([
        'message' => 'required_without:attachment',
        'attachment' => 'nullable|file|max:10240',
    ]);
    
    if ($request->hasFile('attachment')) {
        $path = $request->file('attachment')->store('attachments');
        $validated['attachment_path'] = $path;
    }
    
    $message = $conversation->messages()->create($validated);
    broadcast(new MessageSent($message));
}
```

---

## ‚úÖ Best Practices Checklist

- ‚úÖ Always authenticate channels
- ‚úÖ Use queues for broadcasting
- ‚úÖ Implement rate limiting
- ‚úÖ Sanitize broadcast data
- ‚úÖ Use presence channels for online status
- ‚úÖ Implement pagination for messages
- ‚úÖ Add error handling for WebSocket disconnects
- ‚úÖ Monitor Redis memory usage
- ‚úÖ Use persistent Redis connections
- ‚úÖ Implement message retry logic
- ‚úÖ Add logging for debugging
- ‚úÖ Use CDN for static assets
- ‚úÖ Implement database indexes
- ‚úÖ Use Redis for caching
- ‚úÖ Monitor WebSocket connections

---

## üéì Summary

**Real-time Broadcasting Flow:**
```
Event Fired ‚Üí Redis Pub/Sub ‚Üí Soketi ‚Üí Laravel Echo ‚Üí Frontend Update
```

**Benefits:**
- ‚úÖ Real-time communication
- ‚úÖ Scalable architecture
- ‚úÖ Open-source (no Pusher fees)
- ‚úÖ Full control over infrastructure
- ‚úÖ Easy to debug and monitor
- ‚úÖ Works with any frontend framework

---

**Happy Real-Time Coding! üöÄüí¨**
