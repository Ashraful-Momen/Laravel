--------------------------------------------------
NOTE: What is Dependency Injection (DI) & how Laravel does it
--------------------------------------------------

1. Definition  
Dependency Injection is a technique where the dependencies an object needs (services, config, repositories, etc.) are **given to it** rather than the object creating them itself.  
Laravel’s Service Container handles this automatically via **constructor type-hints**.

2. Workflow (simplified ASCII)
```
┌-----------------------------┐
|  1. You ask for a class     |
|     (controller, job, …)    |
└------------┬----------------┘
             │
             ▼
┌-----------------------------┐
| 2. Router / Command Bus     |
|    sees type-hint:          |
|    function __construct(    |
|        Person $person       |
|    )                        |
└------------┬----------------┘
             │
             ▼
┌-----------------------------┐
| 3. Service Container        |
|    looks up binding:        |
|    Person::class → singleton|
└------------┬----------------┘
             │
             ▼
┌-----------------------------┐
| 4. If bound object exists   |
|    → return same instance   |
|    else → create & store    |
└------------┬----------------┘
             │
             ▼
┌-----------------------------┐
| 5. Object is injected       |
|    straight into ctor       |
└-----------------------------┘
```
Because the container already knows `Person` is a singleton (via `PersonServiceProvider`), every class receives **the same shared instance**.

3. Code walk-through with inline comments  
Same files as before, but now annotated to show the DI flow.

`app/Services/Person.php`
```php
<?php
namespace App\Services;

class Person           // plain POPO (Plain Old PHP Object)
{
    public $name;

    public function setName($name): self
    {
        $this->name = $name;
        return $this;
    }

    public function getName(): ?string
    {
        return $this->name;
    }
}
```

`app/Providers/PersonServiceProvider.php`
```php
<?php
namespace App\Providers;

use Illuminate\Support\ServiceProvider;
use App\Services\Person;

class PersonServiceProvider extends ServiceProvider
{
    public function register(): void
    {
        // Tell container: whenever somebody asks for Person::class
        // give the SAME object during this request / worker lifecycle.
        $this->app->singleton(Person::class);
    }
}
```

`app/Http/Controllers/GreetController.php`  ← DI in action
```php
<?php
namespace App\Http\Controllers;

use App\Services\Person;   // 1. type-hint
use Illuminate\Http\Request;

class GreetController extends Controller
{
    // 2. Constructor receives pre-built object from container
    public function __construct(private Person $person) {}

    public function __invoke(Request $request)
    {
        // 3. Use it—no “new”, no facade, no manual passing
        $this->person->setName($request->route('name', 'World'));

        return response()->json([
            'greeting' => 'Hello ' . $this->person->getName()
        ]);
    }
}
```

`routes/api.php`
```php
use App\Http\Controllers\GreetController;

Route::get('/greet/{name}', GreetController::class);
```

4. Quick cURL test
```bash
curl http://your-app.test/api/greet/Laravel
{"greeting":"Hello Laravel"}
```

No `new Person()` ever appears in your own code—the container **injected** the singleton automatically.
