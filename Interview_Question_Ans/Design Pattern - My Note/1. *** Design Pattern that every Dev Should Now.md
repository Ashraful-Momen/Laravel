## **7 Essential Design Patterns Every Developer Must Know**

### **1. Singleton Pattern** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê
**Category**: Creational  
**Purpose**: Ensure a class has only one instance and provide global access

```java
public class DatabaseConnection {
    private static DatabaseConnection instance;
    
    private DatabaseConnection() { } // Private constructor
    
    public static DatabaseConnection getInstance() {
        if (instance == null) {
            instance = new DatabaseConnection();
        }
        return instance;
    }
}
```
**Use Cases**: Database connections, configuration managers, logging services

---

### **2. Factory Method Pattern** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê
**Category**: Creational  
**Purpose**: Create objects without specifying exact classes

```java
public interface Payment {
    void processPayment(double amount);
}

public class CreditCardPayment implements Payment {
    public void processPayment(double amount) {
        System.out.println("Processing credit card: $" + amount);
    }
}

public class PayPalPayment implements Payment {
    public void processPayment(double amount) {
        System.out.println("Processing PayPal: $" + amount);
    }
}

public class PaymentFactory {
    public Payment createPayment(String type) {
        switch(type.toLowerCase()) {
            case "creditcard": return new CreditCardPayment();
            case "paypal": return new PayPalPayment();
            default: throw new IllegalArgumentException("Unknown payment type");
        }
    }
}
```
**Use Cases**: Payment processors, UI components, database connections

---

### **3. Observer Pattern** ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê
**Category**: Behavioral  
**Purpose**: One-to-many dependency between objects

```java
import java.util.*;

// Subject
class NewsAgency {
    private List<Observer> observers = new ArrayList<>();
    private String news;
    
    public void addObserver(Observer observer) {
        observers.add(observer);
    }
    
    public void setNews(String news) {
        this.news = news;
        notifyObservers();
    }
    
    private void notifyObservers() {
        for (Observer observer : observers) {
            observer.update(news);
        }
    }
}

// Observer
interface Observer {
    void update(String news);
}

class NewsChannel implements Observer {
    private String channelName;
    
    public NewsChannel(String name) {
        this.channelName = name;
    }
    
    public void update(String news) {
        System.out.println(channelName + " broadcasting: " + news);
    }
}
```
**Use Cases**: Event handling, publish-subscribe systems, UI updates

---

### **4. Strategy Pattern** ‚≠ê‚≠ê‚≠ê‚≠ê
**Category**: Behavioral  
**Purpose**: Define family of algorithms and make them interchangeable

```java
public interface SortingStrategy {
    void sort(int[] array);
}

public class BubbleSort implements SortingStrategy {
    public void sort(int[] array) {
        System.out.println("Sorting with Bubble Sort");
        // Implementation
    }
}

public class QuickSort implements SortingStrategy {
    public void sort(int[] array) {
        System.out.println("Sorting with Quick Sort");
        // Implementation
    }
}

public class Sorter {
    private SortingStrategy strategy;
    
    public void setStrategy(SortingStrategy strategy) {
        this.strategy = strategy;
    }
    
    public void sortArray(int[] array) {
        strategy.sort(array);
    }
}
```
**Use Cases**: Sorting algorithms, payment methods, compression algorithms

---

### **5. Decorator Pattern** ‚≠ê‚≠ê‚≠ê‚≠ê
**Category**: Structural  
**Purpose**: Add functionality to objects dynamically

```java
public interface Coffee {
    double getCost();
    String getDescription();
}

public class BasicCoffee implements Coffee {
    public double getCost() { return 2.00; }
    public String getDescription() { return "Basic coffee"; }
}

public abstract class CoffeeDecorator implements Coffee {
    protected Coffee decoratedCoffee;
    
    public CoffeeDecorator(Coffee coffee) {
        this.decoratedCoffee = coffee;
    }
    
    public double getCost() {
        return decoratedCoffee.getCost();
    }
    
    public String getDescription() {
        return decoratedCoffee.getDescription();
    }
}

public class MilkDecorator extends CoffeeDecorator {
    public MilkDecorator(Coffee coffee) {
        super(coffee);
    }
    
    public double getCost() {
        return super.getCost() + 0.50;
    }
    
    public String getDescription() {
        return super.getDescription() + ", with milk";
    }
}
```
**Use Cases**: Java I/O streams, GUI components, middleware

---

### **6. Adapter Pattern** ‚≠ê‚≠ê‚≠ê‚≠ê
**Category**: Structural  
**Purpose**: Make incompatible interfaces work together

```java
// Old system - incompatible
public class LegacyPrinter {
    public void printDocument(String text) {
        System.out.println("Legacy printing: " + text);
    }
}

// New system interface
public interface ModernPrinter {
    void print(String content);
}

// Adapter
public class PrinterAdapter implements ModernPrinter {
    private LegacyPrinter legacyPrinter;
    
    public PrinterAdapter(LegacyPrinter printer) {
        this.legacyPrinter = printer;
    }
    
    public void print(String content) {
        legacyPrinter.printDocument(content); // Adapting the call
    }
}
```
**Use Cases**: Integrating legacy code, third-party libraries, API wrappers

---

### **7. Template Method Pattern** ‚≠ê‚≠ê‚≠ê
**Category**: Behavioral  
**Purpose**: Define algorithm skeleton in base class

```java
public abstract class DataProcessor {
    // Template method - defines algorithm structure
    public final void process() {
        readData();
        processData();
        saveData();
    }
    
    protected abstract void readData();
    protected abstract void processData();
    
    protected void saveData() {
        System.out.println("Saving processed data...");
    }
}

public class CSVProcessor extends DataProcessor {
    protected void readData() {
        System.out.println("Reading CSV data...");
    }
    
    protected void processData() {
        System.out.println("Processing CSV data...");
    }
}

public class XMLProcessor extends DataProcessor {
    protected void readData() {
        System.out.println("Reading XML data...");
    }
    
    protected void processData() {
        System.out.println("Processing XML data...");
    }
}
```
**Use Cases**: Framework design, standard procedures, report generation

---

## **Why These 7 Patterns?**

| Pattern | Frequency | Importance | Learning Curve |
|---------|-----------|------------|----------------|
| Singleton | Very High | Critical | Easy |
| Factory Method | High | Critical | Easy |
| Observer | High | Critical | Medium |
| Strategy | High | Important | Easy |
| Decorator | Medium | Important | Medium |
| Adapter | Medium | Important | Easy |
| Template Method | Medium | Useful | Easy |

**Master these 7 and you'll handle 80% of common software design challenges!** üöÄ
