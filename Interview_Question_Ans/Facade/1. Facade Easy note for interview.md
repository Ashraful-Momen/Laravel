--------------------------------------------------
FACADE – super-simple English
--------------------------------------------------
A Laravel **Facade** is just a **short, easy-to-remember nickname** for a service that lives in the container.  
Behind the nickname the real object is still the one the container built (singleton, scoped, etc.).

--------------------------------------------------
ASCII work-flow (request life-cycle)
--------------------------------------------------
```
1. You write
   Cache::get('key')
     ▲
     │nickname
     │
2. Facade class
   (illuminate/support/Facades/Cache)
   has one method: getFacadeAccessor()
   returns string 'cache'
     ▲
     │
3. Facade base class looks into
   the Container with that string
   $app['cache']  (or $app->make('cache'))
     ▲
     │
4. Container gives back the real
   service object (RedisStore, FileStore…)
     ▲
     │
5. Facade forwards the call
   → get('key') runs on the real object
```

--------------------------------------------------
Coding steps – create a Facade for our Person service
--------------------------------------------------
We already have:

- `app/Services/Person.php`  (real class)  
- `PersonServiceProvider.php`  (binds it as singleton)

Step 1 – the **FULL** Person service class (copy–paste ready)  
`app/Services/Person.php`
```php
<?php

namespace App\Services;

class Person
{
    public $name;

    /**
     * Set the name and return self for chaining.
     */
    public function setName(string $name): self
    {
        $this->name = $name;
        return $this;
    }

    /**
     * Get the current name.
     */
    public function getName(): ?string
    {
        return $this->name;
    }
}
```

Step 2 – make the Facade class  
`app/Facades/Person.php`
```php
<?php
namespace App\Facades;          // choose any namespace you like

use Illuminate\Support\Facades\Facade;

/**
 * @method static string getName()
 * @method static self   setName(string $name)
 */
class Person extends Facade
{
    // This string is what the container will look up.
    protected static function getFacadeAccessor()
    {
        return \App\Services\Person::class; // same key we bound
    }
}
```

Step 3 – register the alias (optional but nice)  
`config/app.php`  – aliases array
```php
'aliases' => Facade::defaultAliases()->merge([
    'Person' => App\Facades\Person::class,   // <-- add this
])->toArray(),
```

Step 4 – use it anywhere
```php
use Person;   // top of file (or \Person if you did not import)

Route::get('/nick', function () {
    Person::setName('Taylor');
    return 'Hello '.Person::getName();
});
```

Step 5 – check it is still the singleton
```php
Route::get('/check', function () {
    $a = app(\App\Services\Person::class);
    $b = Person::getFacadeRoot();   // same object
    dd(spl_object_id($a) === spl_object_id($b)); // true
});
```

--------------------------------------------------
Tiny recap
--------------------------------------------------
1. Real object lives in container.  
2. Facade is only a **static proxy** that forwards calls to that object.  
3. You get short, pretty syntax (`Person::setName()`) without `new` or `app()`.
