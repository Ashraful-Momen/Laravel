# SOLID Principles - Complete Code Examples

## #S = Single Responsibility Principle:
---------------------------------------------
**Different different class handle different logic:**

```php
Class Student: handle student add, delete, or student related logic
Class Payment: handle the payment logic  
Class Notification: handle notification logic
```

**Don't implement all logic in one class.**

❌ **BAD:**
```php
<?php
class User {
    public $name;
    public $email;
    
    public function __construct($name, $email) {
        $this->name = $name;
        $this->email = $email;
    }
    
    public function saveToDatabase() {
        echo "Saving user {$this->name} to MySQL database...\n";
        // Database connection logic here
        // mysqli_connect(), INSERT query, etc.
    }
    
    public function sendEmail() {
        echo "Sending welcome email to {$this->email}...\n";
        // Email sending logic here
        // SMTP configuration, mail() function, etc.
    }
    
    public function validateData() {
        if(empty($this->name)) {
            echo "Name is required!\n";
            return false;
        }
        if(!filter_var($this->email, FILTER_VALIDATE_EMAIL)) {
            echo "Invalid email format!\n";
            return false;
        }
        return true;
    }
    
    public function generateReport() {
        echo "Generating user report for {$this->name}...\n";
        // Report generation logic here
        // PDF creation, CSV export, etc.
    }
}

// Usage - One class doing everything (BAD!)
$user = new User("John Doe", "john@example.com");
if ($user->validateData()) {
    $user->saveToDatabase();
    $user->sendEmail();
    $user->generateReport();
}
?>
```

✅ **GOOD:**
```php
<?php
// Only handles user data
class User {
    public $name;
    public $email;
    
    public function __construct($name, $email) {
        $this->name = $name;
        $this->email = $email;
    }
}

// Only handles database operations
class UserRepository {
    public function saveToDatabase(User $user) {
        echo "Saving {$user->name} to MySQL database...\n";
        // Database connection and save logic
        // $connection = new PDO(...);
        // $stmt = $connection->prepare("INSERT INTO users...");
    }
    
    public function deleteFromDatabase(User $user) {
        echo "Deleting {$user->name} from database...\n";
    }
}

// Only handles email operations
class EmailService {
    public function sendWelcomeEmail(User $user) {
        echo "Sending welcome email to {$user->email}...\n";
        // Email sending logic
        // mail($user->email, "Welcome!", "Welcome message");
    }
    
    public function sendPasswordResetEmail(User $user) {
        echo "Sending password reset email to {$user->email}...\n";
    }
}

// Only handles validation
class UserValidator {
    public function validateData(User $user) {
        if(empty($user->name)) {
            echo "Name is required!\n";
            return false;
        }
        if(!filter_var($user->email, FILTER_VALIDATE_EMAIL)) {
            echo "Invalid email format!\n";
            return false;
        }
        echo "User data is valid!\n";
        return true;
    }
}

// Only handles report generation
class ReportGenerator {
    public function generateUserReport(User $user) {
        echo "Generating user report for {$user->name}...\n";
        // Report generation logic
        // Create PDF, generate CSV, etc.
    }
    
    public function generateUsageReport(User $user) {
        echo "Generating usage report for {$user->name}...\n";
    }
}

// Usage - Each class has one responsibility (GOOD!)
$user = new User("John Doe", "john@example.com");
$validator = new UserValidator();
$repository = new UserRepository();
$emailService = new EmailService();
$reportGenerator = new ReportGenerator();

if ($validator->validateData($user)) {
    $repository->saveToDatabase($user);
    $emailService->sendWelcomeEmail($user);
    $reportGenerator->generateUserReport($user);
}
?>
``` Only handles database operations
class UserRepository {
    public function saveToDatabase(User $user) {
        echo "Saving {$user->name} to MySQL database...\n";
        // Database connection and save logic
    }
}

// Only handles email operations
class EmailService {
    public function sendEmail(User $user) {
        echo "Sending welcome email to {$user->email}...\n";
        // Email sending logic
    }
}

// Only handles validation
class UserValidator {
    public function validateData(User $user) {
        if(empty($user->name)) return false;
        if(!filter_var($user->email, FILTER_VALIDATE_EMAIL)) return false;
        return true;
    }
}

// Only handles report generation
class ReportGenerator {
    public function generateReport(User $user) {
        echo "Generating user report for {$user->name}...\n";
        // Report generation logic
    }
}
```

## #O = Open/Closed Principle:
---------------------------------
**Main class handle all logic structure. We add some feature without change the main structure logic.**

✅ **Complete Example:**
```php
<?php
// Main structure - NEVER MODIFY THIS
abstract class Shape {
    abstract public function calculateArea();
    abstract public function getShapeType();
}

// Original shapes
class Circle extends Shape {
    private $radius;
    
    public function __construct($radius) {
        $this->radius = $radius;
    }
    
    public function calculateArea() {
        return pi() * $this->radius * $this->radius; // π * r²
    }
    
    public function getShapeType() {
        return "Circle";
    }
}

class Rectangle extends Shape {
    private $width;
    private $height;
    
    public function __construct($width, $height) {
        $this->width = $width;
        $this->height = $height;
    }
    
    public function calculateArea() {
        return $this->width * $this->height; // width * height
    }
    
    public function getShapeType() {
        return "Rectangle";
    }
}

// ADD NEW SHAPE WITHOUT CHANGING EXISTING CODE
class Triangle extends Shape {
    private $base;
    private $height;
    
    public function __construct($base, $height) {
        $this->base = $base;
        $this->height = $height;
    }
    
    public function calculateArea() {
        return ($this->base * $this->height) / 2; // (base * height) / 2
    }
    
    public function getShapeType() {
        return "Triangle";
    }
}

// ADD ANOTHER NEW SHAPE - STILL NO CHANGES TO EXISTING CODE
class Square extends Shape {
    private $side;
    
    public function __construct($side) {
        $this->side = $side;
    }
    
    public function calculateArea() {
        return $this->side * $this->side; // side²
    }
    
    public function getShapeType() {
        return "Square";
    }
}

// This class NEVER needs modification when adding new shapes
class AreaCalculator {
    public function getTotalArea(array $shapes) {
        $totalArea = 0;
        foreach($shapes as $shape) {
            $totalArea += $shape->calculateArea(); // Works with ANY shape!
        }
        return $totalArea;
    }
    
    public function getShapeDetails(array $shapes) {
        foreach($shapes as $shape) {
            echo $shape->getShapeType() . " area: " . $shape->calculateArea() . "\n";
        }
    }
}

// Usage example - Adding new shapes works automatically!
$shapes = [
    new Circle(5),
    new Rectangle(4, 6),
    new Triangle(8, 10),    // New shape works automatically!
    new Square(7)           // Another new shape works automatically!
];

$calculator = new AreaCalculator();
echo "=== Shape Details ===\n";
$calculator->getShapeDetails($shapes);
echo "\nTotal Area: " . $calculator->getTotalArea($shapes) . "\n";
?>
```

## #L = Liskov Substitution Principle:
---------------------------------
**Child class can replace parent class without breaking the program.**

✅ **Complete Example:**
```php
<?php
// Base class
class Bird {
    protected $name;
    
    public function __construct($name) {
        $this->name = $name;
    }
    
    public function eat() {
        echo "{$this->name} is eating seeds...\n";
    }
    
    public function makeSound() {
        echo "{$this->name} makes bird sound...\n";
    }
    
    public function getName() {
        return $this->name;
    }
}

// Flying birds extend Bird
class FlyingBird extends Bird {
    public function fly() {
        echo "{$this->name} is soaring in the sky...\n";
    }
    
    public function land() {
        echo "{$this->name} is landing...\n";
    }
}

// Sparrow can substitute FlyingBird perfectly
class Sparrow extends FlyingBird {
    public function fly() {
        echo "{$this->name} flies fast and agile...\n";
    }
    
    public function makeSound() {
        echo "{$this->name}: Tweet tweet!\n";
    }
}

// Eagle can substitute FlyingBird perfectly
class Eagle extends FlyingBird {
    public function fly() {
        echo "{$this->name} flies high and powerful...\n";
    }
    
    public function makeSound() {
        echo "{$this->name}: Screech!\n";
    }
    
    public function hunt() {
        echo "{$this->name} is hunting for prey...\n";
    }
}

// Penguin extends Bird but doesn't inherit flying (correct!)
class Penguin extends Bird {
    public function swim() {
        echo "{$this->name} swims gracefully underwater...\n";
    }
    
    public function makeSound() {
        echo "{$this->name}: Honk honk!\n";
    }
    
    public function slide() {
        echo "{$this->name} slides on ice...\n";
    }
}

// These functions work with ANY of their parameter types
function makeBirdEat(Bird $bird) {
    echo "=== Making {$bird->getName()} eat ===\n";
    $bird->eat();     // All birds can eat
    $bird->makeSound(); // All birds make sound
}

function makeBirdFly(FlyingBird $bird) {
    echo "=== Making {$bird->getName()} fly ===\n";
    $bird->eat();     // All birds can eat
    $bird->fly();     // All flying birds can fly
    $bird->land();    // All flying birds can land
    $bird->makeSound(); // All birds make sound
}

function handlePenguin(Penguin $penguin) {
    echo "=== Handling {$penguin->getName()} ===\n";
    $penguin->eat();
    $penguin->swim();
    $penguin->slide();
    $penguin->makeSound();
}

// Usage - Sparrow and Eagle can replace FlyingBird anywhere!
$sparrow = new Sparrow("Tweety");
$eagle = new Eagle("Mighty");
$penguin = new Penguin("Pingu");

// ✅ Liskov Substitution works perfectly
echo "=== Bird polymorphism ===\n";
makeBirdEat($sparrow); // Bird can be substituted
makeBirdEat($eagle);   // Bird can be substituted
makeBirdEat($penguin); // Bird can be substituted

echo "\n=== Flying bird polymorphism ===\n";
makeBirdFly($sparrow); // FlyingBird can be substituted
makeBirdFly($eagle);   // FlyingBird can be substituted

echo "\n=== Penguin specific behavior ===\n";
handlePenguin($penguin); // Penguin has its own abilities

// ✅ Array of birds - all work the same way
echo "\n=== All birds together ===\n";
$allBirds = [$sparrow, $eagle, $penguin];
foreach($allBirds as $bird) {
    $bird->eat();
    $bird->makeSound();
    
    // Check specific capabilities
    if ($bird instanceof FlyingBird) {
        $bird->fly();
    }
    if ($bird instanceof Penguin) {
        $bird->swim();
    }
    echo "---\n";
}
?>
```

## #I = Interface Segregation Principle:
---------------------------------
**Many small interfaces better than one big interface. Don't force class to implement unused methods.**

❌ **BAD - Big Interface:**
```php
// One big interface forces all classes to implement everything
interface AllActions {
    public function read();
    public function write($data);
    public function execute();
    public function print();
    public function compress();
    public function encrypt();
}

// TextFile forced to implement methods it can't use!
class TextFile implements AllActions {
    private $content = "";
    
    public function read() {
        echo "Reading text file...\n";
        return $this->content;
    }
    
    public function write($data) {
        $this->content = $data;
        echo "Writing to text file: {$data}\n";
    }
    
    // ❌ FORCED to implement - but TextFiles can't execute!
    public function execute() {
        throw new Exception("Text files cannot be executed!");
    }
    
    // ❌ FORCED to implement - but TextFiles can't print!
    public function print() {
        throw new Exception("Text files cannot print directly!");
    }
    
    // ❌ FORCED to implement unused methods
    public function compress() {
        throw new Exception("Not supported!");
    }
    
    public function encrypt() {
        throw new Exception("Not supported!");
    }
}
```

✅ **GOOD - Small Interfaces:**
```php
// Small, focused interfaces
interface Readable {
    public function read();
}

interface Writable {
    public function write($data);
}

interface Executable {
    public function execute();
}

interface Printable {
    public function print();
}

// Classes implement only what they need
class TextFile implements Readable, Writable {
    private $content = "";
    
    public function read() {
        echo "Reading text file...\n";
        return $this->content;
    }
    
    public function write($data) {
        $this->content = $data;
        echo "Writing to text file: {$data}\n";
    }
    // ✅ No forced unused methods!
}

class Script implements Readable, Executable {
    private $script = "echo 'Hello World'";
    
    public function read() {
        echo "Reading script file...\n";
        return $this->script;
    }
    
    public function execute() {
        echo "Executing script: {$this->script}\n";
        // Execute the script
    }
    // ✅ Only implements what it needs!
}

class Document implements Readable, Printable {
    private $content = "Document content";
    
    public function read() {
        echo "Reading document...\n";
        return $this->content;
    }
    
    public function print() {
        echo "Printing document: {$this->content}\n";
        // Send to printer
    }
    // ✅ Perfect! Only relevant methods!
}

// Usage:
$textFile = new TextFile();
$textFile->write("Hello World");
$textFile->read();

$script = new Script();
$script->read();
$script->execute();
```

## #D = Dependency Inversion Principle:
---------------------------------
**Depend on interface (contract), not on concrete class. High level should not depend on low level.**

❌ **BAD - Depends on concrete class:**
```php
// Concrete database classes
class MySQLDatabase {
    public function save($data) {
        echo "Saving to MySQL: {$data}\n";
    }
    
    public function find($id) {
        echo "Finding from MySQL ID: {$id}\n";
        return "mysql_data";
    }
}

// ❌ UserService depends directly on MySQL (tight coupling)
class UserService {
    private $mysql; // ❌ depends on specific database
    
    public function __construct() {
        $this->mysql = new MySQLDatabase(); // ❌ hard-coded dependency
    }
    
    public function saveUser($userData) {
        $this->mysql->save($userData); // ❌ stuck with MySQL only
    }
    
    public function getUser($id) {
        return $this->mysql->find($id); // ❌ cannot change database
    }
}

// If we want MongoDB, we need to CHANGE UserService code!
```

✅ **GOOD - Depends on interface:**
```php
// Interface (abstraction/contract)
interface DatabaseInterface {
    public function save($data);
    public function find($id);
}

// Concrete implementations
class MySQLDatabase implements DatabaseInterface {
    public function save($data) {
        echo "Saving to MySQL: {$data}\n";
        // MySQL specific code
    }
    
    public function find($id) {
        echo "Finding from MySQL ID: {$id}\n";
        return "mysql_user_data";
    }
}

class MongoDatabase implements DatabaseInterface {
    public function save($data) {
        echo "Saving to MongoDB: {$data}\n";
        // MongoDB specific code
    }
    
    public function find($id) {
        echo "Finding from MongoDB ID: {$id}\n";
        return "mongo_user_data";
    }
}

class PostgreSQLDatabase implements DatabaseInterface {
    public function save($data) {
        echo "Saving to PostgreSQL: {$data}\n";
        // PostgreSQL specific code
    }
    
    public function find($id) {
        echo "Finding from PostgreSQL ID: {$id}\n";
        return "postgresql_user_data";
    }
}

// ✅ UserService depends on interface, not concrete classes
class UserService {
    private $database; // ✅ depends on interface
    
    // ✅ Dependency injected through constructor
    public function __construct(DatabaseInterface $database) {
        $this->database = $database; // ✅ any database works!
    }
    
    public function saveUser($userData) {
        $this->database->save($userData); // ✅ works with any DB
    }
    
    public function getUser($id) {
        return $this->database->find($id); // ✅ flexible!
    }
}

// Usage - Same service works with different databases!
$userService1 = new UserService(new MySQLDatabase());
$userService2 = new UserService(new MongoDatabase());
$userService3 = new UserService(new PostgreSQLDatabase());

// All work the same way:
$userService1->saveUser("John Doe");
$userService2->saveUser("Jane Smith");  
$userService3->saveUser("Bob Wilson");
```

## #DRY Principle: Don't Repeat Yourself
----------------------

❌ **BAD - Repetition:**
```php
// Repeated code in multiple classes - BAD!
class StudentController {
    public function validateEmail($email) {
        if (!filter_var($email, FILTER_VALIDATE_EMAIL)) {
            return false;
        }
        return true;
    }
    
    public function sanitizeInput($input) {
        return htmlspecialchars(trim($input));
    }
    
    public function logActivity($message) {
        echo date('Y-m-d H:i:s') . " - " . $message . "\n";
    }
    
    public function addStudent($name, $email) {
        $email = $this->sanitizeInput($email);
        if (!$this->validateEmail($email)) {
            echo "Invalid email\n";
            return false;
        }
        $this->logActivity("Student added: $name");
        echo "Student $name added successfully\n";
    }
}

class TeacherController {
    // ❌ SAME CODE REPEATED!
    public function validateEmail($email) {
        if (!filter_var($email, FILTER_VALIDATE_EMAIL)) {
            return false;
        }
        return true;
    }
    
    // ❌ SAME CODE REPEATED!
    public function sanitizeInput($input) {
        return htmlspecialchars(trim($input));
    }
    
    // ❌ SAME CODE REPEATED!
    public function logActivity($message) {
        echo date('Y-m-d H:i:s') . " - " . $message . "\n";
    }
    
    public function addTeacher($name, $email) {
        $email = $this->sanitizeInput($email);
        if (!$this->validateEmail($email)) {
            echo "Invalid email\n";
            return false;
        }
        $this->logActivity("Teacher added: $name");
        echo "Teacher $name added successfully\n";
    }
}

class AdminController {
    // ❌ SAME CODE REPEATED AGAIN!
    public function validateEmail($email) {
        if (!filter_var($email, FILTER_VALIDATE_EMAIL)) {
            return false;
        }
        return true;
    }
    
    public function sanitizeInput($input) {
        return htmlspecialchars(trim($input));
    }
    
    public function logActivity($message) {
        echo date('Y-m-d H:i:s') . " - " . $message . "\n";
    }
    
    public function addAdmin($name, $email) {
        $email = $this->sanitizeInput($email);
        if (!$this->validateEmail($email)) {
            echo "Invalid email\n";
            return false;
        }
        $this->logActivity("Admin added: $name");
        echo "Admin $name added successfully\n";
    }
}
```

✅ **GOOD - Solve DRY problem:**
```php
// Base class with common functionality - GOOD!
class BaseController {
    // Common validation method
    protected function validateEmail($email) {
        if (!filter_var($email, FILTER_VALIDATE_EMAIL)) {
            return false;
        }
        return true;
    }
    
    // Common sanitization method  
    protected function sanitizeInput($input) {
        return htmlspecialchars(trim($input));
    }
    
    // Common logging method
    protected function logActivity($message) {
        echo date('Y-m-d H:i:s') . " - " . $message . "\n";
    }
    
    // Common process method that all controllers can use
    protected function processUser($name, $email, $userType) {
        // Sanitize input
        $email = $this->sanitizeInput($email);
        $name = $this->sanitizeInput($name);
        
        // Validate email
        if (!$this->validateEmail($email)) {
            echo "Invalid email for $userType\n";
            return false;
        }
        
        // Log activity
        $this->logActivity("$userType added: $name");
        
        // Success message
        echo "$userType $name added successfully\n";
        return true;
    }
}

// ✅ Child classes inherit all common functionality
class StudentController extends BaseController {
    public function addStudent($name, $email) {
        return $this->processUser($name, $email, "Student");
    }
    
    // Student-specific methods can be added here
    public function enrollInCourse($studentId, $courseId) {
        $this->logActivity("Student $studentId enrolled in course $courseId");
        echo "Student enrolled successfully\n";
    }
}

class TeacherController extends BaseController {
    public function addTeacher($name, $email) {
        return $this->processUser($name, $email, "Teacher");
    }
    
    // Teacher-specific methods can be added here
    public function assignToCourse($teacherId, $courseId) {
        $this->logActivity("Teacher $teacherId assigned to course $courseId");
        echo "Teacher assigned successfully\n";
    }
}

class AdminController extends BaseController {
    public function addAdmin($name, $email) {
        return $this->processUser($name, $email, "Admin");
    }
    
    // Admin-specific methods can be added here
    public function grantPermissions($adminId, $permissions) {
        $this->logActivity("Permissions granted to admin $adminId");
        echo "Permissions granted successfully\n";
    }
}

// Usage example:
$studentController = new StudentController();
$teacherController = new TeacherController();
$adminController = new AdminController();

$studentController->addStudent("John Doe", "john@example.com");
$teacherController->addTeacher("Jane Smith", "jane@example.com");
$adminController->addAdmin("Bob Wilson", "bob@example.com");

// All use the same inherited methods - NO REPETITION!
```

---

## 🎯 **COMPLETE DEMO SCRIPT:**

```php
<?php
echo "===============================================\n";
echo "         SOLID PRINCIPLES DEMO\n";
echo "===============================================\n\n";

// === S - Single Responsibility Demo ===
echo "1. SINGLE RESPONSIBILITY PRINCIPLE:\n";
echo "-------------------------------------\n";
$user = new User("John Doe", "john@example.com");
$validator = new UserValidator();
$repository = new UserRepository();
$emailService = new EmailService();

if ($validator->validateData($user)) {
    $repository->saveToDatabase($user);
    $emailService->sendWelcomeEmail($user);
}
echo "\n";

// === O - Open/Closed Demo ===
echo "2. OPEN/CLOSED PRINCIPLE:\n";
echo "-------------------------\n";
$shapes = [
    new Circle(5),
    new Rectangle(4, 6),
    new Triangle(8, 10),
    new Square(7)
];
$calculator = new AreaCalculator();
$calculator->getShapeDetails($shapes);
echo "Total Area: " . $calculator->getTotalArea($shapes) . "\n\n";

// === L - Liskov Substitution Demo ===
echo "3. LISKOV SUBSTITUTION PRINCIPLE:\n";
echo "---------------------------------\n";
$sparrow = new Sparrow("Tweety");
$eagle = new Eagle("Mighty");
$penguin = new Penguin("Pingu");

makeBirdFly($sparrow);
makeBirdFly($eagle);
handlePenguin($penguin);
echo "\n";

// === I - Interface Segregation Demo ===
echo "4. INTERFACE SEGREGATION PRINCIPLE:\n";
echo "-----------------------------------\n";
$textFile = new TextFile();
$textFile->write("Hello World from text file!");
echo "Content: " . $textFile->read() . "\n";

$script = new Script();
$script->read();
$script->execute();

$document = new Document();
$document->read();
$document->print();
echo "\n";

// === D - Dependency Inversion Demo ===
echo "5. DEPENDENCY INVERSION PRINCIPLE:\n";
echo "----------------------------------\n";
$mysqlService = new UserService(new MySQLDatabase());
$mongoService = new UserService(new MongoDatabase());
$postgresService = new UserService(new PostgreSQLDatabase());

$mysqlService->saveUser("MySQL User Data");
$mongoService->saveUser("MongoDB User Data");
$postgresService->saveUser("PostgreSQL User Data");
echo "\n";

// === DRY Principle Demo ===
echo "6. DRY PRINCIPLE:\n";
echo "----------------\n";
$studentController = new StudentController();
$teacherController = new TeacherController();
$adminController = new AdminController();

$studentController->addStudent("Alice Johnson", "alice@school.com");
$teacherController->addTeacher("Bob Smith", "bob@school.com");
$adminController->addAdmin("Carol Wilson", "carol@school.com");

echo "\n===============================================\n";
echo "         SOLID PRINCIPLES COMPLETED!\n";
echo "===============================================\n";
?>
```

## 🎯 **QUICK MEMORY TRICKS:**

**S** = **S**eparate responsibilities  
**O** = **O**pen for extension  
**L** = **L**iskov substitution works  
**I** = **I**nterfaces stay small  
**D** = **D**epend on contracts  

## 💡 **KEY BENEFITS:**

✅ **Maintainable**: Easy to modify and debug  
✅ **Testable**: Each piece can be tested independently  
✅ **Flexible**: Easy to add new features  
✅ **Reusable**: Components can be used in different contexts  
✅ **Scalable**: Code grows without becoming messy  

## 🔥 **WHEN TO USE:**

- **S**: When class is doing too many things
- **O**: When adding new features breaks existing code  
- **L**: When child classes don't work like parent
- **I**: When interface has too many methods
- **D**: When class depends on concrete implementations

**💡 Bottom Line:**  
SOLID + DRY = Clean Code = Happy Developer = Easy Maintenance = Successful Project!
