# PHP SOLID Design Patterns with I/O Operations - Complete Guide

## Overview of SOLID Principles

**SOLID** is an acronym for five design principles:
- **S** - Single Responsibility Principle (SRP)
- **O** - Open/Closed Principle (OCP)
- **L** - Liskov Substitution Principle (LSP)
- **I** - Interface Segregation Principle (ISP)
- **D** - Dependency Inversion Principle (DIP)

## 1. Single Responsibility Principle (SRP)

### Algorithm/Workflow:
1. Each class should have only ONE reason to change
2. Separate concerns into different classes
3. Each class handles ONE specific responsibility

### Simple Code Example:

```php
<?php
// ❌ BAD: Multiple responsibilities in one class
class BadUserManager {
    public function saveUser($userData) {
        // Validation logic
        if (empty($userData['name'])) {
            throw new Exception('Name is required');
        }
        
        // File I/O logic
        file_put_contents('users.txt', json_encode($userData) . "\n", FILE_APPEND);
        
        // Email logic
        mail($userData['email'], 'Welcome!', 'Thanks for joining!');
        
        // Logging logic
        error_log('User saved: ' . $userData['name']);
    }
}

// ✅ GOOD: Each class has single responsibility
class UserValidator {
    public function validate($userData) {
        if (empty($userData['name'])) {
            throw new Exception('Name is required');
        }
        if (empty($userData['email'])) {
            throw new Exception('Email is required');
        }
        return true;
    }
}

class FileWriter {
    public function writeUser($userData) {
        $data = json_encode($userData) . "\n";
        file_put_contents('users.txt', $data, FILE_APPEND);
    }
}

class EmailService {
    public function sendWelcomeEmail($email) {
        mail($email, 'Welcome!', 'Thanks for joining!');
    }
}

class Logger {
    public function log($message) {
        error_log(date('Y-m-d H:i:s') . ' - ' . $message);
    }
}

// Usage
class UserManager {
    private $validator;
    private $fileWriter;
    private $emailService;
    private $logger;
    
    public function __construct() {
        $this->validator = new UserValidator();
        $this->fileWriter = new FileWriter();
        $this->emailService = new EmailService();
        $this->logger = new Logger();
    }
    
    public function saveUser($userData) {
        $this->validator->validate($userData);
        $this->fileWriter->writeUser($userData);
        $this->emailService->sendWelcomeEmail($userData['email']);
        $this->logger->log('User saved: ' . $userData['name']);
    }
}
```

### When to Use:
- When a class is doing too many things
- When changes to one feature require modifying the same class
- When testing becomes difficult due to multiple dependencies

### Real-life Example:
Think of a restaurant: The chef cooks, the waiter serves, the cashier handles payments. Each person has ONE job, not all jobs.

---

## 2. Open/Closed Principle (OCP)

### Algorithm/Workflow:
1. Classes should be open for extension but closed for modification
2. Use interfaces and inheritance
3. Add new features without changing existing code

### Simple Code Example:

```php
<?php
// ✅ GOOD: Open for extension, closed for modification
interface FileReaderInterface {
    public function read($filename);
}

class TextFileReader implements FileReaderInterface {
    public function read($filename) {
        return file_get_contents($filename);
    }
}

class CSVFileReader implements FileReaderInterface {
    public function read($filename) {
        $data = [];
        $handle = fopen($filename, 'r');
        while (($row = fgetcsv($handle)) !== FALSE) {
            $data[] = $row;
        }
        fclose($handle);
        return $data;
    }
}

class JSONFileReader implements FileReaderInterface {
    public function read($filename) {
        $content = file_get_contents($filename);
        return json_decode($content, true);
    }
}

class FileProcessor {
    private $reader;
    
    public function __construct(FileReaderInterface $reader) {
        $this->reader = $reader;
    }
    
    public function processFile($filename) {
        $data = $this->reader->read($filename);
        // Process the data...
        return "Processed: " . count($data) . " items";
    }
}

// Usage - Adding new file types without modifying existing code
$textProcessor = new FileProcessor(new TextFileReader());
$csvProcessor = new FileProcessor(new CSVFileReader());
$jsonProcessor = new FileProcessor(new JSONFileReader());

// Add XML support without changing existing classes
class XMLFileReader implements FileReaderInterface {
    public function read($filename) {
        return simplexml_load_file($filename);
    }
}

$xmlProcessor = new FileProcessor(new XMLFileReader());
```

### When to Use:
- When you need to add new features frequently
- When modifying existing code might break other functionality
- When you want to support multiple formats or behaviors

### Real-life Example:
Like a power outlet - you can plug in different devices (extension) without rewiring the house (modification).

---

## 3. Liskov Substitution Principle (LSP)

### Algorithm/Workflow:
1. Child classes must be substitutable for their parent classes
2. Derived classes should not change the expected behavior
3. Method signatures and return types should remain compatible

### Simple Code Example:

```php
<?php
// ✅ GOOD: Proper substitution
interface StorageInterface {
    public function store($data);
    public function retrieve($key);
}

class FileStorage implements StorageInterface {
    public function store($data) {
        $key = uniqid();
        file_put_contents("storage/{$key}.txt", serialize($data));
        return $key;
    }
    
    public function retrieve($key) {
        $filename = "storage/{$key}.txt";
        if (file_exists($filename)) {
            return unserialize(file_get_contents($filename));
        }
        return null;
    }
}

class DatabaseStorage implements StorageInterface {
    private $pdo;
    
    public function __construct($pdo) {
        $this->pdo = $pdo;
    }
    
    public function store($data) {
        $key = uniqid();
        $stmt = $this->pdo->prepare("INSERT INTO storage (key_name, data) VALUES (?, ?)");
        $stmt->execute([$key, serialize($data)]);
        return $key;
    }
    
    public function retrieve($key) {
        $stmt = $this->pdo->prepare("SELECT data FROM storage WHERE key_name = ?");
        $stmt->execute([$key]);
        $result = $stmt->fetch();
        return $result ? unserialize($result['data']) : null;
    }
}

class DataManager {
    private $storage;
    
    public function __construct(StorageInterface $storage) {
        $this->storage = $storage;
    }
    
    public function saveData($data) {
        return $this->storage->store($data);
    }
    
    public function loadData($key) {
        return $this->storage->retrieve($key);
    }
}

// Both storage types work the same way
$fileManager = new DataManager(new FileStorage());
$dbManager = new DataManager(new DatabaseStorage($pdo));

// Both can be used interchangeably
$key1 = $fileManager->saveData(['name' => 'John']);
$key2 = $dbManager->saveData(['name' => 'Jane']);
```

### When to Use:
- When creating inheritance hierarchies
- When you want to swap implementations seamlessly
- When building plugin or driver systems

### Real-life Example:
Like different brands of batteries - all AA batteries should work in any AA device, regardless of the manufacturer.

---

## 4. Interface Segregation Principle (ISP)

### Algorithm/Workflow:
1. Create small, specific interfaces instead of large, general ones
2. Classes should not depend on methods they don't use
3. Split large interfaces into smaller, focused ones

### Simple Code Example:

```php
<?php
// ❌ BAD: Fat interface
interface BadFileOperationsInterface {
    public function read($filename);
    public function write($filename, $data);
    public function compress($filename);
    public function encrypt($filename);
    public function backup($filename);
    public function delete($filename);
}

// ✅ GOOD: Segregated interfaces
interface ReadableInterface {
    public function read($filename);
}

interface WritableInterface {
    public function write($filename, $data);
}

interface CompressibleInterface {
    public function compress($filename);
}

interface EncryptableInterface {
    public function encrypt($filename);
}

// Simple text file handler - only needs read/write
class SimpleTextFile implements ReadableInterface, WritableInterface {
    public function read($filename) {
        return file_get_contents($filename);
    }
    
    public function write($filename, $data) {
        file_put_contents($filename, $data);
    }
}

// Secure file handler - needs read/write/encrypt
class SecureFile implements ReadableInterface, WritableInterface, EncryptableInterface {
    public function read($filename) {
        $content = file_get_contents($filename);
        return $this->decrypt($content);
    }
    
    public function write($filename, $data) {
        $encryptedData = $this->encrypt($data);
        file_put_contents($filename, $encryptedData);
    }
    
    public function encrypt($data) {
        return base64_encode($data); // Simple encryption for demo
    }
    
    private function decrypt($data) {
        return base64_decode($data);
    }
}

// Archive file - needs read/write/compress
class ArchiveFile implements ReadableInterface, WritableInterface, CompressibleInterface {
    public function read($filename) {
        $content = file_get_contents($filename);
        return gzuncompress($content);
    }
    
    public function write($filename, $data) {
        $compressedData = gzcompress($data);
        file_put_contents($filename, $compressedData);
    }
    
    public function compress($filename) {
        $data = file_get_contents($filename);
        $compressed = gzcompress($data);
        file_put_contents($filename, $compressed);
    }
}

// Usage
class FileProcessor {
    public function processReadableFile(ReadableInterface $file, $filename) {
        return $file->read($filename);
    }
    
    public function processWritableFile(WritableInterface $file, $filename, $data) {
        $file->write($filename, $data);
    }
}
```

### When to Use:
- When interfaces become too large
- When classes implement empty methods they don't need
- When you want flexible, focused contracts

### Real-life Example:
Like a Swiss Army knife vs. specialized tools - sometimes you need just a screwdriver, not a whole toolkit.

---

## 5. Dependency Inversion Principle (DIP)

### Algorithm/Workflow:
1. High-level modules should not depend on low-level modules
2. Both should depend on abstractions (interfaces)
3. Details should depend on abstractions, not the other way around

### Simple Code Example:

```php
<?php
// ❌ BAD: High-level class depends on low-level class
class BadReportGenerator {
    public function generateReport($data) {
        // Directly dependent on file system
        $report = "Report:\n" . print_r($data, true);
        file_put_contents('report.txt', $report);
        return 'report.txt';
    }
}

// ✅ GOOD: Depend on abstractions
interface OutputInterface {
    public function save($content, $identifier);
}

interface LoggerInterface {
    public function log($message);
}

class FileOutput implements OutputInterface {
    public function save($content, $identifier) {
        file_put_contents($identifier . '.txt', $content);
        return $identifier . '.txt';
    }
}

class DatabaseOutput implements OutputInterface {
    private $pdo;
    
    public function __construct($pdo) {
        $this->pdo = $pdo;
    }
    
    public function save($content, $identifier) {
        $stmt = $this->pdo->prepare("INSERT INTO reports (name, content) VALUES (?, ?)");
        $stmt->execute([$identifier, $content]);
        return $identifier;
    }
}

class EmailOutput implements OutputInterface {
    private $emailAddress;
    
    public function __construct($emailAddress) {
        $this->emailAddress = $emailAddress;
    }
    
    public function save($content, $identifier) {
        mail($this->emailAddress, "Report: {$identifier}", $content);
        return "Sent to: {$this->emailAddress}";
    }
}

class FileLogger implements LoggerInterface {
    public function log($message) {
        file_put_contents('app.log', date('Y-m-d H:i:s') . " - {$message}\n", FILE_APPEND);
    }
}

class ReportGenerator {
    private $output;
    private $logger;
    
    public function __construct(OutputInterface $output, LoggerInterface $logger) {
        $this->output = $output;
        $this->logger = $logger;
    }
    
    public function generateReport($data, $reportName) {
        $this->logger->log("Generating report: {$reportName}");
        
        $report = "Report: {$reportName}\n";
        $report .= "Generated: " . date('Y-m-d H:i:s') . "\n";
        $report .= "Data:\n" . print_r($data, true);
        
        $result = $this->output->save($report, $reportName);
        
        $this->logger->log("Report saved: {$result}");
        
        return $result;
    }
}

// Usage - Easy to swap implementations
$fileOutput = new FileOutput();
$dbOutput = new DatabaseOutput($pdo);
$emailOutput = new EmailOutput('admin@example.com');
$logger = new FileLogger();

$fileReporter = new ReportGenerator($fileOutput, $logger);
$dbReporter = new ReportGenerator($dbOutput, $logger);
$emailReporter = new ReportGenerator($emailOutput, $logger);

// All work the same way
$data = ['users' => 150, 'orders' => 75];
$fileReporter->generateReport($data, 'monthly_stats');
$dbReporter->generateReport($data, 'monthly_stats');
$emailReporter->generateReport($data, 'monthly_stats');
```

### When to Use:
- When you want to easily swap implementations
- When you need to test classes in isolation
- When you want to reduce tight coupling between components

### Real-life Example:
Like a universal charger port (USB-C) - your phone doesn't care what brand of charger you use, as long as it fits the standard interface.

---

## Complete Example: File Processing System

Here's a comprehensive example that combines all SOLID principles:

```php
<?php
// Interfaces (ISP & DIP)
interface FileReaderInterface {
    public function read($filename);
}

interface FileProcessorInterface {
    public function process($data);
}

interface OutputInterface {
    public function output($data, $destination);
}

interface LoggerInterface {
    public function log($message);
}

// Single Responsibility Classes (SRP)
class CSVReader implements FileReaderInterface {
    public function read($filename) {
        $data = [];
        if (($handle = fopen($filename, "r")) !== FALSE) {
            while (($row = fgetcsv($handle, 1000, ",")) !== FALSE) {
                $data[] = $row;
            }
            fclose($handle);
        }
        return $data;
    }
}

class JSONReader implements FileReaderInterface {
    public function read($filename) {
        $content = file_get_contents($filename);
        return json_decode($content, true);
    }
}

class DataProcessor implements FileProcessorInterface {
    public function process($data) {
        // Simple processing - count records and add timestamp
        return [
            'processed_at' => date('Y-m-d H:i:s'),
            'total_records' => count($data),
            'data' => $data
        ];
    }
}

class FileOutput implements OutputInterface {
    public function output($data, $destination) {
        file_put_contents($destination, json_encode($data, JSON_PRETTY_PRINT));
        return "Saved to: {$destination}";
    }
}

class ConsoleOutput implements OutputInterface {
    public function output($data, $destination) {
        echo "Results:\n";
        echo json_encode($data, JSON_PRETTY_PRINT);
        return "Displayed on console";
    }
}

class SimpleLogger implements LoggerInterface {
    public function log($message) {
        echo "[" . date('Y-m-d H:i:s') . "] {$message}\n";
    }
}

// Main orchestrator class (DIP)
class FileProcessingService {
    private $reader;
    private $processor;
    private $output;
    private $logger;
    
    public function __construct(
        FileReaderInterface $reader,
        FileProcessorInterface $processor,
        OutputInterface $output,
        LoggerInterface $logger
    ) {
        $this->reader = $reader;
        $this->processor = $processor;
        $this->output = $output;
        $this->logger = $logger;
    }
    
    public function processFile($inputFile, $outputDestination) {
        $this->logger->log("Starting file processing: {$inputFile}");
        
        try {
            // Read file
            $data = $this->reader->read($inputFile);
            $this->logger->log("File read successfully. Records: " . count($data));
            
            // Process data
            $processedData = $this->processor->process($data);
            $this->logger->log("Data processed successfully");
            
            // Output results
            $result = $this->output->output($processedData, $outputDestination);
            $this->logger->log("Output completed: {$result}");
            
            return $result;
            
        } catch (Exception $e) {
            $this->logger->log("Error: " . $e->getMessage());
            throw $e;
        }
    }
}

// Usage examples
$logger = new SimpleLogger();

// Process CSV file and save as JSON
$csvService = new FileProcessingService(
    new CSVReader(),
    new DataProcessor(),
    new FileOutput(),
    $logger
);

// Process JSON file and display on console
$jsonService = new FileProcessingService(
    new JSONReader(),
    new DataProcessor(),
    new ConsoleOutput(),
    $logger
);

// Easy to extend with new readers/outputs (OCP)
// Easy to substitute components (LSP)
// Each class has single responsibility (SRP)
// Small, focused interfaces (ISP)
// Depends on abstractions, not concretions (DIP)

// $csvService->processFile('data.csv', 'processed_data.json');
// $jsonService->processFile('data.json', '');
?>
```

## Summary

### When to Use Each Principle:

1. **SRP**: When classes become too complex or handle multiple concerns
2. **OCP**: When you frequently need to add new features or support new formats
3. **LSP**: When building inheritance hierarchies or swappable components
4. **ISP**: When interfaces become too large or classes implement unused methods
5. **DIP**: When you need flexible, testable, and maintainable code

### Benefits:
- **Maintainable**: Easy to modify and extend
- **Testable**: Components can be tested in isolation
- **Flexible**: Easy to swap implementations
- **Reusable**: Components can be used in different contexts
- **Scalable**: New features can be added without breaking existing code

### Real-world Applications:
- **E-commerce systems**: Different payment methods, shipping providers
- **Content management**: Multiple file formats, storage options
- **API integrations**: Various third-party services
- **Reporting systems**: Different output formats, data sources
- **Authentication systems**: Multiple providers (Google, Facebook, etc.)

The key is to start simple and apply these principles as your code grows and becomes more complex!
