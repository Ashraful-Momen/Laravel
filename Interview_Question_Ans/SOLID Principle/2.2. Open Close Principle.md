# Open/Closed Principle (OCP) - Complete Guide

## Definition

> **"Software entities (classes, modules, functions, etc.) should be open for extension but closed for modification."**

- **Open for Extension**: You can add new functionality
- **Closed for Modification**: You don't change existing code

## Core Concept

The OCP is about designing your code so that when requirements change, you add new code rather than modifying existing, working code. This reduces the risk of introducing bugs into tested functionality.

## Why OCP Matters

### Problems Without OCP:
- **Fragile Code**: Changes break existing functionality
- **Regression Bugs**: Fixing one thing breaks another
- **Testing Overhead**: Need to retest everything when anything changes
- **Maintenance Nightmare**: Fear of touching working code

### Benefits With OCP:
- **Stable Foundation**: Existing code remains untouched
- **Risk Reduction**: New features can't break old ones
- **Easy Testing**: Only test new extensions
- **Confidence**: Developers aren't afraid to add features

## Algorithm/Workflow for Implementing OCP

```
1. Identify what might change in the future
2. Create abstractions (interfaces/abstract classes) for those areas
3. Implement current functionality using these abstractions
4. When new requirements come, create new implementations
5. Plug in new implementations without touching existing code
```

## Basic Example: Shape Calculator

### ❌ BAD: Violating OCP

```php
<?php
class Rectangle {
    public $width;
    public $height;
    
    public function __construct($width, $height) {
        $this->width = $width;
        $this->height = $height;
    }
}

class Circle {
    public $radius;
    
    public function __construct($radius) {
        $this->radius = $radius;
    }
}

// This class violates OCP
class BadAreaCalculator {
    public function calculateTotalArea($shapes) {
        $totalArea = 0;
        
        foreach ($shapes as $shape) {
            if ($shape instanceof Rectangle) {
                $totalArea += $shape->width * $shape->height;
            } elseif ($shape instanceof Circle) {
                $totalArea += pi() * $shape->radius * $shape->radius;
            }
            // Problem: Need to modify this class for every new shape type!
        }
        
        return $totalArea;
    }
}

// Adding Triangle requires modifying BadAreaCalculator
class Triangle {
    public $base;
    public $height;
    
    public function __construct($base, $height) {
        $this->base = $base;
        $this->height = $height;
    }
}

// Now we need to modify BadAreaCalculator:
// elseif ($shape instanceof Triangle) {
//     $totalArea += 0.5 * $shape->base * $shape->height;
// }
```

### ✅ GOOD: Following OCP

```php
<?php
// Abstraction - the key to OCP
interface Shape {
    public function calculateArea();
}

// Implementations - closed for modification
class Rectangle implements Shape {
    private $width;
    private $height;
    
    public function __construct($width, $height) {
        $this->width = $width;
        $this->height = $height;
    }
    
    public function calculateArea() {
        return $this->width * $this->height;
    }
}

class Circle implements Shape {
    private $radius;
    
    public function __construct($radius) {
        $this->radius = $radius;
    }
    
    public function calculateArea() {
        return pi() * $this->radius * $this->radius;
    }
}

// This class is now closed for modification
class GoodAreaCalculator {
    public function calculateTotalArea($shapes) {
        $totalArea = 0;
        
        foreach ($shapes as $shape) {
            $totalArea += $shape->calculateArea();
        }
        
        return $totalArea;
    }
}

// Adding new shapes - EXTENSION without MODIFICATION
class Triangle implements Shape {
    private $base;
    private $height;
    
    public function __construct($base, $height) {
        $this->base = $base;
        $this->height = $height;
    }
    
    public function calculateArea() {
        return 0.5 * $this->base * $this->height;
    }
}

class Pentagon implements Shape {
    private $side;
    
    public function __construct($side) {
        $this->side = $side;
    }
    
    public function calculateArea() {
        return (1.720477 * $this->side * $this->side);
    }
}

// Usage - No changes needed to existing code!
$calculator = new GoodAreaCalculator();
$shapes = [
    new Rectangle(5, 10),
    new Circle(7),
    new Triangle(6, 8),
    new Pentagon(4)
];

echo "Total Area: " . $calculator->calculateTotalArea($shapes);
```

## Advanced Example: File Processing System

### ❌ BAD: Violating OCP

```php
<?php
class BadFileProcessor {
    public function process($filename) {
        $extension = pathinfo($filename, PATHINFO_EXTENSION);
        $content = file_get_contents($filename);
        
        if ($extension === 'txt') {
            return $this->processTxtFile($content);
        } elseif ($extension === 'csv') {
            return $this->processCsvFile($content);
        } elseif ($extension === 'json') {
            return $this->processJsonFile($content);
        }
        // Problem: Need to modify this method for every new file type!
        
        throw new Exception("Unsupported file type: $extension");
    }
    
    private function processTxtFile($content) {
        return ['type' => 'text', 'lines' => explode("\n", $content)];
    }
    
    private function processCsvFile($content) {
        $lines = explode("\n", $content);
        $data = [];
        foreach ($lines as $line) {
            $data[] = str_getcsv($line);
        }
        return ['type' => 'csv', 'data' => $data];
    }
    
    private function processJsonFile($content) {
        return ['type' => 'json', 'data' => json_decode($content, true)];
    }
}
```

### ✅ GOOD: Following OCP

```php
<?php
// Abstraction for file processing
interface FileProcessorInterface {
    public function canProcess($filename);
    public function process($filename);
}

// Base implementation
abstract class AbstractFileProcessor implements FileProcessorInterface {
    protected $supportedExtensions = [];
    
    public function canProcess($filename) {
        $extension = strtolower(pathinfo($filename, PATHINFO_EXTENSION));
        return in_array($extension, $this->supportedExtensions);
    }
    
    abstract public function process($filename);
}

// Specific processors - each closed for modification
class TextFileProcessor extends AbstractFileProcessor {
    protected $supportedExtensions = ['txt', 'text'];
    
    public function process($filename) {
        $content = file_get_contents($filename);
        return [
            'type' => 'text',
            'lines' => explode("\n", $content),
            'word_count' => str_word_count($content),
            'char_count' => strlen($content)
        ];
    }
}

class CsvFileProcessor extends AbstractFileProcessor {
    protected $supportedExtensions = ['csv'];
    
    public function process($filename) {
        $data = [];
        if (($handle = fopen($filename, "r")) !== FALSE) {
            while (($row = fgetcsv($handle)) !== FALSE) {
                $data[] = $row;
            }
            fclose($handle);
        }
        
        return [
            'type' => 'csv',
            'data' => $data,
            'rows' => count($data),
            'columns' => count($data[0] ?? [])
        ];
    }
}

class JsonFileProcessor extends AbstractFileProcessor {
    protected $supportedExtensions = ['json'];
    
    public function process($filename) {
        $content = file_get_contents($filename);
        $data = json_decode($content, true);
        
        return [
            'type' => 'json',
            'data' => $data,
            'valid_json' => json_last_error() === JSON_ERROR_NONE,
            'size' => strlen($content)
        ];
    }
}

// Main processor - closed for modification
class FileProcessingService {
    private $processors = [];
    
    public function addProcessor(FileProcessorInterface $processor) {
        $this->processors[] = $processor;
    }
    
    public function process($filename) {
        foreach ($this->processors as $processor) {
            if ($processor->canProcess($filename)) {
                return $processor->process($filename);
            }
        }
        
        throw new Exception("No processor found for file: $filename");
    }
}

// Adding new file types - EXTENSION without MODIFICATION
class XmlFileProcessor extends AbstractFileProcessor {
    protected $supportedExtensions = ['xml'];
    
    public function process($filename) {
        $content = file_get_contents($filename);
        $xml = simplexml_load_string($content);
        
        return [
            'type' => 'xml',
            'data' => json_decode(json_encode($xml), true),
            'valid_xml' => $xml !== false,
            'root_element' => $xml ? $xml->getName() : null
        ];
    }
}

class PdfFileProcessor extends AbstractFileProcessor {
    protected $supportedExtensions = ['pdf'];
    
    public function process($filename) {
        // Simulated PDF processing
        $size = filesize($filename);
        
        return [
            'type' => 'pdf',
            'file_size' => $size,
            'pages' => rand(1, 100), // Simulated page count
            'encrypted' => false // Simulated
        ];
    }
}

// Usage - No changes to existing code!
$service = new FileProcessingService();
$service->addProcessor(new TextFileProcessor());
$service->addProcessor(new CsvFileProcessor());
$service->addProcessor(new JsonFileProcessor());

// Add new processors without modifying existing code
$service->addProcessor(new XmlFileProcessor());
$service->addProcessor(new PdfFileProcessor());

// Process different file types
$files = ['data.txt', 'data.csv', 'data.json', 'data.xml', 'document.pdf'];
foreach ($files as $file) {
    try {
        $result = $service->process($file);
        echo "Processed $file: " . json_encode($result, JSON_PRETTY_PRINT) . "\n";
    } catch (Exception $e) {
        echo "Error processing $file: " . $e->getMessage() . "\n";
    }
}
```

## Real-World Example: Payment Processing System

```php
<?php
// Payment abstraction
interface PaymentProcessorInterface {
    public function supports($paymentMethod);
    public function processPayment($amount, $paymentData);
    public function refund($transactionId, $amount);
}

// Base payment processor
abstract class BasePaymentProcessor implements PaymentProcessorInterface {
    protected $supportedMethods = [];
    
    public function supports($paymentMethod) {
        return in_array(strtolower($paymentMethod), $this->supportedMethods);
    }
    
    protected function logTransaction($type, $amount, $details = []) {
        $log = [
            'timestamp' => date('Y-m-d H:i:s'),
            'type' => $type,
            'amount' => $amount,
            'processor' => get_class($this),
            'details' => $details
        ];
        
        file_put_contents('transactions.log', json_encode($log) . "\n", FILE_APPEND);
    }
}

// Existing payment processors
class CreditCardProcessor extends BasePaymentProcessor {
    protected $supportedMethods = ['visa', 'mastercard', 'amex'];
    
    public function processPayment($amount, $paymentData) {
        // Validate credit card
        if (!$this->validateCard($paymentData)) {
            throw new Exception('Invalid credit card data');
        }
        
        // Process payment with card gateway
        $transactionId = 'cc_' . uniqid();
        
        $this->logTransaction('payment', $amount, [
            'card_last_four' => substr($paymentData['card_number'], -4),
            'transaction_id' => $transactionId
        ]);
        
        return [
            'success' => true,
            'transaction_id' => $transactionId,
            'amount' => $amount,
            'processor' => 'credit_card'
        ];
    }
    
    public function refund($transactionId, $amount) {
        $this->logTransaction('refund', $amount, [
            'original_transaction' => $transactionId
        ]);
        
        return [
            'success' => true,
            'refund_id' => 'rf_' . uniqid(),
            'amount' => $amount
        ];
    }
    
    private function validateCard($data) {
        return isset($data['card_number']) && 
               isset($data['cvv']) && 
               isset($data['expiry']);
    }
}

class PayPalProcessor extends BasePaymentProcessor {
    protected $supportedMethods = ['paypal'];
    
    public function processPayment($amount, $paymentData) {
        if (!isset($paymentData['paypal_email'])) {
            throw new Exception('PayPal email required');
        }
        
        $transactionId = 'pp_' . uniqid();
        
        $this->logTransaction('payment', $amount, [
            'paypal_email' => $paymentData['paypal_email'],
            'transaction_id' => $transactionId
        ]);
        
        return [
            'success' => true,
            'transaction_id' => $transactionId,
            'amount' => $amount,
            'processor' => 'paypal'
        ];
    }
    
    public function refund($transactionId, $amount) {
        $this->logTransaction('refund', $amount, [
            'original_transaction' => $transactionId
        ]);
        
        return [
            'success' => true,
            'refund_id' => 'pprf_' . uniqid(),
            'amount' => $amount
        ];
    }
}

// Main payment service - closed for modification
class PaymentService {
    private $processors = [];
    
    public function addProcessor(PaymentProcessorInterface $processor) {
        $this->processors[] = $processor;
    }
    
    public function processPayment($amount, $paymentMethod, $paymentData) {
        foreach ($this->processors as $processor) {
            if ($processor->supports($paymentMethod)) {
                return $processor->processPayment($amount, $paymentData);
            }
        }
        
        throw new Exception("Payment method '$paymentMethod' not supported");
    }
    
    public function refund($transactionId, $amount) {
        // Find processor based on transaction ID prefix
        foreach ($this->processors as $processor) {
            try {
                return $processor->refund($transactionId, $amount);
            } catch (Exception $e) {
                continue;
            }
        }
        
        throw new Exception("Could not process refund for transaction: $transactionId");
    }
}

// EXTENSION: Adding new payment methods without modifying existing code
class BankTransferProcessor extends BasePaymentProcessor {
    protected $supportedMethods = ['bank_transfer', 'ach'];
    
    public function processPayment($amount, $paymentData) {
        if (!isset($paymentData['account_number']) || !isset($paymentData['routing_number'])) {
            throw new Exception('Bank account details required');
        }
        
        $transactionId = 'bt_' . uniqid();
        
        $this->logTransaction('payment', $amount, [
            'account_last_four' => substr($paymentData['account_number'], -4),
            'routing_number' => $paymentData['routing_number'],
            'transaction_id' => $transactionId
        ]);
        
        return [
            'success' => true,
            'transaction_id' => $transactionId,
            'amount' => $amount,
            'processor' => 'bank_transfer',
            'processing_time' => '1-3 business days'
        ];
    }
    
    public function refund($transactionId, $amount) {
        $this->logTransaction('refund', $amount, [
            'original_transaction' => $transactionId
        ]);
        
        return [
            'success' => true,
            'refund_id' => 'btrf_' . uniqid(),
            'amount' => $amount,
            'processing_time' => '3-5 business days'
        ];
    }
}

class CryptocurrencyProcessor extends BasePaymentProcessor {
    protected $supportedMethods = ['bitcoin', 'ethereum', 'litecoin'];
    
    public function processPayment($amount, $paymentData) {
        if (!isset($paymentData['wallet_address']) || !isset($paymentData['crypto_type'])) {
            throw new Exception('Cryptocurrency wallet details required');
        }
        
        $transactionId = 'crypto_' . uniqid();
        
        $this->logTransaction('payment', $amount, [
            'crypto_type' => $paymentData['crypto_type'],
            'wallet_address' => $paymentData['wallet_address'],
            'transaction_id' => $transactionId
        ]);
        
        return [
            'success' => true,
            'transaction_id' => $transactionId,
            'amount' => $amount,
            'processor' => 'cryptocurrency',
            'crypto_type' => $paymentData['crypto_type'],
            'confirmations_required' => 6
        ];
    }
    
    public function refund($transactionId, $amount) {
        // Crypto refunds might work differently
        throw new Exception('Cryptocurrency refunds must be processed manually');
    }
}

// Usage - Setting up the payment system
$paymentService = new PaymentService();

// Add existing processors
$paymentService->addProcessor(new CreditCardProcessor());
$paymentService->addProcessor(new PayPalProcessor());

// Add new processors - NO MODIFICATION to existing code!
$paymentService->addProcessor(new BankTransferProcessor());
$paymentService->addProcessor(new CryptocurrencyProcessor());

// Process different types of payments
try {
    // Credit card payment
    $result1 = $paymentService->processPayment(100.00, 'visa', [
        'card_number' => '4111111111111111',
        'cvv' => '123',
        'expiry' => '12/25'
    ]);
    echo "Credit Card: " . json_encode($result1, JSON_PRETTY_PRINT) . "\n";
    
    // PayPal payment
    $result2 = $paymentService->processPayment(50.00, 'paypal', [
        'paypal_email' => 'user@example.com'
    ]);
    echo "PayPal: " . json_encode($result2, JSON_PRETTY_PRINT) . "\n";
    
    // Bank transfer payment (new!)
    $result3 = $paymentService->processPayment(200.00, 'bank_transfer', [
        'account_number' => '123456789',
        'routing_number' => '987654321'
    ]);
    echo "Bank Transfer: " . json_encode($result3, JSON_PRETTY_PRINT) . "\n";
    
    // Cryptocurrency payment (new!)
    $result4 = $paymentService->processPayment(75.00, 'bitcoin', [
        'wallet_address' => '1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa',
        'crypto_type' => 'bitcoin'
    ]);
    echo "Cryptocurrency: " . json_encode($result4, JSON_PRETTY_PRINT) . "\n";
    
} catch (Exception $e) {
    echo "Payment error: " . $e->getMessage() . "\n";
}
```

## OCP Implementation Strategies

### 1. Strategy Pattern + OCP

```php
<?php
interface DiscountStrategy {
    public function calculateDiscount($amount, $customer);
}

class RegularCustomerDiscount implements DiscountStrategy {
    public function calculateDiscount($amount, $customer) {
        return $amount * 0.05; // 5% discount
    }
}

class PremiumCustomerDiscount implements DiscountStrategy {
    public function calculateDiscount($amount, $customer) {
        return $amount * 0.15; // 15% discount
    }
}

class VIPCustomerDiscount implements DiscountStrategy {
    public function calculateDiscount($amount, $customer) {
        return $amount * 0.25; // 25% discount
    }
}

// Easy to add new discount types without modifying existing code
class SeasonalDiscount implements DiscountStrategy {
    public function calculateDiscount($amount, $customer) {
        $currentMonth = date('n');
        $discountRate = in_array($currentMonth, [11, 12]) ? 0.20 : 0.10;
        return $amount * $discountRate;
    }
}

class PricingService {
    private $strategies = [];
    
    public function addStrategy($customerType, DiscountStrategy $strategy) {
        $this->strategies[$customerType] = $strategy;
    }
    
    public function calculateFinalPrice($amount, $customerType, $customer) {
        if (isset($this->strategies[$customerType])) {
            $discount = $this->strategies[$customerType]->calculateDiscount($amount, $customer);
            return $amount - $discount;
        }
        
        return $amount;
    }
}
```

### 2. Factory Pattern + OCP

```php
<?php
interface LoggerInterface {
    public function log($message, $level);
}

class FileLogger implements LoggerInterface {
    private $filename;
    
    public function __construct($filename) {
        $this->filename = $filename;
    }
    
    public function log($message, $level) {
        $timestamp = date('Y-m-d H:i:s');
        $logEntry = "[$timestamp] [$level] $message\n";
        file_put_contents($this->filename, $logEntry, FILE_APPEND);
    }
}

class DatabaseLogger implements LoggerInterface {
    private $pdo;
    
    public function __construct($pdo) {
        $this->pdo = $pdo;
    }
    
    public function log($message, $level) {
        $stmt = $this->pdo->prepare("INSERT INTO logs (message, level, created_at) VALUES (?, ?, ?)");
        $stmt->execute([$message, $level, date('Y-m-d H:i:s')]);
    }
}

// Factory that's open for extension
class LoggerFactory {
    private static $creators = [];
    
    public static function registerCreator($type, callable $creator) {
        self::$creators[$type] = $creator;
    }
    
    public static function create($type, ...$args) {
        if (!isset(self::$creators[$type])) {
            throw new Exception("Logger type '$type' not registered");
        }
        
        return call_user_func(self::$creators[$type], ...$args);
    }
}

// Register existing loggers
LoggerFactory::registerCreator('file', function($filename) {
    return new FileLogger($filename);
});

LoggerFactory::registerCreator('database', function($pdo) {
    return new DatabaseLogger($pdo);
});

// Add new logger types without modifying factory
class EmailLogger implements LoggerInterface {
    private $emailAddress;
    
    public function __construct($emailAddress) {
        $this->emailAddress = $emailAddress;
    }
    
    public function log($message, $level) {
        if ($level === 'ERROR' || $level === 'CRITICAL') {
            mail($this->emailAddress, "Log Alert: $level", $message);
        }
    }
}

// Register new logger - EXTENSION without MODIFICATION
LoggerFactory::registerCreator('email', function($emailAddress) {
    return new EmailLogger($emailAddress);
});

// Usage
$fileLogger = LoggerFactory::create('file', 'app.log');
$emailLogger = LoggerFactory::create('email', 'admin@example.com');
```

## When to Use OCP

### ✅ Use OCP When:

1. **Frequent Feature Additions**: New requirements come regularly
2. **Multiple Variations**: Different ways to do the same thing
3. **Plugin Architecture**: Need to support third-party extensions
4. **Configuration-Driven Behavior**: Behavior changes based on settings
5. **Testing Different Implementations**: Need to swap implementations
6. **Legacy Code Protection**: Can't risk breaking existing functionality

### ❌ Don't Overuse OCP When:

1. **Requirements Are Stable**: Unlikely to change
2. **Simple, One-Off Solutions**: Won't need extensions
3. **Performance Critical**: Abstractions add overhead
4. **Over-Engineering**: Making simple things complex

## Common Pitfalls and Solutions

### Pitfall 1: Premature Abstraction

```php
// ❌ Over-engineering for simple case
interface StringFormatter {
    public function format($string);
}

class UppercaseFormatter implements StringFormatter {
    public function format($string) {
        return strtoupper($string);
    }
}

// ✅ Simple solution for simple problem
function formatString($string) {
    return strtoupper($string);
}
```

### Pitfall 2: Wrong Abstraction Level

```php
// ❌ Too specific abstraction
interface PdfReportGenerator {
    public function generatePdf($data);
}

// ✅ Better abstraction
interface ReportGenerator {
    public function generate($data, $format);
}
```

### Pitfall 3: Missing Extension Points

```php
// ❌ Hard to extend
class OrderProcessor {
    public function processOrder($order) {
        $this->validateOrder($order);
        $this->calculateTotals($order);
        $this->saveOrder($order);
        $this->sendConfirmationEmail($order);
        // What if we need SMS notifications? Need to modify this method!
    }
}

// ✅ Extension points
interface OrderProcessorInterface {
    public function processOrder($order);
}

interface NotificationInterface {
    public function send($order);
}

class OrderProcessor implements OrderProcessorInterface {
    private $notifications = [];
    
    public function addNotification(NotificationInterface $notification) {
        $this->notifications[] = $notification;
    }
    
    public function processOrder($order) {
        $this->validateOrder($order);
        $this->calculateTotals($order);
        $this->saveOrder($order);
        
        foreach ($this->notifications as $notification) {
            $notification->send($order);
        }
    }
}
```

## Real-World Applications

### 1. E-commerce Systems
- Payment methods (credit card, PayPal, cryptocurrency)
- Shipping providers (FedEx, UPS, DHL)
- Tax calculators (by region, product type)

### 2. Content Management Systems
- File processors (images, videos, documents)
- Storage backends (local, cloud, CDN)
- Authentication providers (local, OAuth, LDAP)

### 3. API Integrations
- Data formats (JSON, XML, CSV)
- Transport protocols (HTTP, SOAP, GraphQL)
- Authentication methods (API key, JWT, OAuth)

### 4. Notification Systems
- Delivery channels (email, SMS, push, webhook)
- Message formats (plain text, HTML, markdown)
- Priority handling (immediate, queued, scheduled)

## Summary

The Open/Closed Principle is about building software that can grow without breaking. By designing abstractions and extension points, you create systems that welcome new features while protecting existing functionality.

**Key Takeaways:**
- Use interfaces and abstract classes for variation points
- Implement new features by adding new classes, not modifying existing ones
- Think about what might change and design abstractions around those areas
- Don't over-engineer - apply OCP where it adds real value
- Combine with other patterns (Strategy, Factory, Observer) for maximum effect

**Remember**: The goal isn't to predict every possible future requirement, but to make your code flexible enough to handle change gracefully when it comes.
