# Open/Closed Principle (OCP) - Complete Guide with Laravel Examples

## 1. Algorithm with ASCII Visualization

### Core Concept Algorithm:
```
1. Identify what might change in the future
2. Create abstractions (interfaces) for those areas
3. Implement current functionality using abstractions
4. When new requirements come → Create new implementations
5. Plug in new implementations without touching existing code
```

### ASCII Visualization - Before OCP (BAD):

```
┌─────────────────────────────────────────────────────────────┐
│                    MONOLITHIC CLASS                         │
│  ┌─────────────────────────────────────────────────────┐   │
│  │              PaymentProcessor                       │   │
│  │                                                     │   │
│  │  processPayment($type, $data) {                     │   │
│  │    if ($type == 'credit_card') {                    │   │
│  │      // Credit card logic                           │   │
│  │    } elseif ($type == 'paypal') {                   │   │
│  │      // PayPal logic                                │   │
│  │    } elseif ($type == 'bank_transfer') {            │   │
│  │      // Bank transfer logic                         │   │ ← MODIFICATION NEEDED
│  │    }                                                │   │   FOR NEW PAYMENT
│  │  }                                                  │   │
│  └─────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘

Problem: Adding new payment types requires MODIFYING existing class
Risk: Breaking existing functionality
```

### ASCII Visualization - After OCP (GOOD):

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           OPEN/CLOSED ARCHITECTURE                         │
│                                                                             │
│  ┌─────────────────────┐         ┌─────────────────────────────────────┐   │
│  │   PaymentService    │ uses     │     PaymentProcessor Interface      │   │
│  │                     │ ────────▶│                                     │   │
│  │ - processors[]      │          │ + processPayment($amount, $data)    │   │
│  │ + addProcessor()    │          │ + refund($transactionId)            │   │
│  │ + process()         │          └─────────────────────────────────────┘   │
│  └─────────────────────┘                               │                    │
│                                                        │                    │
│                                              implements│                    │
│                                                        ▼                    │
│  ┌────────────────┐  ┌────────────────┐  ┌────────────────┐                │
│  │ CreditCard     │  │ PayPalProcessor│  │ BankTransfer   │                │
│  │ Processor      │  │                │  │ Processor      │                │
│  │                │  │                │  │                │                │
│  │ + process()    │  │ + process()    │  │ + process()    │                │
│  │ + refund()     │  │ + refund()     │  │ + refund()     │                │
│  └────────────────┘  └────────────────┘  └────────────────┘                │
│         ▲                                                                   │
│         │                                                                   │
│         │ EXTENSION (Add new without modification)                          │
│         │                                                                   │
│  ┌────────────────┐  ┌────────────────┐  ┌────────────────┐                │
│  │ Cryptocurrency │  │ Apple Pay      │  │ Google Pay     │                │
│  │ Processor      │  │ Processor      │  │ Processor      │                │
│  │                │  │                │  │                │                │
│  │ + process()    │  │ + process()    │  │ + process()    │                │
│  │ + refund()     │  │ + refund()     │  │ + refund()     │                │
│  └────────────────┘  └────────────────┘  └────────────────┘                │
└─────────────────────────────────────────────────────────────────────────────┘

Benefits: 
- Add new payment types without touching existing code
- Each processor is independent and testable
- No risk of breaking existing functionality
```

### OCP Workflow Diagram:

```
REQUIREMENT CHANGE WORKFLOW:

┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   New Feature   │───▶│  Create New     │───▶│   Register/     │
│   Required      │    │  Implementation │    │   Add New       │
│                 │    │                 │    │   Component     │
└─────────────────┘    └─────────────────┘    └─────────────────┘
                                                       │
┌─────────────────┐    ┌─────────────────┐            │
│   Zero Risk     │◀───│  No Changes to  │◀───────────┘
│   Deployment    │    │  Existing Code  │
└─────────────────┘    └─────────────────┘

TRADITIONAL APPROACH (Violates OCP):
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   New Feature   │───▶│   Modify        │───▶│   Test All      │
│   Required      │    │   Existing      │    │   Existing      │
│                 │    │   Classes       │    │   Features      │
└─────────────────┘    └─────────────────┘    └─────────────────┘
                                                       │
┌─────────────────┐    ┌─────────────────┐            │
│   High Risk     │◀───│   Potential     │◀───────────┘
│   Deployment    │    │   Regressions   │
└─────────────────┘    └─────────────────┘
```

## 2. Easy PHP Code for Understanding

### Simple Example - Shape Calculator

```php
<?php
// ❌ BAD: Violates OCP
class BadShapeCalculator {
    public function calculateArea($shapes) {
        $totalArea = 0;
        
        foreach ($shapes as $shape) {
            if ($shape['type'] === 'rectangle') {
                $totalArea += $shape['width'] * $shape['height'];
            } elseif ($shape['type'] === 'circle') {
                $totalArea += pi() * $shape['radius'] * $shape['radius'];
            }
            // Need to modify this class for every new shape! ❌
        }
        
        return $totalArea;
    }
}

// ✅ GOOD: Follows OCP
interface Shape {
    public function calculateArea();
}

class Rectangle implements Shape {
    private $width, $height;
    
    public function __construct($width, $height) {
        $this->width = $width;
        $this->height = $height;
    }
    
    public function calculateArea() {
        return $this->width * $this->height;
    }
}

class Circle implements Shape {
    private $radius;
    
    public function __construct($radius) {
        $this->radius = $radius;
    }
    
    public function calculateArea() {
        return pi() * $this->radius * $this->radius;
    }
}

// This class is CLOSED for modification
class GoodShapeCalculator {
    public function calculateArea($shapes) {
        $totalArea = 0;
        
        foreach ($shapes as $shape) {
            $totalArea += $shape->calculateArea();
        }
        
        return $totalArea;
    }
}

// EXTENSION: Add new shapes without modifying existing code
class Triangle implements Shape {
    private $base, $height;
    
    public function __construct($base, $height) {
        $this->base = $base;
        $this->height = $height;
    }
    
    public function calculateArea() {
        return 0.5 * $this->base * $this->height;
    }
}

// Usage
$calculator = new GoodShapeCalculator();
$shapes = [
    new Rectangle(5, 10),
    new Circle(7),
    new Triangle(6, 8)  // New shape, no changes to calculator!
];

echo "Total Area: " . $calculator->calculateArea($shapes);
?>
```

### Easy Example - Notification System

```php
<?php
// Interface for all notification methods
interface NotificationChannel {
    public function send($message, $recipient);
}

// Existing implementations
class EmailNotification implements NotificationChannel {
    public function send($message, $recipient) {
        // Send email
        mail($recipient, 'Notification', $message);
        return "Email sent to: $recipient";
    }
}

class SMSNotification implements NotificationChannel {
    public function send($message, $recipient) {
        // Send SMS (simulated)
        return "SMS sent to: $recipient - Message: $message";
    }
}

// Notification service - CLOSED for modification
class NotificationService {
    private $channels = [];
    
    public function addChannel(NotificationChannel $channel) {
        $this->channels[] = $channel;
    }
    
    public function notify($message, $recipient) {
        $results = [];
        foreach ($this->channels as $channel) {
            $results[] = $channel->send($message, $recipient);
        }
        return $results;
    }
}

// EXTENSION: Add new notification methods without touching existing code
class SlackNotification implements NotificationChannel {
    public function send($message, $recipient) {
        // Send to Slack (simulated)
        return "Slack message sent to: $recipient";
    }
}

class PushNotification implements NotificationChannel {
    public function send($message, $recipient) {
        // Send push notification (simulated)
        return "Push notification sent to device: $recipient";
    }
}

// Usage
$notificationService = new NotificationService();
$notificationService->addChannel(new EmailNotification());
$notificationService->addChannel(new SMSNotification());

// Add new channels without modifying existing code
$notificationService->addChannel(new SlackNotification());
$notificationService->addChannel(new PushNotification());

$results = $notificationService->notify("Hello World!", "user@example.com");
foreach ($results as $result) {
    echo $result . "\n";
}
?>
```

## 3. Use Cases

### Common Scenarios Where OCP Applies:

1. **Payment Processing** - Multiple payment gateways (PayPal, Stripe, Square)
2. **File Processing** - Different formats (CSV, JSON, XML, PDF)
3. **Notification Systems** - Various channels (Email, SMS, Push, Slack)
4. **Authentication** - Multiple providers (Local, OAuth, LDAP, SSO)
5. **Data Export** - Different formats (PDF, Excel, CSV, JSON)
6. **Shipping Calculations** - Various carriers (FedEx, UPS, DHL)
7. **Tax Calculations** - Different regions and rules
8. **Content Management** - Multiple storage backends (Local, S3, CloudFlare)

## 4. Real-Life Laravel Implementation

### Scenario: E-commerce Order Processing System

```php
<?php
// app/Contracts/OrderProcessorInterface.php
namespace App\Contracts;

interface OrderProcessorInterface
{
    public function canProcess($orderType);
    public function process($order);
    public function calculateFees($order);
}

// app/Services/OrderProcessors/BaseOrderProcessor.php
namespace App\Services\OrderProcessors;

use App\Contracts\OrderProcessorInterface;

abstract class BaseOrderProcessor implements OrderProcessorInterface
{
    protected $supportedTypes = [];
    
    public function canProcess($orderType)
    {
        return in_array($orderType, $this->supportedTypes);
    }
    
    abstract public function process($order);
    abstract public function calculateFees($order);
    
    protected function logProcessing($order, $processor)
    {
        \Log::info("Order {$order->id} processed by {$processor}");
    }
}

// app/Services/OrderProcessors/StandardOrderProcessor.php
namespace App\Services\OrderProcessors;

use App\Models\Order;

class StandardOrderProcessor extends BaseOrderProcessor
{
    protected $supportedTypes = ['standard', 'regular'];
    
    public function process($order)
    {
        // Standard order processing logic
        $order->status = 'processing';
        $order->processing_fee = $this->calculateFees($order);
        $order->estimated_delivery = now()->addDays(5);
        $order->save();
        
        $this->logProcessing($order, 'StandardOrderProcessor');
        
        return [
            'success' => true,
            'message' => 'Standard order processed successfully',
            'estimated_delivery' => $order->estimated_delivery
        ];
    }
    
    public function calculateFees($order)
    {
        return $order->total * 0.03; // 3% processing fee
    }
}

// app/Services/OrderProcessors/ExpressOrderProcessor.php
namespace App\Services\OrderProcessors;

use App\Models\Order;

class ExpressOrderProcessor extends BaseOrderProcessor
{
    protected $supportedTypes = ['express', 'rush'];
    
    public function process($order)
    {
        // Express order processing logic
        $order->status = 'express_processing';
        $order->processing_fee = $this->calculateFees($order);
        $order->estimated_delivery = now()->addDays(1);
        $order->priority = 'high';
        $order->save();
        
        // Send express notification
        \Notification::send($order->customer, new ExpressOrderNotification($order));
        
        $this->logProcessing($order, 'ExpressOrderProcessor');
        
        return [
            'success' => true,
            'message' => 'Express order processed successfully',
            'estimated_delivery' => $order->estimated_delivery,
            'priority' => 'high'
        ];
    }
    
    public function calculateFees($order)
    {
        return $order->total * 0.05 + 15; // 5% + $15 express fee
    }
}

// app/Services/OrderService.php
namespace App\Services;

use App\Contracts\OrderProcessorInterface;
use App\Models\Order;

class OrderService
{
    private $processors = [];
    
    public function addProcessor(OrderProcessorInterface $processor)
    {
        $this->processors[] = $processor;
    }
    
    public function processOrder(Order $order)
    {
        foreach ($this->processors as $processor) {
            if ($processor->canProcess($order->type)) {
                return $processor->process($order);
            }
        }
        
        throw new \Exception("No processor found for order type: {$order->type}");
    }
    
    public function calculateProcessingFee(Order $order)
    {
        foreach ($this->processors as $processor) {
            if ($processor->canProcess($order->type)) {
                return $processor->calculateFees($order);
            }
        }
        
        return 0;
    }
}

// app/Providers/OrderServiceProvider.php
namespace App\Providers;

use Illuminate\Support\ServiceProvider;
use App\Services\OrderService;
use App\Services\OrderProcessors\StandardOrderProcessor;
use App\Services\OrderProcessors\ExpressOrderProcessor;

class OrderServiceProvider extends ServiceProvider
{
    public function register()
    {
        $this->app->singleton(OrderService::class, function ($app) {
            $service = new OrderService();
            
            // Register existing processors
            $service->addProcessor(new StandardOrderProcessor());
            $service->addProcessor(new ExpressOrderProcessor());
            
            return $service;
        });
    }
}

// app/Http/Controllers/OrderController.php
namespace App\Http\Controllers;

use Illuminate\Http\Request;
use App\Services\OrderService;
use App\Models\Order;

class OrderController extends Controller
{
    private $orderService;
    
    public function __construct(OrderService $orderService)
    {
        $this->orderService = $orderService;
    }
    
    public function processOrder(Request $request, Order $order)
    {
        try {
            $result = $this->orderService->processOrder($order);
            
            return response()->json([
                'success' => true,
                'data' => $result
            ]);
        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => $e->getMessage()
            ], 400);
        }
    }
}
```

### EXTENSION: Adding New Order Types (No Modification Needed!)

```php
<?php
// app/Services/OrderProcessors/InternationalOrderProcessor.php
namespace App\Services\OrderProcessors;

use App\Models\Order;

class InternationalOrderProcessor extends BaseOrderProcessor
{
    protected $supportedTypes = ['international', 'global'];
    
    public function process($order)
    {
        // International order processing logic
        $order->status = 'international_processing';
        $order->processing_fee = $this->calculateFees($order);
        $order->estimated_delivery = now()->addDays(14);
        $order->requires_customs = true;
        $order->save();
        
        // Generate customs documentation
        $this->generateCustomsDocuments($order);
        
        $this->logProcessing($order, 'InternationalOrderProcessor');
        
        return [
            'success' => true,
            'message' => 'International order processed successfully',
            'estimated_delivery' => $order->estimated_delivery,
            'customs_required' => true
        ];
    }
    
    public function calculateFees($order)
    {
        $baseFee = $order->total * 0.04; // 4% processing fee
        $customsFee = $order->total * 0.02; // 2% customs fee
        $internationalFee = 25; // $25 international handling
        
        return $baseFee + $customsFee + $internationalFee;
    }
    
    private function generateCustomsDocuments($order)
    {
        // Generate customs documentation logic
        \Log::info("Customs documents generated for order {$order->id}");
    }
}

// app/Services/OrderProcessors/DigitalOrderProcessor.php
namespace App\Services\OrderProcessors;

use App\Models\Order;

class DigitalOrderProcessor extends BaseOrderProcessor
{
    protected $supportedTypes = ['digital', 'download'];
    
    public function process($order)
    {
        // Digital order processing logic
        $order->status = 'completed'; // Digital orders complete immediately
        $order->processing_fee = $this->calculateFees($order);
        $order->estimated_delivery = now(); // Instant delivery
        $order->delivery_method = 'digital';
        $order->save();
        
        // Generate download links
        $this->generateDownloadLinks($order);
        
        // Send digital delivery email
        \Mail::to($order->customer)->send(new DigitalOrderDelivery($order));
        
        $this->logProcessing($order, 'DigitalOrderProcessor');
        
        return [
            'success' => true,
            'message' => 'Digital order processed and delivered',
            'download_links' => $this->getDownloadLinks($order),
            'delivery_method' => 'instant'
        ];
    }
    
    public function calculateFees($order)
    {
        return $order->total * 0.025; // 2.5% processing fee (lower for digital)
    }
    
    private function generateDownloadLinks($order)
    {
        // Generate secure download links
        foreach ($order->items as $item) {
            if ($item->product->type === 'digital') {
                $item->download_link = route('download', [
                    'token' => \Str::random(64),
                    'item' => $item->id
                ]);
                $item->save();
            }
        }
    }
    
    private function getDownloadLinks($order)
    {
        return $order->items->where('download_link', '!=', null)
                          ->pluck('download_link')
                          ->toArray();
    }
}

// Update app/Providers/OrderServiceProvider.php to include new processors
namespace App\Providers;

use App\Services\OrderProcessors\InternationalOrderProcessor;
use App\Services\OrderProcessors\DigitalOrderProcessor;

class OrderServiceProvider extends ServiceProvider
{
    public function register()
    {
        $this->app->singleton(OrderService::class, function ($app) {
            $service = new OrderService();
            
            // Existing processors (unchanged)
            $service->addProcessor(new StandardOrderProcessor());
            $service->addProcessor(new ExpressOrderProcessor());
            
            // NEW processors - no modification to existing code!
            $service->addProcessor(new InternationalOrderProcessor());
            $service->addProcessor(new DigitalOrderProcessor());
            
            return $service;
        });
    }
}
```

## 5. Real-Life Laravel Code - Payment Processing System

### Complete Payment System Implementation

```php
<?php
// app/Contracts/PaymentGatewayInterface.php
namespace App\Contracts;

interface PaymentGatewayInterface
{
    public function charge($amount, $paymentData);
    public function refund($transactionId, $amount);
    public function verify($transactionId);
    public function getGatewayName();
}

// app/Services/PaymentGateways/BasePaymentGateway.php
namespace App\Services\PaymentGateways;

use App\Contracts\PaymentGatewayInterface;
use App\Models\PaymentTransaction;

abstract class BasePaymentGateway implements PaymentGatewayInterface
{
    protected function createTransaction($amount, $status, $gatewayResponse = [])
    {
        return PaymentTransaction::create([
            'amount' => $amount,
            'status' => $status,
            'gateway' => $this->getGatewayName(),
            'gateway_response' => $gatewayResponse,
            'created_at' => now()
        ]);
    }
    
    protected function logTransaction($type, $amount, $details = [])
    {
        \Log::info("Payment {$type}: {$this->getGatewayName()}", [
            'amount' => $amount,
            'details' => $details
        ]);
    }
}

// app/Services/PaymentGateways/StripePaymentGateway.php
namespace App\Services\PaymentGateways;

use Stripe\Stripe;
use Stripe\PaymentIntent;

class StripePaymentGateway extends BasePaymentGateway
{
    public function __construct()
    {
        Stripe::setApiKey(config('services.stripe.secret'));
    }
    
    public function charge($amount, $paymentData)
    {
        try {
            $paymentIntent = PaymentIntent::create([
                'amount' => $amount * 100, // Stripe uses cents
                'currency' => 'usd',
                'payment_method' => $paymentData['payment_method_id'],
                'confirmation_method' => 'manual',
                'confirm' => true,
            ]);
            
            $transaction = $this->createTransaction($amount, 'completed', [
                'stripe_payment_intent_id' => $paymentIntent->id,
                'stripe_status' => $paymentIntent->status
            ]);
            
            $this->logTransaction('charge', $amount, [
                'transaction_id' => $transaction->id,
                'stripe_payment_intent' => $paymentIntent->id
            ]);
            
            return [
                'success' => true,
                'transaction_id' => $transaction->id,
                'gateway_transaction_id' => $paymentIntent->id,
                'amount' => $amount
            ];
            
        } catch (\Exception $e) {
            $transaction = $this->createTransaction($amount, 'failed', [
                'error' => $e->getMessage()
            ]);
            
            return [
                'success' => false,
                'error' => $e->getMessage(),
                'transaction_id' => $transaction->id
            ];
        }
    }
    
    public function refund($transactionId, $amount)
    {
        try {
            $transaction = PaymentTransaction::findOrFail($transactionId);
            $stripePaymentIntentId = $transaction->gateway_response['stripe_payment_intent_id'];
            
            $refund = \Stripe\Refund::create([
                'payment_intent' => $stripePaymentIntentId,
                'amount' => $amount * 100
            ]);
            
            $this->logTransaction('refund', $amount, [
                'original_transaction' => $transactionId,
                'stripe_refund_id' => $refund->id
            ]);
            
            return [
                'success' => true,
                'refund_id' => $refund->id,
                'amount' => $amount
            ];
            
        } catch (\Exception $e) {
            return [
                'success' => false,
                'error' => $e->getMessage()
            ];
        }
    }
    
    public function verify($transactionId)
    {
        $transaction = PaymentTransaction::find($transactionId);
        if (!$transaction) {
            return ['success' => false, 'error' => 'Transaction not found'];
        }
        
        try {
            $paymentIntent = PaymentIntent::retrieve(
                $transaction->gateway_response['stripe_payment_intent_id']
            );
            
            return [
                'success' => true,
                'status' => $paymentIntent->status,
                'amount' => $paymentIntent->amount / 100
            ];
            
        } catch (\Exception $e) {
            return [
                'success' => false,
                'error' => $e->getMessage()
            ];
        }
    }
    
    public function getGatewayName()
    {
        return 'stripe';
    }
}

// app/Services/PaymentGateways/PayPalPaymentGateway.php
namespace App\Services\PaymentGateways;

use PayPal\Api\Payment;
use PayPal\Api\Payer;
use PayPal\Api\Amount;
use PayPal\Api\Transaction;

class PayPalPaymentGateway extends BasePaymentGateway
{
    private $apiContext;
    
    public function __construct()
    {
        $this->apiContext = new \PayPal\Rest\ApiContext(
            new \PayPal\Auth\OAuthTokenCredential(
                config('services.paypal.client_id'),
                config('services.paypal.client_secret')
            )
        );
    }
    
    public function charge($amount, $paymentData)
    {
        try {
            $payer = new Payer();
            $payer->setPaymentMethod('paypal');
            
            $amountObj = new Amount();
            $amountObj->setCurrency('USD')
                     ->setTotal($amount);
            
            $transaction = new Transaction();
            $transaction->setAmount($amountObj)
                       ->setDescription('Payment transaction');
            
            $payment = new Payment();
            $payment->setIntent('sale')
                   ->setPayer($payer)
                   ->setTransactions(array($transaction));
            
            $payment->create($this->apiContext);
            
            $dbTransaction = $this->createTransaction($amount, 'pending', [
                'paypal_payment_id' => $payment->getId(),
                'paypal_state' => $payment->getState()
            ]);
            
            $this->logTransaction('charge', $amount, [
                'transaction_id' => $dbTransaction->id,
                'paypal_payment_id' => $payment->getId()
            ]);
            
            return [
                'success' => true,
                'transaction_id' => $dbTransaction->id,
                'gateway_transaction_id' => $payment->getId(),
                'approval_url' => $this->getApprovalUrl($payment),
                'amount' => $amount
            ];
            
        } catch (\Exception $e) {
            $dbTransaction = $this->createTransaction($amount, 'failed', [
                'error' => $e->getMessage()
            ]);
            
            return [
                'success' => false,
                'error' => $e->getMessage(),
                'transaction_id' => $dbTransaction->id
            ];
        }
    }
    
    public function refund($transactionId, $amount)
    {
        // PayPal refund implementation
        try {
            $transaction = PaymentTransaction::findOrFail($transactionId);
            
            // Simulate PayPal refund API call
            $refundId = 'paypal_refund_' . uniqid();
            
            $this->logTransaction('refund', $amount, [
                'original_transaction' => $transactionId,
                'paypal_refund_id' => $refundId
            ]);
            
            return [
                'success' => true,
                'refund_id' => $refundId,
                'amount' => $amount
            ];
            
        } catch (\Exception $e) {
            return [
                'success' => false,
                'error' => $e->getMessage()
            ];
        }
    }
    
    public function verify($transactionId)
    {
        $transaction = PaymentTransaction::find($transactionId);
        if (!$transaction) {
            return ['success' => false, 'error' => 'Transaction not found'];
        }
        
        try {
            $payment = Payment::get(
                $transaction->gateway_response['paypal_payment_id'],
                $this->apiContext
            );
            
            return [
                'success' => true,
                'status' => $payment->getState(),
                'amount' => $transaction->amount
            ];
            
        } catch (\Exception $e) {
            return [
                'success' => false,
                'error' => $e->getMessage()
            ];
        }
    }
    
    public function getGatewayName()
    {
        return 'paypal';
    }
    
    private function getApprovalUrl($payment)
    {
        foreach ($payment->getLinks() as $link) {
            if ($link->getRel() === 'approval_url') {
                return $link->getHref();
            }
        }
        return null;
    }
}

// app/Services/PaymentService.php
namespace App\Services;

use App\Contracts\PaymentGatewayInterface;

class PaymentService
{
    private $gateways = [];
    
    public function addGateway($name, PaymentGatewayInterface $gateway)
    {
        $this->gateways[$name] = $gateway;
    }
    
    public function charge($gatewayName, $amount, $paymentData)
    {
        if (!isset($this->gateways[$gatewayName])) {
            throw new \Exception("Payment gateway '{$gatewayName}' not found");
        }
        
        return $this->gateways[$gatewayName]->charge($amount, $paymentData);
    }
    
    public function refund($gatewayName, $transactionId, $amount)
    {
        if (!isset($this->gateways[$gatewayName])) {
            throw new \Exception("Payment gateway '{$gatewayName}' not found");
        }
        
        return $this->gateways[$gatewayName]->refund($transactionId, $amount);
    }
    
    public function verify($gatewayName, $transactionId)
    {
        if (!isset($this->gateways[$gatewayName])) {
            throw new \Exception("Payment gateway '{$gatewayName}' not found");
        }
        
        return $this->gateways[$gatewayName]->verify($transactionId);
    }
    
    public function getAvailableGateways()
    {
        return array_keys($this->gateways);
    }
}

// app/Providers/PaymentServiceProvider.php
namespace App\Providers;

use Illuminate\Support\ServiceProvider;
use App\Services\PaymentService;
use App\Services\PaymentGateways\StripePaymentGateway;
use App\Services\PaymentGateways\PayPalPaymentGateway;

class PaymentServiceProvider extends ServiceProvider
{
    public function register()
    {
        $this->app->singleton(PaymentService::class, function ($app) {
            $service = new PaymentService();
            
            // Register existing payment gateways
            $service->addGateway('stripe', new StripePaymentGateway());
            $service->addGateway('paypal', new PayPalPaymentGateway());
            
            return $service;
        });
    }
}

// app/Http/Controllers/PaymentController.php
namespace App\Http\Controllers;

use Illuminate\Http\Request;
use App\Services\PaymentService;
use App\Http\Requests\ProcessPaymentRequest;

class PaymentController extends Controller
{
    private $paymentService;
    
    public function __construct(PaymentService $paymentService)
    {
        $this->paymentService = $paymentService;
    }
    
    public function processPayment(ProcessPaymentRequest $request)
    {
        try {
            $result = $this->paymentService->charge(
                $request->gateway,
                $request->amount,
                $request->payment_data
            );
            
            return response()->json([
                'success' => true,
                'data' => $result
            ]);
            
        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => $e->getMessage()
            ], 400);
        }
    }
    
    public function refundPayment(Request $request)
    {
        $request->validate([
            'gateway' => 'required|string',
            'transaction_id' => 'required|integer',
            'amount' => 'required|numeric|min:0'
        ]);
        
        try {
            $result = $this->paymentService->refund(
                $request->gateway,
                $request->transaction_id,
                $request->amount
            );
            
            return response()->json([
                'success' => true,
                'data' => $result
            ]);
            
        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => $e->getMessage()
            ], 400);
        }
    }
    
    public function verifyPayment(Request $request)
    {
        $request->validate([
            'gateway' => 'required|string',
            'transaction_id' => 'required|integer'
        ]);
        
        try {
            $result = $this->paymentService->verify(
                $request->gateway,
                $request->transaction_id
            );
            
            return response()->json([
                'success' => true,
                'data' => $result
            ]);
            
        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'message' => $e->getMessage()
            ], 400);
        }
    }
    
    public function getGateways()
    {
        return response()->json([
            'gateways' => $this->paymentService->getAvailableGateways()
        ]);
    }
}
```

### EXTENSION: Adding New Payment Gateways (Zero Modification!)

```php
<?php
// app/Services/PaymentGateways/SquarePaymentGateway.php
namespace App\Services\PaymentGateways;

use SquareConnect\Api\PaymentsApi;
use SquareConnect\Model\CreatePaymentRequest;
use SquareConnect\Model\Money;

class SquarePaymentGateway extends BasePaymentGateway
{
    private $paymentsApi;
    
    public function __construct()
    {
        $config = new \SquareConnect\Configuration();
        $config->setAccessToken(config('services.square.access_token'));
        $config->setHost(config('services.square.environment'));
        
        $this->paymentsApi = new PaymentsApi(null, $config);
    }
    
    public function charge($amount, $paymentData)
    {
        try {
            $money = new Money();
            $money->setAmount($amount * 100); // Square uses cents
            $money->setCurrency('USD');
            
            $request = new CreatePaymentRequest();
            $request->setSourceId($paymentData['source_id']);
            $request->setAmountMoney($money);
            $request->setIdempotencyKey(uniqid());
            
            $response = $this->paymentsApi->createPayment($request);
            $payment = $response->getPayment();
            
            $transaction = $this->createTransaction($amount, 'completed', [
                'square_payment_id' => $payment->getId(),
                'square_status' => $payment->getStatus()
            ]);
            
            $this->logTransaction('charge', $amount, [
                'transaction_id' => $transaction->id,
                'square_payment_id' => $payment->getId()
            ]);
            
            return [
                'success' => true,
                'transaction_id' => $transaction->id,
                'gateway_transaction_id' => $payment->getId(),
                'amount' => $amount
            ];
            
        } catch (\Exception $e) {
            $transaction = $this->createTransaction($amount, 'failed', [
                'error' => $e->getMessage()
            ]);
            
            return [
                'success' => false,
                'error' => $e->getMessage(),
                'transaction_id' => $transaction->id
            ];
        }
    }
    
    public function refund($transactionId, $amount)
    {
        try {
            $transaction = PaymentTransaction::findOrFail($transactionId);
            $squarePaymentId = $transaction->gateway_response['square_payment_id'];
            
            // Square refund implementation
            $refundId = 'square_refund_' . uniqid();
            
            $this->logTransaction('refund', $amount, [
                'original_transaction' => $transactionId,
                'square_refund_id' => $refundId
            ]);
            
            return [
                'success' => true,
                'refund_id' => $refundId,
                'amount' => $amount
            ];
            
        } catch (\Exception $e) {
            return [
                'success' => false,
                'error' => $e->getMessage()
            ];
        }
    }
    
    public function verify($transactionId)
    {
        $transaction = PaymentTransaction::find($transactionId);
        if (!$transaction) {
            return ['success' => false, 'error' => 'Transaction not found'];
        }
        
        try {
            // Square verification implementation
            return [
                'success' => true,
                'status' => $transaction->status,
                'amount' => $transaction->amount
            ];
            
        } catch (\Exception $e) {
            return [
                'success' => false,
                'error' => $e->getMessage()
            ];
        }
    }
    
    public function getGatewayName()
    {
        return 'square';
    }
}

// app/Services/PaymentGateways/CryptocurrencyPaymentGateway.php
namespace App\Services\PaymentGateways;

class CryptocurrencyPaymentGateway extends BasePaymentGateway
{
    public function charge($amount, $paymentData)
    {
        try {
            // Cryptocurrency payment processing
            $walletAddress = $paymentData['wallet_address'];
            $cryptoType = $paymentData['crypto_type'];
            
            // Simulate blockchain transaction
            $blockchainTxId = 'crypto_' . strtoupper($cryptoType) . '_' . uniqid();
            
            $transaction = $this->createTransaction($amount, 'pending', [
                'blockchain_tx_id' => $blockchainTxId,
                'crypto_type' => $cryptoType,
                'wallet_address' => $walletAddress,
                'confirmations_required' => 6
            ]);
            
            $this->logTransaction('charge', $amount, [
                'transaction_id' => $transaction->id,
                'blockchain_tx_id' => $blockchainTxId,
                'crypto_type' => $cryptoType
            ]);
            
            return [
                'success' => true,
                'transaction_id' => $transaction->id,
                'gateway_transaction_id' => $blockchainTxId,
                'amount' => $amount,
                'crypto_type' => $cryptoType,
                'confirmations_required' => 6,
                'estimated_confirmation_time' => '60 minutes'
            ];
            
        } catch (\Exception $e) {
            $transaction = $this->createTransaction($amount, 'failed', [
                'error' => $e->getMessage()
            ]);
            
            return [
                'success' => false,
                'error' => $e->getMessage(),
                'transaction_id' => $transaction->id
            ];
        }
    }
    
    public function refund($transactionId, $amount)
    {
        // Cryptocurrency refunds work differently
        return [
            'success' => false,
            'error' => 'Cryptocurrency payments cannot be automatically refunded. Please process manually.'
        ];
    }
    
    public function verify($transactionId)
    {
        $transaction = PaymentTransaction::find($transactionId);
        if (!$transaction) {
            return ['success' => false, 'error' => 'Transaction not found'];
        }
        
        try {
            // Simulate blockchain verification
            $confirmations = rand(0, 6); // Simulate confirmations
            $status = $confirmations >= 6 ? 'completed' : 'pending';
            
            return [
                'success' => true,
                'status' => $status,
                'confirmations' => $confirmations,
                'blockchain_tx_id' => $transaction->gateway_response['blockchain_tx_id'],
                'amount' => $transaction->amount
            ];
            
        } catch (\Exception $e) {
            return [
                'success' => false,
                'error' => $e->getMessage()
            ];
        }
    }
    
    public function getGatewayName()
    {
        return 'cryptocurrency';
    }
}

// Update PaymentServiceProvider to include new gateways
namespace App\Providers;

use App\Services\PaymentGateways\SquarePaymentGateway;
use App\Services\PaymentGateways\CryptocurrencyPaymentGateway;

class PaymentServiceProvider extends ServiceProvider
{
    public function register()
    {
        $this->app->singleton(PaymentService::class, function ($app) {
            $service = new PaymentService();
            
            // Existing gateways (NO CHANGES NEEDED!)
            $service->addGateway('stripe', new StripePaymentGateway());
            $service->addGateway('paypal', new PayPalPaymentGateway());
            
            // NEW gateways - EXTENSION without MODIFICATION!
            $service->addGateway('square', new SquarePaymentGateway());
            $service->addGateway('cryptocurrency', new CryptocurrencyPaymentGateway());
            
            return $service;
        });
    }
}
```

### Database Migration for Payment Transactions

```php
<?php
// database/migrations/create_payment_transactions_table.php
use Illuminate\Database\Migrations\Migration;
use Illuminate\Database\Schema\Blueprint;
use Illuminate\Support\Facades\Schema;

class CreatePaymentTransactionsTable extends Migration
{
    public function up()
    {
        Schema::create('payment_transactions', function (Blueprint $table) {
            $table->id();
            $table->decimal('amount', 10, 2);
            $table->enum('status', ['pending', 'completed', 'failed', 'refunded']);
            $table->string('gateway');
            $table->json('gateway_response')->nullable();
            $table->unsignedBigInteger('user_id')->nullable();
            $table->unsignedBigInteger('order_id')->nullable();
            $table->timestamps();
            
            $table->foreign('user_id')->references('id')->on('users');
            $table->foreign('order_id')->references('id')->on('orders');
            $table->index(['gateway', 'status']);
        });
    }
    
    public function down()
    {
        Schema::dropIfExists('payment_transactions');
    }
}
```

### Routes Configuration

```php
<?php
// routes/api.php
use App\Http\Controllers\PaymentController;
use App\Http\Controllers\OrderController;

Route::prefix('payments')->group(function () {
    Route::post('/process', [PaymentController::class, 'processPayment']);
    Route::post('/refund', [PaymentController::class, 'refundPayment']);
    Route::post('/verify', [PaymentController::class, 'verifyPayment']);
    Route::get('/gateways', [PaymentController::class, 'getGateways']);
});

Route::prefix('orders')->group(function () {
    Route::post('/{order}/process', [OrderController::class, 'processOrder']);
});
```

### Frontend Usage Examples

```javascript
// Frontend JavaScript - Processing Payments
class PaymentProcessor {
    async processPayment(gateway, amount, paymentData) {
        try {
            const response = await fetch('/api/payments/process', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRF-TOKEN': document.querySelector('meta[name="csrf-token"]').content
                },
                body: JSON.stringify({
                    gateway: gateway,
                    amount: amount,
                    payment_data: paymentData
                })
            });
            
            const result = await response.json();
            
            if (result.success) {
                console.log('Payment successful:', result.data);
                return result.data;
            } else {
                console.error('Payment failed:', result.message);
                throw new Error(result.message);
            }
        } catch (error) {
            console.error('Payment error:', error);
            throw error;
        }
    }
    
    async getAvailableGateways() {
        const response = await fetch('/api/payments/gateways');
        const result = await response.json();
        return result.gateways;
    }
}

// Usage
const processor = new PaymentProcessor();

// Process Stripe payment
processor.processPayment('stripe', 100.00, {
    payment_method_id: 'pm_1234567890'
}).then(result => {
    console.log('Stripe payment completed:', result);
});

// Process PayPal payment
processor.processPayment('paypal', 50.00, {
    return_url: 'https://example.com/success',
    cancel_url: 'https://example.com/cancel'
}).then(result => {
    console.log('PayPal payment initiated:', result);
    if (result.approval_url) {
        window.location.href = result.approval_url;
    }
});

// Process cryptocurrency payment
processor.processPayment('cryptocurrency', 75.00, {
    wallet_address: '1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa',
    crypto_type: 'bitcoin'
}).then(result => {
    console.log('Crypto payment initiated:', result);
    console.log('Confirmations required:', result.confirmations_required);
});
```

## Summary: Benefits of OCP in Laravel

### ✅ Benefits Achieved:

1. **Zero Risk Extensions**: Add new payment gateways without touching existing code
2. **Independent Testing**: Each gateway can be tested in isolation
3. **Easy Maintenance**: Bug fixes in one gateway don't affect others
4. **Flexible Configuration**: Can enable/disable gateways per environment
5. **Clean Architecture**: Each gateway has single responsibility
6. **Developer Confidence**: No fear of breaking existing functionality

### 🎯 Key OCP Patterns Used:

1. **Interface Segregation**: `PaymentGatewayInterface` defines contract
2. **Dependency Injection**: Service provider registers implementations
3. **Strategy Pattern**: Each gateway implements different strategies
4. **Factory Pattern**: PaymentService acts as gateway factory

### 🚀 Real-world Impact:

- **Development Speed**: New features added faster
- **Code Quality**: Cleaner, more maintainable codebase
- **Team Confidence**: Developers comfortable making changes
- **Business Agility**: Quick response to new requirements
- **Risk Reduction**: Stable, tested foundation

The Open/Closed Principle transforms your Laravel applications from fragile monoliths into flexible, extensible systems that welcome change!
