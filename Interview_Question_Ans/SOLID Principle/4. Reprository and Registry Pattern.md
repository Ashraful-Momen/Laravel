Got it — here’s a **complete dev-friendly note** for **Repository Pattern** and **Registry Pattern**, covering:

* Algorithm / working
* ASCII flow
* Example code (PHP style)
* Quick reference summary

---

## **1. Repository Pattern**

### **Algorithm**

1. **Define an interface** that describes the methods for interacting with the data source (e.g., DB, API).
2. **Implement the interface** in a concrete repository class that handles the actual persistence logic.
3. **Inject the repository** into services or controllers.
4. **Business logic** calls repository methods instead of directly accessing the DB.

**Why?**

* Decouples business logic from data access.
* Makes testing easier (can mock repository).
* Allows swapping storage (MySQL → MongoDB) without changing business code.

---

### **ASCII Flow**

```
Controller/Service
     |
     v
Repository Interface  <- Defines contract
     |
     v
Concrete Repository   <- Implements contract
     |
     v
Database / External API
```

---

### **Example (PHP / Laravel style)**

**Interface (Core Layer)**

```php
// Core/Interfaces/UserRepositoryInterface.php
namespace Core\Interfaces;

interface UserRepositoryInterface {
    public function getById(int $id);
    public function getAll();
    public function save($user);
}
```

**Implementation (Infrastructure Layer)**

```php
// Infrastructure/Repositories/UserRepository.php
namespace Infrastructure\Repositories;

use Core\Interfaces\UserRepositoryInterface;
use App\Models\User as EloquentUser;

class UserRepository implements UserRepositoryInterface {
    public function getById(int $id) {
        return EloquentUser::find($id);
    }
    public function getAll() {
        return EloquentUser::all();
    }
    public function save($user) {
        return $user->save();
    }
}
```

**Usage**

```php
$userRepo = new UserRepository();
$user = $userRepo->getById(1);
```

---

**Quick Note (Repository Pattern)**

* **Purpose**: Isolate data access logic from business logic.
* **Benefit**: Loose coupling, testability, easier maintenance.
* **Best Practice**: Always code against the interface, not the concrete repository.

---

## **2. Registry Pattern**

### **Algorithm**

1. Maintain a **central storage (registry)** of shared objects.
2. Store instances in a static property (e.g., array).
3. Access those instances globally using a key.

**Why?**

* Provides a **global well-known object store**.
* Avoids repeatedly creating objects (shared state).
* But can **increase coupling** if abused.

---

### **ASCII Flow**

```
+-------------------+
|  Registry Class    |
|-------------------|
| [ 'db' => DBConn ] |
| [ 'logger' => Log ]|
+---------+---------+
          |
  get('db') / set('logger')
          |
      Anywhere in app
```

---

### **Example (PHP)**

```php
// Registry.php
class Registry {
    private static $store = [];

    public static function set($key, $object) {
        self::$store[$key] = $object;
    }

    public static function get($key) {
        return self::$store[$key] ?? null;
    }
}

// Example usage
Registry::set('config', ['db' => 'mysql', 'host' => 'localhost']);
$config = Registry::get('config');

Registry::set('logger', new Logger());
$logger = Registry::get('logger');
```

---

**Quick Note (Registry Pattern)**

* **Purpose**: Store and retrieve shared objects globally.
* **Benefit**: Easy central access.
* **Risk**: Can lead to hidden dependencies and tight coupling — use sparingly.
* **Difference from Repository**:

  * **Repository** → abstracts data access (DB/API).
  * **Registry** → stores/retrieves shared objects.

---

✅ **Key takeaway**:

* Use **Repository Pattern** for clean, testable data access.
* Use **Registry Pattern** as a *global object store* only when truly needed.

---

If you want, I can also merge **Onion Architecture + Repository Pattern + Registry Pattern** into **one combined workflow diagram** so you can see **how they fit together in a real system**.
Want me to prepare that combined diagram?
