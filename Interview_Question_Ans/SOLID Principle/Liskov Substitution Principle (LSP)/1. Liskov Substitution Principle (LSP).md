# Liskov Substitution Principle (LSP) - Complete Guide with Laravel Examples

## Definition

> **"Objects of a superclass should be replaceable with objects of a subclass without breaking the application."**

**In Simple Terms**: If you have a parent class and child classes, you should be able to use any child class wherever you use the parent class, and everything should work the same way.

## 1. Algorithm with ASCII Visualization

### Core LSP Algorithm:
```
1. Define parent class or interface with specific behavior contract
2. Create child classes that implement the same contract
3. Ensure child classes don't change expected behavior
4. Test: Replace parent with child - should work identically
5. No client code should break when substitution happens
```

### ASCII Visualization - LSP Violation (BAD):

```
┌─────────────────────────────────────────────────────────────────────────┐
│                           LSP VIOLATION                                 │
│                                                                         │
│  ┌─────────────────┐                                                    │
│  │    Bird Class   │                                                    │
│  │                 │                                                    │
│  │  + fly()        │ ← All birds should fly, right?                    │
│  │  + makeSound()  │                                                    │
│  └─────────────────┘                                                    │
│           │                                                             │
│           │ inherits                                                    │
│           ▼                                                             │
│  ┌─────────────────┐         ┌─────────────────┐                       │
│  │   Eagle Class   │         │  Penguin Class  │                       │
│  │                 │         │                 │                       │
│  │  + fly() ✓      │         │  + fly() ❌     │ ← BREAKS LSP!          │
│  │    flies fast   │         │    throws       │   Penguin can't fly    │
│  │  + makeSound()  │         │    exception    │   but inherits fly()   │
│  └─────────────────┘         │  + makeSound()  │                       │
│                               └─────────────────┘                       │
│                                                                         │
│  Client Code:                                                           │
│  function makeBirdFly(Bird $bird) {                                     │
│    $bird->fly(); // ❌ BREAKS with Penguin!                            │
│  }                                                                      │
│                                                                         │
│  makeBirdFly(new Eagle());   // ✓ Works                                │
│  makeBirdFly(new Penguin()); // ❌ Exception! LSP violated             │
└─────────────────────────────────────────────────────────────────────────┘
```

### ASCII Visualization - LSP Compliant (GOOD):

```
┌─────────────────────────────────────────────────────────────────────────┐
│                           LSP COMPLIANT                                 │
│                                                                         │
│  ┌─────────────────┐                                                    │
│  │    Bird Class   │                                                    │
│  │                 │                                                    │
│  │  + move()       │ ← All birds can move (fly, swim, walk)            │
│  │  + makeSound()  │                                                    │
│  └─────────────────┘                                                    │
│           │                                                             │
│           │ inherits                                                    │
│           ▼                                                             │
│  ┌─────────────────┐         ┌─────────────────┐                       │
│  │   Eagle Class   │         │  Penguin Class  │                       │
│  │                 │         │                 │                       │
│  │  + move() ✓     │         │  + move() ✓     │ ← FOLLOWS LSP!         │
│  │    flies fast   │         │    swims fast   │   Both can move        │
│  │  + makeSound()  │         │  + makeSound()  │   in their own way     │
│  └─────────────────┘         └─────────────────┘                       │
│                                                                         │
│  Optional Specific Interfaces:                                          │
│  ┌─────────────────┐         ┌─────────────────┐                       │
│  │ Flyable Interface│         │Swimmable Interface│                     │
│  │  + fly()        │         │  + swim()       │                       │
│  └─────────────────┘         └─────────────────┘                       │
│           ▲                           ▲                                 │
│           │                           │                                 │
│      Eagle only                  Penguin only                          │
│                                                                         │
│  Client Code:                                                           │
│  function makeBirdMove(Bird $bird) {                                    │
│    $bird->move(); // ✓ Works with ALL birds!                          │
│  }                                                                      │
│                                                                         │
│  makeBirdMove(new Eagle());   // ✓ Eagle flies                         │
│  makeBirdMove(new Penguin()); // ✓ Penguin swims                       │
└─────────────────────────────────────────────────────────────────────────┘
```

### LSP Substitution Flow Diagram:

```
SUBSTITUTION TEST WORKFLOW:

┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Client Code   │───▶│   Uses Parent   │───▶│   Expected      │
│   expects       │    │   Class/        │    │   Behavior      │
│   certain       │    │   Interface     │    │                 │
│   behavior      │    │                 │    │                 │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         │                       │                       │
         ▼                       ▼                       ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Substitute    │───▶│   With Child    │───▶│   Same or       │
│   Parent with   │    │   Class         │    │   Compatible    │
│   Child         │    │   Instance      │    │   Behavior      │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                                             │
         │              LSP COMPLIANCE CHECK           │
         └─────────────────────────────────────────────┘
                                  │
                         ✓ If same behavior = LSP ✓
                         ❌ If different behavior = LSP ❌

EXAMPLE:
Storage $storage = new FileStorage();     // Parent type
$storage->store($data);                   // Works

Storage $storage = new DatabaseStorage(); // Child substitution
$storage->store($data);                   // Should work identically!
```

## 2. Easy PHP Code Examples

### Simple Example - Rectangle vs Square Problem

```php
<?php
// ❌ BAD: LSP Violation
class Rectangle {
    protected $width;
    protected $height;
    
    public function setWidth($width) {
        $this->width = $width;
    }
    
    public function setHeight($height) {
        $this->height = $height;
    }
    
    public function getWidth() {
        return $this->width;
    }
    
    public function getHeight() {
        return $this->height;
    }
    
    public function getArea() {
        return $this->width * $this->height;
    }
}

// This violates LSP!
class Square extends Rectangle {
    public function setWidth($width) {
        $this->width = $width;
        $this->height = $width; // ❌ Changes behavior!
    }
    
    public function setHeight($height) {
        $this->width = $height;  // ❌ Changes behavior!
        $this->height = $height;
    }
}

// Client code that breaks with Square
function calculateArea(Rectangle $rectangle) {
    $rectangle->setWidth(5);
    $rectangle->setHeight(10);
    // Expected: 5 * 10 = 50
    return $rectangle->getArea();
}

$rectangle = new Rectangle();
echo calculateArea($rectangle); // Output: 50 ✓

$square = new Square();
echo calculateArea($square); // Output: 100 ❌ (Unexpected!)
// LSP violated - substitution changes behavior

// ✅ GOOD: LSP Compliant Solution
interface Shape {
    public function getArea();
}

class GoodRectangle implements Shape {
    private $width;
    private $height;
    
    public function __construct($width, $height) {
        $this->width = $width;
        $this->height = $height;
    }
    
    public function getArea() {
        return $this->width * $this->height;
    }
    
    public function getWidth() {
        return $this->width;
    }
    
    public function getHeight() {
        return $this->height;
    }
}

class GoodSquare implements Shape {
    private $side;
    
    public function __construct($side) {
        $this->side = $side;
    }
    
    public function getArea() {
        return $this->side * $this->side;
    }
    
    public function getSide() {
        return $this->side;
    }
}

// Client code works with any Shape
function calculateShapeArea(Shape $shape) {
    return $shape->getArea(); // ✓ Always works as expected
}

$rectangle = new GoodRectangle(5, 10);
echo calculateShapeArea($rectangle); // Output: 50 ✓

$square = new GoodSquare(7);
echo calculateShapeArea($square); // Output: 49 ✓
// LSP respected - substitution works perfectly
?>
```

### Simple Example - File Storage System

```php
<?php
// Interface defining the contract
interface FileStorage {
    public function store($filename, $content);
    public function retrieve($filename);
    public function delete($filename);
    public function exists($filename);
}

// ✅ GOOD: All implementations follow the same contract
class LocalFileStorage implements FileStorage {
    private $basePath;
    
    public function __construct($basePath = 'storage/') {
        $this->basePath = $basePath;
    }
    
    public function store($filename, $content) {
        $fullPath = $this->basePath . $filename;
        return file_put_contents($fullPath, $content) !== false;
    }
    
    public function retrieve($filename) {
        $fullPath = $this->basePath . $filename;
        if (!file_exists($fullPath)) {
            return null; // Consistent behavior
        }
        return file_get_contents($fullPath);
    }
    
    public function delete($filename) {
        $fullPath = $this->basePath . $filename;
        if (file_exists($fullPath)) {
            return unlink($fullPath);
        }
        return true; // Already deleted = success
    }
    
    public function exists($filename) {
        return file_exists($this->basePath . $filename);
    }
}

class DatabaseFileStorage implements FileStorage {
    private $pdo;
    
    public function __construct($pdo) {
        $this->pdo = $pdo;
    }
    
    public function store($filename, $content) {
        $stmt = $this->pdo->prepare("INSERT OR REPLACE INTO files (filename, content) VALUES (?, ?)");
        return $stmt->execute([$filename, $content]);
    }
    
    public function retrieve($filename) {
        $stmt = $this->pdo->prepare("SELECT content FROM files WHERE filename = ?");
        $stmt->execute([$filename]);
        $result = $stmt->fetch();
        return $result ? $result['content'] : null; // Same behavior as LocalFileStorage
    }
    
    public function delete($filename) {
        $stmt = $this->pdo->prepare("DELETE FROM files WHERE filename = ?");
        return $stmt->execute([$filename]);
    }
    
    public function exists($filename) {
        $stmt = $this->pdo->prepare("SELECT COUNT(*) FROM files WHERE filename = ?");
        $stmt->execute([$filename]);
        return $stmt->fetchColumn() > 0;
    }
}

// Client code - works with ANY FileStorage implementation
class DocumentManager {
    private $storage;
    
    public function __construct(FileStorage $storage) {
        $this->storage = $storage;
    }
    
    public function saveDocument($name, $content) {
        if ($this->storage->exists($name)) {
            throw new Exception("Document already exists: $name");
        }
        
        return $this->storage->store($name, $content);
    }
    
    public function getDocument($name) {
        $content = $this->storage->retrieve($name);
        if ($content === null) {
            throw new Exception("Document not found: $name");
        }
        return $content;
    }
    
    public function removeDocument($name) {
        if (!$this->storage->exists($name)) {
            throw new Exception("Document not found: $name");
        }
        
        return $this->storage->delete($name);
    }
}

// Usage - LSP in action! Both storage types work identically
$localManager = new DocumentManager(new LocalFileStorage());
$dbManager = new DocumentManager(new DatabaseFileStorage($pdo));

// Both managers work exactly the same way
$localManager->saveDocument('test.txt', 'Hello World');
$dbManager->saveDocument('test.txt', 'Hello World');

$content1 = $localManager->getDocument('test.txt'); // "Hello World"
$content2 = $dbManager->getDocument('test.txt');    // "Hello World"

// Perfect substitution - LSP respected!
?>
```

## 3. Use Cases

### Common LSP Scenarios:

1. **Storage Systems** - File, Database, Cloud storage (all store/retrieve data)
2. **Payment Gateways** - Stripe, PayPal, Square (all process payments)
3. **Notification Channels** - Email, SMS, Push (all send messages)
4. **Authentication Providers** - Local, OAuth, LDAP (all authenticate users)
5. **Database Connections** - MySQL, PostgreSQL, SQLite (all execute queries)
6. **Cache Systems** - Redis, Memcached, File cache (all cache data)
7. **API Clients** - REST, GraphQL, SOAP (all fetch data)
8. **File Processors** - PDF, Image, Video (all process files)

### When LSP is Important:

✅ **Plugin Systems** - Plugins must work interchangeably
✅ **Testing** - Mock objects must behave like real objects
✅ **Configuration-based Systems** - Different implementations per environment
✅ **Library Development** - Users expect consistent behavior
✅ **Microservices** - Services must be substitutable

## 4. Real-Life Laravel Implementation

### Scenario: Multi-Channel Notification System

```php
<?php
// app/Contracts/NotificationChannelInterface.php
namespace App\Contracts;

interface NotificationChannelInterface
{
    public function send($recipient, $message, $options = []);
    public function isAvailable();
    public function getChannelName();
    public function validateRecipient($recipient);
}

// app/Services/Notifications/BaseNotificationChannel.php
namespace App\Services\Notifications;

use App\Contracts\NotificationChannelInterface;
use Illuminate\Support\Facades\Log;

abstract class BaseNotificationChannel implements NotificationChannelInterface
{
    protected function logNotification($channel, $recipient, $status, $details = [])
    {
        Log::info("Notification sent via {$channel}", [
            'recipient' => $recipient,
            'status' => $status,
            'details' => $details,
            'timestamp' => now()
        ]);
    }
    
    protected function handleError($error, $recipient)
    {
        Log::error("Notification failed", [
            'channel' => $this->getChannelName(),
            'recipient' => $recipient,
            'error' => $error,
            'timestamp' => now()
        ]);
        
        return [
            'success' => false,
            'error' => $error,
            'channel' => $this->getChannelName()
        ];
    }
    
    abstract public function send($recipient, $message, $options = []);
    abstract public function isAvailable();
    abstract public function getChannelName();
    abstract public function validateRecipient($recipient);
}

// app/Services/Notifications/EmailNotificationChannel.php
namespace App\Services\Notifications;

use Illuminate\Support\Facades\Mail;
use App\Mail\NotificationMail;

class EmailNotificationChannel extends BaseNotificationChannel
{
    public function send($recipient, $message, $options = [])
    {
        if (!$this->validateRecipient($recipient)) {
            return $this->handleError('Invalid email address', $recipient);
        }
        
        if (!$this->isAvailable()) {
            return $this->handleError('Email service unavailable', $recipient);
        }
        
        try {
            $subject = $options['subject'] ?? 'Notification';
            
            Mail::to($recipient)->send(new NotificationMail($message, $subject));
            
            $this->logNotification($this->getChannelName(), $recipient, 'sent', [
                'subject' => $subject
            ]);
            
            return [
                'success' => true,
                'channel' => $this->getChannelName(),
                'recipient' => $recipient,
                'message' => 'Email sent successfully'
            ];
            
        } catch (\Exception $e) {
            return $this->handleError($e->getMessage(), $recipient);
        }
    }
    
    public function isAvailable()
    {
        return config('mail.driver') !== null && 
               config('mail.from.address') !== null;
    }
    
    public function getChannelName()
    {
        return 'email';
    }
    
    public function validateRecipient($recipient)
    {
        return filter_var($recipient, FILTER_VALIDATE_EMAIL) !== false;
    }
}

// app/Services/Notifications/SmsNotificationChannel.php
namespace App\Services\Notifications;

use Twilio\Rest\Client;

class SmsNotificationChannel extends BaseNotificationChannel
{
    private $twilioClient;
    
    public function __construct()
    {
        if ($this->isAvailable()) {
            $this->twilioClient = new Client(
                config('services.twilio.sid'),
                config('services.twilio.token')
            );
        }
    }
    
    public function send($recipient, $message, $options = [])
    {
        if (!$this->validateRecipient($recipient)) {
            return $this->handleError('Invalid phone number', $recipient);
        }
        
        if (!$this->isAvailable()) {
            return $this->handleError('SMS service unavailable', $recipient);
        }
        
        try {
            $smsMessage = $this->twilioClient->messages->create(
                $recipient,
                [
                    'from' => config('services.twilio.from'),
                    'body' => $message
                ]
            );
            
            $this->logNotification($this->getChannelName(), $recipient, 'sent', [
                'sms_sid' => $smsMessage->sid
            ]);
            
            return [
                'success' => true,
                'channel' => $this->getChannelName(),
                'recipient' => $recipient,
                'sms_sid' => $smsMessage->sid,
                'message' => 'SMS sent successfully'
            ];
            
        } catch (\Exception $e) {
            return $this->handleError($e->getMessage(), $recipient);
        }
    }
    
    public function isAvailable()
    {
        return config('services.twilio.sid') !== null && 
               config('services.twilio.token') !== null;
    }
    
    public function getChannelName()
    {
        return 'sms';
    }
    
    public function validateRecipient($recipient)
    {
        // Basic phone number validation
        return preg_match('/^\+?[1-9]\d{1,14}$/', $recipient);
    }
}

// app/Services/Notifications/SlackNotificationChannel.php
namespace App\Services\Notifications;

use GuzzleHttp\Client;

class SlackNotificationChannel extends BaseNotificationChannel
{
    private $httpClient;
    
    public function __construct()
    {
        $this->httpClient = new Client();
    }
    
    public function send($recipient, $message, $options = [])
    {
        if (!$this->validateRecipient($recipient)) {
            return $this->handleError('Invalid Slack webhook URL', $recipient);
        }
        
        if (!$this->isAvailable()) {
            return $this->handleError('Slack service unavailable', $recipient);
        }
        
        try {
            $payload = [
                'text' => $message,
                'channel' => $options['channel'] ?? '#general',
                'username' => $options['username'] ?? 'Laravel App',
                'icon_emoji' => $options['icon'] ?? ':robot_face:'
            ];
            
            $response = $this->httpClient->post($recipient, [
                'json' => $payload
            ]);
            
            $this->logNotification($this->getChannelName(), $recipient, 'sent', [
                'channel' => $payload['channel'],
                'status_code' => $response->getStatusCode()
            ]);
            
            return [
                'success' => true,
                'channel' => $this->getChannelName(),
                'recipient' => $recipient,
                'slack_channel' => $payload['channel'],
                'message' => 'Slack message sent successfully'
            ];
            
        } catch (\Exception $e) {
            return $this->handleError($e->getMessage(), $recipient);
        }
    }
    
    public function isAvailable()
    {
        return config('services.slack.webhook_url') !== null;
    }
    
    public function getChannelName()
    {
        return 'slack';
    }
    
    public function validateRecipient($recipient)
    {
        return filter_var($recipient, FILTER_VALIDATE_URL) !== false &&
               strpos($recipient, 'hooks.slack.com') !== false;
    }
}

// app/Services/NotificationService.php - LSP in Action!
namespace App\Services;

use App\Contracts\NotificationChannelInterface;

class NotificationService
{
    private $channels = [];
    private $defaultChannels = ['email'];
    
    public function addChannel($name, NotificationChannelInterface $channel)
    {
        $this->channels[$name] = $channel;
    }
    
    public function setDefaultChannels($channels)
    {
        $this->defaultChannels = $channels;
    }
    
    // LSP: Any NotificationChannelInterface implementation works here
    public function notify($recipient, $message, $channelNames = null, $options = [])
    {
        $channelNames = $channelNames ?? $this->defaultChannels;
        $results = [];
        
        foreach ($channelNames as $channelName) {
            if (!isset($this->channels[$channelName])) {
                $results[$channelName] = [
                    'success' => false,
                    'error' => "Channel '{$channelName}' not found"
                ];
                continue;
            }
            
            $channel = $this->channels[$channelName];
            
            // LSP: Every channel implements the same interface
            // We can call send() on any channel and expect consistent behavior
            $result = $channel->send($recipient, $message, $options);
            $results[$channelName] = $result;
        }
        
        return $results;
    }
    
    public function getAvailableChannels()
    {
        $available = [];
        
        foreach ($this->channels as $name => $channel) {
            // LSP: Every channel implements isAvailable() consistently
            if ($channel->isAvailable()) {
                $available[] = [
                    'name' => $name,
                    'channel_name' => $channel->getChannelName()
                ];
            }
        }
        
        return $available;
    }
    
    public function validateRecipientForChannel($channelName, $recipient)
    {
        if (!isset($this->channels[$channelName])) {
            return false;
        }
        
        // LSP: Every channel implements validateRecipient() consistently
        return $this->channels[$channelName]->validateRecipient($recipient);
    }
}

// app/Providers/NotificationServiceProvider.php
namespace App\Providers;

use Illuminate\Support\ServiceProvider;
use App\Services\NotificationService;
use App\Services\Notifications\EmailNotificationChannel;
use App\Services\Notifications\SmsNotificationChannel;
use App\Services\Notifications\SlackNotificationChannel;

class NotificationServiceProvider extends ServiceProvider
{
    public function register()
    {
        $this->app->singleton(NotificationService::class, function ($app) {
            $service = new NotificationService();
            
            // LSP: All channels implement the same interface
            // They can be used interchangeably
            $service->addChannel('email', new EmailNotificationChannel());
            $service->addChannel('sms', new SmsNotificationChannel());
            $service->addChannel('slack', new SlackNotificationChannel());
            
            return $service;
        });
    }
}

// app/Http/Controllers/NotificationController.php
namespace App\Http\Controllers;

use Illuminate\Http\Request;
use App\Services\NotificationService;

class NotificationController extends Controller
{
    private $notificationService;
    
    public function __construct(NotificationService $notificationService)
    {
        $this->notificationService = $notificationService;
    }
    
    public function send(Request $request)
    {
        $request->validate([
            'recipient' => 'required|string',
            'message' => 'required|string',
            'channels' => 'array',
            'options' => 'array'
        ]);
        
        try {
            // LSP: The service works with any combination of channels
            // because they all implement the same interface consistently
            $results = $this->notificationService->notify(
                $request->recipient,
                $request->message,
                $request->channels,
                $request->options ?? []
            );
            
            return response()->json([
                'success' => true,
                'results' => $results
            ]);
            
        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'error' => $e->getMessage()
            ], 400);
        }
    }
    
    public function getChannels()
    {
        return response()->json([
            'channels' => $this->notificationService->getAvailableChannels()
        ]);
    }
    
    public function validateRecipient(Request $request)
    {
        $request->validate([
            'channel' => 'required|string',
            'recipient' => 'required|string'
        ]);
        
        $isValid = $this->notificationService->validateRecipientForChannel(
            $request->channel,
            $request->recipient
        );
        
        return response()->json([
            'valid' => $isValid
        ]);
    }
}
```

## 5. Real-Life Laravel Code - Cache System

### Complete Cache System with LSP

```php
<?php
// app/Contracts/CacheInterface.php
namespace App\Contracts;

interface CacheInterface
{
    public function get($key, $default = null);
    public function put($key, $value, $ttl = null);
    public function forget($key);
    public function flush();
    public function has($key);
    public function increment($key, $value = 1);
    public function decrement($key, $value = 1);
}

// app/Services/Cache/BaseCacheDriver.php
namespace App\Services\Cache;

use App\Contracts\CacheInterface;
use Illuminate\Support\Facades\Log;

abstract class BaseCacheDriver implements CacheInterface
{
    protected $prefix;
    protected $defaultTtl;
    
    public function __construct($prefix = 'app_', $defaultTtl = 3600)
    {
        $this->prefix = $prefix;
        $this->defaultTtl = $defaultTtl;
    }
    
    protected function getKey($key)
    {
        return $this->prefix . $key;
    }
    
    protected function logOperation($operation, $key, $success = true, $details = [])
    {
        Log::info("Cache {$operation}", [
            'driver' => get_class($this),
            'key' => $key,
            'success' => $success,
            'details' => $details
        ]);
    }
    
    // Abstract methods that must be implemented consistently
    abstract public function get($key, $default = null);
    abstract public function put($key, $value, $ttl = null);
    abstract public function forget($key);
    abstract public function flush();
    abstract public function has($key);
    abstract public function increment($key, $value = 1);
    abstract public function decrement($key, $value = 1);
}

// app/Services/Cache/RedisCacheDriver.php
namespace App\Services\Cache;

use Illuminate\Support\Facades\Redis;

class RedisCacheDriver extends BaseCacheDriver
{
    public function get($key, $default = null)
    {
        try {
            $value = Redis::get($this->getKey($key));
            $result = $value !== null ? unserialize($value) : $default;
            
            $this->logOperation('get', $key, true, [
                'found' => $value !== null
            ]);
            
            return $result;
            
        } catch (\Exception $e) {
            $this->logOperation('get', $key, false, ['error' => $e->getMessage()]);
            return $default;
        }
    }
    
    public function put($key, $value, $ttl = null)
    {
        try {
            $ttl = $ttl ?? $this->defaultTtl;
            $serialized = serialize($value);
            
            $result = Redis::setex($this->getKey($key), $ttl, $serialized);
            
            $this->logOperation('put', $key, $result, [
                'ttl' => $ttl,
                'size' => strlen($serialized)
            ]);
            
            return $result;
            
        } catch (\Exception $e) {
            $this->logOperation('put', $key, false, ['error' => $e->getMessage()]);
            return false;
        }
    }
    
    public function forget($key)
    {
        try {
            $result = Redis::del($this->getKey($key)) > 0;
            $this->logOperation('forget', $key, $result);
            return $result;
            
        } catch (\Exception $e) {
            $this->logOperation('forget', $key, false, ['error' => $e->getMessage()]);
            return false;
        }
    }
    
    public function flush()
    {
        try {
            $result = Redis::flushdb();
            $this->logOperation('flush', 'all', $result);
            return $result;
            
        } catch (\Exception $e) {
            $this->logOperation('flush', 'all', false, ['error' => $e->getMessage()]);
            return false;
        }
    }
    
    public function has($key)
    {
        try {
            $result = Redis::exists($this->getKey($key)) > 0;
            $this->logOperation('has', $key, true, ['exists' => $result]);
            return $result;
            
        } catch (\Exception $e) {
            $this->logOperation('has', $key, false, ['error' => $e->getMessage()]);
            return false;
        }
    }
    
    public function increment($key, $value = 1)
    {
        try {
            $result = Redis::incrby($this->getKey($key), $value);
            $this->logOperation('increment', $key, true, [
                'increment_by' => $value,
                'new_value' => $result
            ]);
            return $result;
            
        } catch (\Exception $e) {
            $this->logOperation('increment', $key, false, ['error' => $e->getMessage()]);
            return false;
        }
    }
    
    public function decrement($key, $value = 1)
    {
        try {
            $result = Redis::decrby($this->getKey($key), $value);
            $this->logOperation('decrement', $key, true, [
                'decrement_by' => $value,
                'new_value' => $result
            ]);
            return $result;
            
        } catch (\Exception $e) {
            $this->logOperation('decrement', $key, false, ['error' => $e->getMessage()]);
            return false;
        }
    }
}

// app/Services/Cache/FileCacheDriver.php
namespace App\Services\Cache;

class FileCacheDriver extends BaseCacheDriver
{
    private $cachePath;
    
    public function __construct($prefix = 'app_', $defaultTtl = 3600, $cachePath = null)
    {
        parent::__construct($prefix, $defaultTtl);
        $this->cachePath = $cachePath ?: storage_path('framework/cache/data/');
        
        if (!is_dir($this->cachePath)) {
            mkdir($this->cachePath, 0755, true);
        }
    }
    
    public function get($key, $default = null)
    {
        try {
            $filePath = $this->getFilePath($key);
            
            if (!file_exists($filePath)) {
                $this->logOperation('get', $key, true, ['found' => false]);
                return $default;
            }
            
            $content = file_get_contents($filePath);
            $data = unserialize($content);
            
            // Check if expired
            if ($data['expires'] < time()) {
                unlink($filePath);
                $this->logOperation('get', $key, true, ['found' => false, 'expired' => true]);
                return $default;
            }
            
            $this->logOperation('get', $key, true, ['found' => true]);
            return $data['value'];
            
        } catch (\Exception $e) {
            $this->logOperation('get', $key, false, ['error' => $e->getMessage()]);
            return $default;
        }
    }
    
    public function put($key, $value, $ttl = null)
    {
        try {
            $ttl = $ttl ?? $this->defaultTtl;
            $filePath = $this->getFilePath($key);
            
            $data = [
                'value' => $value,
                'expires' => time() + $ttl
            ];
            
            $result = file_put_contents($filePath, serialize($data)) !== false;
            
            $this->logOperation('put', $key, $result, [
                'ttl' => $ttl,
                'expires_at' => date('Y-m-d H:i:s', $data['expires'])
            ]);
            
            return $result;
            
        } catch (\Exception $e) {
            $this->logOperation('put', $key, false, ['error' => $e->getMessage()]);
            return false;
        }
    }
    
    public function forget($key)
    {
        try {
            $filePath = $this->getFilePath($key);
            
            if (file_exists($filePath)) {
                $result = unlink($filePath);
            } else {
                $result = true; // Already deleted
            }
            
            $this->logOperation('forget', $key, $result);
            return $result;
            
        } catch (\Exception $e) {
            $this->logOperation('forget', $key, false, ['error' => $e->getMessage()]);
            return false;
        }
    }
    
    public function flush()
    {
        try {
            $files = glob($this->cachePath . $this->prefix . '*');
            $deleted = 0;
            
            foreach ($files as $file) {
                if (unlink($file)) {
                    $deleted++;
                }
            }
            
            $this->logOperation('flush', 'all', true, ['files_deleted' => $deleted]);
            return true;
            
        } catch (\Exception $e) {
            $this->logOperation('flush', 'all', false, ['error' => $e->getMessage()]);
            return false;
        }
    }
    
    public function has($key)
    {
        try {
            $filePath = $this->getFilePath($key);
            
            if (!file_exists($filePath)) {
                $this->logOperation('has', $key, true, ['exists' => false]);
                return false;
            }
            
            // Check if expired
            $content = file_get_contents($filePath);
            $data = unserialize($content);
            
            if ($data['expires'] < time()) {
                unlink($filePath);
                $this->logOperation('has', $key, true, ['exists' => false, 'was_expired' => true]);
                return false;
            }
            
            $this->logOperation('has', $key, true, ['exists' => true]);
            return true;
            
        } catch (\Exception $e) {
            $this->logOperation('has', $key, false, ['error' => $e->getMessage()]);
            return false;
        }
    }
    
    public function increment($key, $value = 1)
    {
        try {
            $current = $this->get($key, 0);
            $newValue = $current + $value;
            
            if ($this->put($key, $newValue)) {
                $this->logOperation('increment', $key, true, [
                    'increment_by' => $value,
                    'old_value' => $current,
                    'new_value' => $newValue
                ]);
                return $newValue;
            }
            
            return false;
            
        } catch (\Exception $e) {
            $this->logOperation('increment', $key, false, ['error' => $e->getMessage()]);
            return false;
        }
    }
    
    public function decrement($key, $value = 1)
    {
        try {
            $current = $this->get($key, 0);
            $newValue = $current - $value;
            
            if ($this->put($key, $newValue)) {
                $this->logOperation('decrement', $key, true, [
                    'decrement_by' => $value,
                    'old_value' => $current,
                    'new_value' => $newValue
                ]);
                return $newValue;
            }
            
            return false;
            
        } catch (\Exception $e) {
            $this->logOperation('decrement', $key, false, ['error' => $e->getMessage()]);
            return false;
        }
    }
    
    private function getFilePath($key)
    {
        return $this->cachePath . $this->getKey($key) . '.cache';
    }
}

// app/Services/Cache/MemoryCacheDriver.php
namespace App\Services\Cache;

class MemoryCacheDriver extends BaseCacheDriver
{
    private static $storage = [];
    
    public function get($key, $default = null)
    {
        $fullKey = $this->getKey($key);
        
        if (!isset(self::$storage[$fullKey])) {
            $this->logOperation('get', $key, true, ['found' => false]);
            return $default;
        }
        
        $data = self::$storage[$fullKey];
        
        // Check if expired
        if ($data['expires'] < time()) {
            unset(self::$storage[$fullKey]);
            $this->logOperation('get', $key, true, ['found' => false, 'expired' => true]);
            return $default;
        }
        
        $this->logOperation('get', $key, true, ['found' => true]);
        return $data['value'];
    }
    
    public function put($key, $value, $ttl = null)
    {
        $ttl = $ttl ?? $this->defaultTtl;
        $fullKey = $this->getKey($key);
        
        self::$storage[$fullKey] = [
            'value' => $value,
            'expires' => time() + $ttl
        ];
        
        $this->logOperation('put', $key, true, [
            'ttl' => $ttl,
            'expires_at' => date('Y-m-d H:i:s', self::$storage[$fullKey]['expires'])
        ]);
        
        return true;
    }
    
    public function forget($key)
    {
        $fullKey = $this->getKey($key);
        $existed = isset(self::$storage[$fullKey]);
        
        unset(self::$storage[$fullKey]);
        
        $this->logOperation('forget', $key, true, ['existed' => $existed]);
        return true;
    }
    
    public function flush()
    {
        $count = count(self::$storage);
        self::$storage = [];
        
        $this->logOperation('flush', 'all', true, ['items_cleared' => $count]);
        return true;
    }
    
    public function has($key)
    {
        $fullKey = $this->getKey($key);
        
        if (!isset(self::$storage[$fullKey])) {
            $this->logOperation('has', $key, true, ['exists' => false]);
            return false;
        }
        
        $data = self::$storage[$fullKey];
        
        // Check if expired
        if ($data['expires'] < time()) {
            unset(self::$storage[$fullKey]);
            $this->logOperation('has', $key, true, ['exists' => false, 'was_expired' => true]);
            return false;
        }
        
        $this->logOperation('has', $key, true, ['exists' => true]);
        return true;
    }
    
    public function increment($key, $value = 1)
    {
        $current = $this->get($key, 0);
        $newValue = $current + $value;
        
        $this->put($key, $newValue);
        
        $this->logOperation('increment', $key, true, [
            'increment_by' => $value,
            'old_value' => $current,
            'new_value' => $newValue
        ]);
        
        return $newValue;
    }
    
    public function decrement($key, $value = 1)
    {
        $current = $this->get($key, 0);
        $newValue = $current - $value;
        
        $this->put($key, $newValue);
        
        $this->logOperation('decrement', $key, true, [
            'decrement_by' => $value,
            'old_value' => $current,
            'new_value' => $newValue
        ]);
        
        return $newValue;
    }
}

// app/Services/CacheService.php - LSP in Perfect Action!
namespace App\Services;

use App\Contracts\CacheInterface;

class CacheService
{
    private $driver;
    private $fallbackDriver;
    
    public function __construct(CacheInterface $driver, CacheInterface $fallbackDriver = null)
    {
        $this->driver = $driver;
        $this->fallbackDriver = $fallbackDriver;
    }
    
    // LSP: Works with ANY CacheInterface implementation
    public function remember($key, $ttl, $callback)
    {
        $value = $this->driver->get($key);
        
        if ($value !== null) {
            return $value;
        }
        
        $value = $callback();
        $this->driver->put($key, $value, $ttl);
        
        return $value;
    }
    
    public function rememberForever($key, $callback)
    {
        return $this->remember($key, 86400 * 365, $callback); // 1 year
    }
    
    public function get($key, $default = null)
    {
        // Try primary driver first
        $value = $this->driver->get($key, null);
        
        if ($value !== null) {
            return $value;
        }
        
        // Try fallback driver if available
        if ($this->fallbackDriver) {
            $value = $this->fallbackDriver->get($key, null);
            if ($value !== null) {
                // Store in primary driver for next time
                $this->driver->put($key, $value);
                return $value;
            }
        }
        
        return $default;
    }
    
    public function put($key, $value, $ttl = null)
    {
        $result = $this->driver->put($key, $value, $ttl);
        
        // Also store in fallback if available
        if ($this->fallbackDriver) {
            $this->fallbackDriver->put($key, $value, $ttl);
        }
        
        return $result;
    }
    
    public function forget($key)
    {
        $result = $this->driver->forget($key);
        
        if ($this->fallbackDriver) {
            $this->fallbackDriver->forget($key);
        }
        
        return $result;
    }
    
    public function flush()
    {
        $result = $this->driver->flush();
        
        if ($this->fallbackDriver) {
            $this->fallbackDriver->flush();
        }
        
        return $result;
    }
    
    public function has($key)
    {
        return $this->driver->has($key) || 
               ($this->fallbackDriver && $this->fallbackDriver->has($key));
    }
    
    public function increment($key, $value = 1)
    {
        return $this->driver->increment($key, $value);
    }
    
    public function decrement($key, $value = 1)
    {
        return $this->driver->decrement($key, $value);
    }
    
    // LSP: Can switch drivers at runtime
    public function switchDriver(CacheInterface $newDriver)
    {
        $this->driver = $newDriver;
    }
}

// app/Providers/CacheServiceProvider.php
namespace App\Providers;

use Illuminate\Support\ServiceProvider;
use App\Services\CacheService;
use App\Services\Cache\RedisCacheDriver;
use App\Services\Cache\FileCacheDriver;
use App\Services\Cache\MemoryCacheDriver;

class CacheServiceProvider extends ServiceProvider
{
    public function register()
    {
        // Register individual cache drivers
        $this->app->bind('cache.redis', function () {
            return new RedisCacheDriver('app_', 3600);
        });
        
        $this->app->bind('cache.file', function () {
            return new FileCacheDriver('app_', 3600);
        });
        
        $this->app->bind('cache.memory', function () {
            return new MemoryCacheDriver('app_', 3600);
        });
        
        // LSP: CacheService works with ANY cache driver
        $this->app->singleton(CacheService::class, function ($app) {
            $primaryDriver = config('cache.default', 'redis');
            $fallbackDriver = config('cache.fallback', 'file');
            
            $primary = $app->make("cache.{$primaryDriver}");
            $fallback = $fallbackDriver ? $app->make("cache.{$fallbackDriver}") : null;
            
            return new CacheService($primary, $fallback);
        });
    }
}

// app/Http/Controllers/CacheController.php
namespace App\Http\Controllers;

use Illuminate\Http\Request;
use App\Services\CacheService;

class CacheController extends Controller
{
    private $cacheService;
    
    public function __construct(CacheService $cacheService)
    {
        $this->cacheService = $cacheService;
    }
    
    public function get(Request $request, $key)
    {
        $value = $this->cacheService->get($key);
        
        return response()->json([
            'key' => $key,
            'value' => $value,
            'found' => $value !== null
        ]);
    }
    
    public function put(Request $request)
    {
        $request->validate([
            'key' => 'required|string',
            'value' => 'required',
            'ttl' => 'nullable|integer|min:1'
        ]);
        
        $result = $this->cacheService->put(
            $request->key,
            $request->value,
            $request->ttl
        );
        
        return response()->json([
            'success' => $result,
            'key' => $request->key,
            'ttl' => $request->ttl
        ]);
    }
    
    public function remember(Request $request)
    {
        $request->validate([
            'key' => 'required|string',
            'ttl' => 'required|integer|min:1',
            'callback_data' => 'required'
        ]);
        
        $value = $this->cacheService->remember(
            $request->key,
            $request->ttl,
            function () use ($request) {
                // Simulate expensive operation
                sleep(1);
                return $request->callback_data;
            }
        );
        
        return response()->json([
            'key' => $request->key,
            'value' => $value,
            'cached' => true
        ]);
    }
    
    public function increment(Request $request, $key)
    {
        $request->validate([
            'value' => 'nullable|integer|min:1'
        ]);
        
        $newValue = $this->cacheService->increment($key, $request->value ?? 1);
        
        return response()->json([
            'key' => $key,
            'new_value' => $newValue
        ]);
    }
    
    public function forget(Request $request, $key)
    {
        $result = $this->cacheService->forget($key);
        
        return response()->json([
            'key' => $key,
            'deleted' => $result
        ]);
    }
    
    public function flush()
    {
        $result = $this->cacheService->flush();
        
        return response()->json([
            'flushed' => $result
        ]);
    }
}
```

### LSP Testing Example

```php
<?php
// tests/Unit/LSP/CacheDriverTest.php
namespace Tests\Unit\LSP;

use Tests\TestCase;
use App\Services\Cache\RedisCacheDriver;
use App\Services\Cache\FileCacheDriver;
use App\Services\Cache\MemoryCacheDriver;
use App\Contracts\CacheInterface;

class CacheDriverTest extends TestCase
{
    /**
     * Test LSP: All cache drivers should behave consistently
     */
    public function test_all_cache_drivers_follow_lsp()
    {
        $drivers = [
            new MemoryCacheDriver('test_', 60),
            new FileCacheDriver('test_', 60, storage_path('test_cache/')),
            // new RedisCacheDriver('test_', 60), // Uncomment if Redis available
        ];
        
        foreach ($drivers as $driver) {
            $this->assertInstanceOf(CacheInterface::class, $driver);
            $this->runLSPTests($driver);
        }
    }
    
    private function runLSPTests(CacheInterface $cache)
    {
        $driverName = get_class($cache);
        
        // Test 1: Basic put/get behavior should be consistent
        $cache->put('test_key', 'test_value', 60);
        $this->assertEquals('test_value', $cache->get('test_key'), 
            "Basic get/put failed for {$driverName}");
        
        // Test 2: Default value behavior should be consistent
        $this->assertEquals('default', $cache->get('nonexistent', 'default'),
            "Default value behavior failed for {$driverName}");
        
        // Test 3: Has method should be consistent
        $this->assertTrue($cache->has('test_key'),
            "Has method failed for existing key in {$driverName}");
        $this->assertFalse($cache->has('nonexistent'),
            "Has method failed for nonexistent key in {$driverName}");
        
        // Test 4: Forget method should be consistent
        $cache->forget('test_key');
        $this->assertFalse($cache->has('test_key'),
            "Forget method failed for {$driverName}");
        
        // Test 5: Increment/decrement should be consistent
        $cache->put('counter', 5);
        $this->assertEquals(8, $cache->increment('counter', 3),
            "Increment failed for {$driverName}");
        $this->assertEquals(6, $cache->decrement('counter', 2),
            "Decrement failed for {$driverName}");
        
        // Test 6: Flush should be consistent
        $cache->put('test1', 'value1');
        $cache->put('test2', 'value2');
        $cache->flush();
        $this->assertFalse($cache->has('test1'),
            "Flush failed for {$driverName}");
        $this->assertFalse($cache->has('test2'),
            "Flush failed for {$driverName}");
    }
}
```

### Configuration Files

```php
<?php
// config/cache.php
return [
    'default' => env('CACHE_DRIVER', 'redis'),
    'fallback' => env('CACHE_FALLBACK', 'file'),
    
    'stores' => [
        'redis' => [
            'driver' => 'redis',
            'connection' => 'cache',
        ],
        
        'file' => [
            'driver' => 'file',
            'path' => storage_path('framework/cache/data'),
        ],
        
        'memory' => [
            'driver' => 'memory',
        ],
    ],
];

// routes/api.php
use App\Http\Controllers\CacheController;
use App\Http\Controllers\NotificationController;

Route::prefix('cache')->group(function () {
    Route::get('/{key}', [CacheController::class, 'get']);
    Route::post('/', [CacheController::class, 'put']);
    Route::post('/remember', [CacheController::class, 'remember']);
    Route::post('/{key}/increment', [CacheController::class, 'increment']);
    Route::delete('/{key}', [CacheController::class, 'forget']);
    Route::delete('/', [CacheController::class, 'flush']);
});

Route::prefix('notifications')->group(function () {
    Route::post('/send', [NotificationController::class, 'send']);
    Route::get('/channels', [NotificationController::class, 'getChannels']);
    Route::post('/validate', [NotificationController::class, 'validateRecipient']);
});
```

## Summary: LSP Benefits in Laravel

### ✅ Perfect Substitution Achieved:

1. **Cache Drivers**: Redis, File, Memory - all work identically
2. **Notification Channels**: Email, SMS, Slack - consistent interface
3. **Testing**: Mock objects behave exactly like real implementations
4. **Configuration**: Switch implementations without code changes

### 🎯 Key LSP Patterns:

1. **Consistent Interface**: All implementations follow same contract
2. **Predictable Behavior**: No surprises when substituting implementations
3. **Same Preconditions**: All implementations accept same inputs
4. **Same Postconditions**: All implementations produce same outputs
5. **Exception Consistency**: All implementations handle errors the same way

### 🚀 Real-world Benefits:

- **Risk-free Substitution**: Swap implementations confidently
- **Easy Testing**: Mock objects work perfectly
- **Environment Flexibility**: Different implementations per environment
- **Performance Optimization**: Switch to faster implementations seamlessly
- **Backward Compatibility**: New implementations work with existing code

LSP ensures your Laravel applications are truly modular - any component can be swapped with another implementation without breaking anything!
