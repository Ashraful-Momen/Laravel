# Laravel Service Container & Service Provider - Interactive Guide

## ğŸ§© Service Container: The Heart of Laravel

Think of Laravel's Service Container as a powerful **key-value store** that manages all your application's dependencies.

### ğŸ’¡ The Core Concept

At its simplest, the Service Container works just like an array:

```php
// Simple array key-value
$array['key'] = $value;

// Laravel's container (simplified conceptual equivalent)
app()->bind('key', $value);
```

## ğŸš€ Quick Start Example

### Step 1: Create a Service
```bash
php artisan make:class Services/Logger
```

```php
// app/Services/Logger.php
namespace App\Services;

class Logger
{
    public function log($message)
    {
        return "LOG: " . $message;
    }
}
```

### Step 2: Bind it in Service Provider

```bash
php artisan make:provider LoggerServiceProvider
```

```php
// app/Providers/LoggerServiceProvider.php
namespace App\Providers;

use Illuminate\Support\ServiceProvider;
use App\Services\Logger;

class LoggerServiceProvider extends ServiceProvider
{
    public function register(): void
    {
        // Bind as singleton (same instance everywhere)
        $this->app->singleton(Logger::class, function ($app) {
            return new Logger();
        });
        
        // Or bind with custom name
        $this->app->bind('logger', function ($app) {
            return new Logger();
        });
    }
}
```

### Step 3: Register Provider

```php
// config/app.php
'providers' => [
    // ... other providers
    App\Providers\LoggerServiceProvider::class,
],
```

### Step 4: Use the Service

```php
// In Controller or Route
Route::get('/test-logger', function () {
    // Method 1: Using make()
    $logger = app()->make(Logger::class);
    
    // Method 2: Using helper
    $logger = app('logger');
    
    // Method 3: Dependency Injection
    return (new TestController())->index();
});

// Using Dependency Injection in Controller
class TestController extends Controller
{
    public function index(Logger $logger)
    {
        return response()->json([
            'message' => $logger->log('Hello from container!')
        ]);
    }
}
```

## ğŸ¯ Different Binding Methods

### 1. **Simple Binding** - New instance each time
```php
$this->app->bind(Logger::class, function ($app) {
    return new Logger();
});
```

### 2. **Singleton Binding** - Same instance everywhere
```php
$this->app->singleton(Logger::class, function ($app) {
    return new Logger();
});
```

### 3. **Instance Binding** - Bind existing object
```php
$logger = new Logger();
$this->app->instance(Logger::class, $logger);
```

### 4. **Interface Binding** - Bind interface to implementation
```php
// Create interface
// app/Contracts/LoggerInterface.php
namespace App\Contracts;

interface LoggerInterface
{
    public function log($message);
}

// Bind in provider
$this->app->bind(
    LoggerInterface::class,
    \App\Services\Logger::class
);

// Use with type-hinting
public function index(LoggerInterface $logger)
{
    // Works automatically!
}
```

## ğŸ§ª Practical Examples

### Example 1: Email Service with Configuration

```php
// app/Services/EmailService.php
namespace App\Services;

class EmailService
{
    private $fromEmail;
    
    public function __construct($fromEmail = null)
    {
        $this->fromEmail = $fromEmail ?? config('mail.from.address');
    }
    
    public function send($to, $subject)
    {
        return "Sending email from {$this->fromEmail} to {$to}";
    }
}

// In Service Provider
$this->app->singleton(EmailService::class, function ($app) {
    return new EmailService('custom@email.com');
});
```

### Example 2: Payment Gateway (Interface Example)

```php
// Interface
namespace App\Contracts;

interface PaymentGateway
{
    public function charge($amount);
}

// Stripe Implementation
namespace App\Services;

class StripePayment implements PaymentGateway
{
    public function charge($amount)
    {
        return "Charged \${$amount} via Stripe";
    }
}

// PayPal Implementation  
namespace App\Services;

class PayPalPayment implements PaymentGateway
{
    public function charge($amount)
    {
        return "Charged \${$amount} via PayPal";
    }
}

// Binding - Easy to switch!
$this->app->bind(PaymentGateway::class, StripePayment::class);
// Change to PayPal with one line:
// $this->app->bind(PaymentGateway::class, PayPalPayment::class);

// Usage in Controller
class PaymentController extends Controller
{
    public function checkout(PaymentGateway $payment)
    {
        // Automatically uses whichever implementation is bound
        return $payment->charge(100);
    }
}
```

## ğŸ“ Service Provider Structure

```php
namespace App\Providers;

use Illuminate\Support\ServiceProvider;

class CustomServiceProvider extends ServiceProvider
{
    // Register - Bind services to container
    public function register(): void
    {
        $this->app->singleton('my-service', function ($app) {
            return new MyService();
        });
    }
    
    // Boot - Run after all providers are registered
    public function boot(): void
    {
        // You can access other services here
        $service = $this->app->make('my-service');
        
        // Register routes, views, etc.
        $this->loadRoutesFrom(__DIR__.'/../routes/custom.php');
        $this->loadViewsFrom(__DIR__.'/../resources/views', 'custom');
    }
}
```

## ğŸ® Interactive Test Routes

Add these to your `routes/web.php` to test:

```php
// Test basic container
Route::get('/container-test', function () {
    // Bind a simple value
    app()->bind('greeting', function () {
        return 'Hello from Container!';
    });
    
    // Retrieve it
    return app('greeting');
});

// Test singleton vs bind
Route::get('/singleton-test', function () {
    // Singleton example
    app()->singleton('counter', function () {
        return ['count' => 0];
    });
    
    $counter = app('counter');
    $counter['count']++;
    
    $counter2 = app('counter');
    $counter2['count']++;
    
    return "Singleton count: " . $counter2['count']; // Will be 2 (same instance)
});

// Test interface binding
Route::get('/interface-test', function (App\Contracts\LoggerInterface $logger) {
    return $logger->log('Testing interface binding');
});
```

## ğŸ” How to Check Registered Services

```php
// See all bindings
Route::get('/debug-container', function () {
    // Method 1: Get container instance
    $container = app();
    
    // Method 2: See bound services (simplified)
    $bindings = [
        'Logger' => app()->bound(Logger::class),
        'PaymentGateway' => app()->bound(PaymentGateway::class),
        'EmailService' => app()->bound(EmailService::class),
    ];
    
    return response()->json($bindings);
});
```

## ğŸ“ Cheat Sheet

### **Binding Types:**
- `bind()` - New instance each time
- `singleton()` - Same instance everywhere
- `instance()` - Bind existing object
- `scoped()` - Same instance per request/lifetime

### **Resolution Methods:**
```php
// All do the same thing:
$service = app(Service::class);
$service = app()->make(Service::class);
$service = resolve(Service::class);
$service = $this->app->make(Service::class); // In service provider
```

### **Check if Service Exists:**
```php
app()->bound(Service::class); // true/false
app()->has(Service::class);   // true/false
```

## ğŸ Simple Project Structure

```
app/
â”œâ”€â”€ Contracts/
â”‚   â””â”€â”€ LoggerInterface.php
â”œâ”€â”€ Services/
â”‚   â”œâ”€â”€ Logger.php
â”‚   â”œâ”€â”€ EmailService.php
â”‚   â””â”€â”€ PaymentGateway.php
â”œâ”€â”€ Providers/
â”‚   â”œâ”€â”€ AppServiceProvider.php
â”‚   â””â”€â”€ LoggerServiceProvider.php
config/
â””â”€â”€ app.php (register providers here)
```

## ğŸ’¡ Pro Tips

1. **Use interfaces** for flexibility and testing
2. **Keep providers focused** - one provider per feature/module
3. **Use dependency injection** in controllers
4. **Lazy load services** when possible
5. **Test different bindings** to understand the difference

## ğŸš¨ Common Mistakes

```php
// âŒ DON'T - Creating new instances manually
$logger = new Logger(); // Hard to test, no container benefits

// âœ… DO - Use container
$logger = app(Logger::class);
// or use dependency injection
public function __construct(Logger $logger) { ... }
```

## ğŸ“š Next Steps

1. Try creating a simple service and binding it
2. Create an interface and two implementations
3. Switch implementations by changing one line in provider
4. Add a service provider for your feature
5. Experiment with singleton vs regular binding

**Remember:** The Service Container is just a smart registry that manages object creation for you. Service Providers are where you tell it how to create those objects!
