# PHPUnit Complete Testing Guide

## Table of Contents
1. [Introduction](#introduction)
2. [Installation](#installation)
3. [Writing Tests](#writing-tests)
4. [Configuration & Autoloading](#configuration--autoloading)
5. [Advanced Testing Concepts](#advanced-testing-concepts)
6. [Test Doubles & Mocking](#test-doubles--mocking)

---

## Introduction

### What is PHPUnit?
PHPUnit is a programmer-oriented testing framework for PHP. It's an instance of the xUnit architecture for unit testing frameworks.

### The AAA Pattern (Arrange-Act-Assert)
Every test should follow this structure:

- **Arrange**: Prepare the environment for testing (setup variables, objects, or methods)
- **Act**: Execute the function/method being tested
- **Assert**: Verify the result matches expectations

**Example:**
```php
<?php
use PHPUnit\Framework\TestCase;

class CheckoutTest extends TestCase
{
    public function testDiscountIsApplied(): void
    {
        // Arrange
        $cart = new Cart();
        $cart->addItem('T-shirt', 20.00);
        $cart->addItem('Mug', 5.00);
        $checkout = new Checkout($cart);

        // Act
        $total = $checkout->getTotal();

        // Assert
        $this->assertSame(22.50, $total);
    }
}
```

---

## Installation

### Method 1: Install PHPUnit (PHAR)
Download the PHAR file from: https://phar.phpunit.de/

```bash
# Switch PHP version if needed
sudo update-alternatives --config php

# Create alias for convenience
alias phpunit="php phpunit-12.3.15.phar"

# Check version
phpunit --version
```

### Method 2: Install PHPUnit (Composer) ⭐ Recommended
```bash
# Install PHPUnit as a dev dependency
composer require --dev phpunit/phpunit

# Check version
./vendor/bin/phpunit --version
# Output: PHPUnit 11.5.42 by Sebastian Bergmann and contributors.

# Create alias for easier access
alias phpunit='./vendor/bin/phpunit'

# View available options
./vendor/bin/phpunit --help
```

---

## Writing Tests

### Write Your First Test
Create a test file: `CodeTest/ExampleTest.php`

```php
<?php declare(strict_types=1);

use PHPUnit\Framework\TestCase;

final class ExampleTest extends TestCase
{
    public function testExampleIsTrue(): void
    {
        $this->assertTrue(true);
        $this->assertSame(1, 1); // Expected, Actual
    }
}
```

**Run the test:**
```bash
./vendor/bin/phpunit CodeTest/ExampleTest.php --color

# Output:
# .                                                  1 / 1 (100%)
# OK (1 test, 2 assertions)
```

### Test a Function
**File: `lib/addFunction.php`**
```php
<?php
declare(strict_types=1);

function addIntegers(int $a, int $b): int {
    return $a + $b;
}
```

**File: `CodeTest/TestAddition.php`**
```php
<?php
declare(strict_types=1);

use PHPUnit\Framework\TestCase;

require __DIR__ . '/../lib/addFunction.php';

final class TestAddition extends TestCase
{
    public function testAddTwoInteger(): void
    {
        $this->assertSame(5, addIntegers(2, 3));
    }
}
```

**Run test:**
```bash
./vendor/bin/phpunit CodeTest/TestAddition.php --color
```

**Failed Test Output Example:**
```
F                                                  1 / 1 (100%)

There was 1 failure:
1) TestAddition::testAddTwoInteger
Failed asserting that 4 is identical to 5.

FAILURES!
Tests: 1, Assertions: 1, Failures: 1.
```

### Multiple Test Methods
You can have multiple test methods in a single test class. Each method tests a specific function:

```php
final class CalculatorTest extends TestCase
{
    public function testAddition(): void
    {
        $this->assertSame(4, add(2, 2));
    }

    public function testSubtraction(): void
    {
        $this->assertSame(0, subtract(2, 2));
    }

    public function testMultiplication(): void
    {
        $this->assertSame(6, multiply(2, 3));
    }
}
```

### Testing Classes
**File: `src/Person.php`**
```php
<?php
declare(strict_types=1);

class Person
{
    private string $firstName;
    private string $lastName;

    public function getFirstName(): string
    {
        return $this->firstName;
    }

    public function getLastName(): string
    {
        return $this->lastName;
    }

    public function fullName(): string
    {
        return trim($this->firstName . " " . $this->lastName);
    }

    public function setFirstName(string $firstName): void
    {
        $this->firstName = $firstName;
    }

    public function setLastName(string $lastName): void
    {
        $this->lastName = $lastName;
    }
}
```

**File: `CodeTest/PersonTest.php`**
```php
<?php
declare(strict_types=1);

use PHPUnit\Framework\TestCase;

require_once __DIR__ . '/../src/Person.php';

final class PersonTest extends TestCase
{
    public function testFullName(): void
    {
        $person = new Person();
        $person->setFirstName('Adiha');
        $person->setLastName('Islam');

        $this->assertSame('Adiha Islam', $person->fullName());
    }
}
```

---

## Command-line Options

### Basic Commands
```bash
# Run specific test file
./vendor/bin/phpunit CodeTest/PersonTest.php

# Add color output
./vendor/bin/phpunit CodeTest/PersonTest.php --color

# Show detailed test documentation
./vendor/bin/phpunit CodeTest/PersonTest.php --color --testdox

# View all options
./vendor/bin/phpunit --help
```

### --testdox Output Examples

**Passed Test:**
```
Person
 ✔ Full name

OK (1 test, 1 assertion)
```

**Failed Test:**
```
Person
 ✘ Full name
   ┐
   ├ Failed asserting that two strings are identical.
   ┊ --- Expected
   ┊ +++ Actual
   ┊ @@ @@
   ┊ -'Adiha Isla'
   ┊ +'Adiha Islam'
   │
   │ /home/user/CodeTest/PersonTest.php:19
   ┴

FAILURES!
Tests: 1, Assertions: 1, Failures: 1.
```

### Running Specific Test Methods
```bash
# Run a specific test method
./vendor/bin/phpunit --filter testFullName CodeTest/PersonTest.php

# Run tests matching a pattern
./vendor/bin/phpunit --filter testAdd
```

### Marking Methods as Tests
Two ways to mark a method as a test:

**Method 1: Use `test` prefix (Recommended)**
```php
public function testSomething(): void
{
    // Test code
}
```

**Method 2: Use `@test` annotation**
```php
/**
 * @test
 */
public function itShouldDoSomething(): void
{
    // Test code
}
```

---

## Configuration & Autoloading

### The Bootstrap Script
The bootstrap file contains dependencies and setup code needed before running tests.

**File: `CodeTest/bootstrap.php`**
```php
<?php
require_once __DIR__ . '/../src/Person.php';
// Add other dependencies here
```

**Run with bootstrap:**
```bash
./vendor/bin/phpunit CodeTest/PersonTest.php --bootstrap CodeTest/bootstrap.php --color --testdox
```

### Custom Autoloading
Use `spl_autoload_register()` to automatically load class files:

**File: `CodeTest/bootstrap.php`**
```php
<?php
spl_autoload_register(
    static function (string $class): void {
        // Convert Foo\Bar => Foo/Bar.php
        $file = __DIR__ . '/../src/' . str_replace('\\', '/', $class) . '.php';
        if (file_exists($file)) {
            require_once $file;
        }
    }
);
```

Now you can remove individual `require` statements from test files.

### Composer Autoloading ⭐ Best Practice

#### PSR-4 Autoloading
**Update `composer.json`:**
```json
{
    "require-dev": {
        "phpunit/phpunit": "^11.5"
    },
    "autoload": {
        "psr-4": {
            "App\\": "src/"
        }
    }
}
```

**Update `src/Person.php` with namespace:**
```php
<?php
declare(strict_types=1);

namespace App;

class Person
{
    // ... class code
}
```

**Update test file:**
```php
<?php
declare(strict_types=1);

use PHPUnit\Framework\TestCase;
use App\Person;

final class PersonTest extends TestCase
{
    // ... test code
}
```

**Generate autoload files:**
```bash
composer dump-autoload
```

**Run test with Composer autoloader:**
```bash
./vendor/bin/phpunit CodeTest/PersonTest.php --bootstrap vendor/autoload.php --color --testdox
```

#### Autoloading Files
For standalone functions, add them to `composer.json`:

```json
{
    "autoload": {
        "psr-4": {
            "App\\": "src/"
        },
        "files": [
            "lib/addFunction.php"
        ]
    }
}
```

Then run:
```bash
composer dump-autoload
./vendor/bin/phpunit CodeTest/TestAddition.php --bootstrap vendor/autoload.php --color --testdox
```

### Configuration File

Create `phpunit.xml` in your project root to avoid repeating command-line options:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<phpunit xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:noNamespaceSchemaLocation="vendor/phpunit/phpunit/phpunit.xsd"
         bootstrap="vendor/autoload.php"
         colors="true"
         executionOrder="depends,defects"
         beStrictAboutOutputDuringTests="true"
         failOnRisky="true"
         failOnWarning="true">
    <testsuites>
        <testsuite name="default">
            <directory>CodeTest</directory>
        </testsuite>
    </testsuites>

    <source>
        <include>
            <directory>src</directory>
        </include>
    </source>
</phpunit>
```

**Now you can simply run:**
```bash
./vendor/bin/phpunit
# Or with alias:
phpunit
```

### Test Suites
Organize tests into multiple suites:

```xml
<testsuites>
    <testsuite name="unit">
        <directory>tests/Unit</directory>
    </testsuite>
    <testsuite name="integration">
        <directory>tests/Integration</directory>
    </testsuite>
    <testsuite name="feature">
        <directory>tests/Feature</directory>
    </testsuite>
</testsuites>
```

**Run specific suite:**
```bash
./vendor/bin/phpunit --testsuite unit
./vendor/bin/phpunit --testsuite integration
```

---

## Advanced Testing Concepts

### Incomplete Tests
Mark tests that are not yet implemented:

```php
public function testSomethingComplex(): void
{
    $this->markTestIncomplete('This test needs to be implemented');
}
```

**Output:**
```
I                                                  1 / 1 (100%)

There was 1 incomplete test:
1) MyTest::testSomethingComplex
This test needs to be implemented
```

### Errors vs Failures

**Error:** PHP error or exception (code is broken)
```php
public function testDivision(): void
{
    $result = 10 / 0; // PHP Warning/Error
    $this->assertSame(5, $result);
}
```

**Failure:** Assertion fails (logic is wrong)
```php
public function testAddition(): void
{
    $this->assertSame(5, 2 + 2); // Assertion fails
}
```

### Data Providers
Test the same method with multiple sets of data:

```php
/**
 * @dataProvider additionProvider
 */
public function testAdd(int $a, int $b, int $expected): void
{
    $this->assertSame($expected, add($a, $b));
}

public static function additionProvider(): array
{
    return [
        'positive numbers' => [2, 3, 5],
        'negative numbers' => [-2, -3, -5],
        'mixed numbers' => [2, -3, -1],
        'with zero' => [0, 5, 5],
    ];
}
```

**Output:**
```
Addition
 ✔ Add with data set "positive numbers"
 ✔ Add with data set "negative numbers"
 ✔ Add with data set "mixed numbers"
 ✔ Add with data set "with zero"
```

### Multiple Assertions
You can have multiple assertions in one test:

```php
public function testPersonDetails(): void
{
    $person = new Person();
    $person->setFirstName('John');
    $person->setLastName('Doe');
    $person->setAge(30);

    $this->assertSame('John', $person->getFirstName());
    $this->assertSame('Doe', $person->getLastName());
    $this->assertSame(30, $person->getAge());
    $this->assertSame('John Doe', $person->fullName());
}
```

**Best Practice:** Keep tests focused. If testing multiple aspects, consider splitting into separate test methods.

### Test Dependencies
Make one test depend on another:

```php
public function testCreateUser(): User
{
    $user = new User('john@example.com');
    $this->assertSame('john@example.com', $user->getEmail());
    return $user;
}

/**
 * @depends testCreateUser
 */
public function testUpdateUser(User $user): void
{
    $user->setEmail('jane@example.com');
    $this->assertSame('jane@example.com', $user->getEmail());
}
```

**Note:** If `testCreateUser` fails, `testUpdateUser` will be skipped.

### Fixtures
Setup and teardown methods run before/after tests:

```php
final class DatabaseTest extends TestCase
{
    private PDO $pdo;

    // Runs before EACH test method
    protected function setUp(): void
    {
        $this->pdo = new PDO('sqlite::memory:');
        $this->pdo->exec('CREATE TABLE users (id INT, name TEXT)');
    }

    // Runs after EACH test method
    protected function tearDown(): void
    {
        $this->pdo = null;
    }

    // Runs ONCE before all tests in the class
    public static function setUpBeforeClass(): void
    {
        // e.g., create test database
    }

    // Runs ONCE after all tests in the class
    public static function tearDownAfterClass(): void
    {
        // e.g., delete test database
    }

    public function testInsertUser(): void
    {
        $this->pdo->exec("INSERT INTO users VALUES (1, 'John')");
        $stmt = $this->pdo->query("SELECT name FROM users WHERE id = 1");
        $name = $stmt->fetchColumn();
        
        $this->assertSame('John', $name);
    }
}
```

**Fixture Methods:**
- `setUp()` - Before each test
- `tearDown()` - After each test
- `setUpBeforeClass()` - Once before all tests
- `tearDownAfterClass()` - Once after all tests

### Expecting Exceptions
Test that code throws expected exceptions:

```php
public function testDivisionByZero(): void
{
    $this->expectException(DivisionByZeroError::class);
    $this->expectExceptionMessage('Division by zero');
    
    $calculator = new Calculator();
    $calculator->divide(10, 0);
}
```

**Alternative syntax:**
```php
public function testInvalidEmail(): void
{
    $this->expectException(InvalidArgumentException::class);
    
    $user = new User('invalid-email');
}
```

---

## Test Doubles & Mocking

### Test Doubles
Test doubles are objects that replace real dependencies in tests. Types:
- **Dummy**: Passed but never used
- **Stub**: Returns predefined values
- **Mock**: Verifies method calls
- **Fake**: Simplified working implementation
- **Spy**: Records method calls

### Dependency Injection
Make classes testable by injecting dependencies:

**Bad (Hard to test):**
```php
class UserService
{
    public function getUser(int $id): User
    {
        $db = new Database(); // Hard-coded dependency
        return $db->find($id);
    }
}
```

**Good (Easy to test):**
```php
class UserService
{
    private Database $db;

    public function __construct(Database $db)
    {
        $this->db = $db; // Injected dependency
    }

    public function getUser(int $id): User
    {
        return $this->db->find($id);
    }
}
```

### Stubs
Stubs return predefined values without real implementation:

```php
public function testGetUserReturnsUser(): void
{
    // Create a stub for Database
    $dbStub = $this->createStub(Database::class);
    
    // Configure the stub
    $dbStub->method('find')
           ->willReturn(new User(1, 'John Doe'));
    
    // Inject stub into service
    $service = new UserService($dbStub);
    
    // Test
    $user = $service->getUser(1);
    $this->assertSame('John Doe', $user->getName());
}
```

**Stub with different return values:**
```php
$stub = $this->createStub(PaymentGateway::class);

$stub->method('processPayment')
     ->willReturnOnConsecutiveCalls(true, false, true);

$this->assertTrue($gateway->processPayment());  // First call
$this->assertFalse($gateway->processPayment()); // Second call
$this->assertTrue($gateway->processPayment());  // Third call
```

**Stub with arguments:**
```php
$stub = $this->createStub(EmailService::class);

$stub->method('send')
     ->with('test@example.com', 'Subject')
     ->willReturn(true);
```

### Mocks
Mocks verify that methods are called with expected parameters:

```php
public function testSendEmailIsCalled(): void
{
    // Create a mock
    $emailMock = $this->createMock(EmailService::class);
    
    // Set expectations
    $emailMock->expects($this->once())
              ->method('send')
              ->with(
                  $this->equalTo('user@example.com'),
                  $this->equalTo('Welcome!'),
                  $this->stringContains('Hello')
              )
              ->willReturn(true);
    
    // Inject mock
    $service = new UserService($emailMock);
    
    // Execute
    $service->registerUser('user@example.com');
    
    // Verification happens automatically
}
```

**Mock expectations:**
```php
// Called exactly once
$mock->expects($this->once())

// Called exactly N times
$mock->expects($this->exactly(3))

// Never called
$mock->expects($this->never())

// Called at least once
$mock->expects($this->atLeastOnce())

// Called at specific invocation
$mock->expects($this->at(0)) // First call
```

**Complex mock example:**
```php
public function testOrderProcess(): void
{
    $paymentMock = $this->createMock(PaymentProcessor::class);
    $emailMock = $this->createMock(EmailService::class);
    $loggerMock = $this->createMock(Logger::class);
    
    // Payment should be processed once
    $paymentMock->expects($this->once())
                ->method('charge')
                ->with($this->equalTo(100))
                ->willReturn(true);
    
    // Email should be sent once after payment
    $emailMock->expects($this->once())
              ->method('sendConfirmation')
              ->with($this->stringContains('@'));
    
    // Logger should record the transaction
    $loggerMock->expects($this->once())
               ->method('log')
               ->with($this->stringContains('Order completed'));
    
    $orderService = new OrderService($paymentMock, $emailMock, $loggerMock);
    $result = $orderService->processOrder(100, 'user@example.com');
    
    $this->assertTrue($result);
}
```

---

## Quick Reference

### Common Assertions
```php
$this->assertTrue($condition);
$this->assertFalse($condition);
$this->assertSame($expected, $actual);      // Strict comparison (===)
$this->assertEquals($expected, $actual);    // Loose comparison (==)
$this->assertNull($value);
$this->assertEmpty($value);
$this->assertCount(3, $array);
$this->assertStringContainsString('substring', $string);
$this->assertArrayHasKey('key', $array);
$this->assertInstanceOf(ClassName::class, $object);
```

### Running Tests
```bash
# Run all tests
phpunit

# Run specific file
phpunit tests/UserTest.php

# Run specific method
phpunit --filter testUserCanLogin

# Run with coverage
phpunit --coverage-html coverage/

# Run specific suite
phpunit --testsuite unit

# Stop on first failure
phpunit --stop-on-failure
```

### Best Practices
✅ **DO:**
- Use descriptive test method names
- Follow the AAA pattern
- Test one concept per test method
- Use data providers for similar tests
- Mock external dependencies
- Keep tests fast
- Use meaningful assertion messages

❌ **DON'T:**
- Test private methods directly
- Have dependencies between tests
- Use real databases or APIs
- Write tests that depend on execution order
- Mix unit and integration tests

---

## Additional Resources
- Official Documentation: https://phpunit.de/documentation.html
- PHPUnit GitHub: https://github.com/sebastianbergmann/phpunit
- Composer Autoloading: https://getcomposer.org/doc/04-schema.md#autoload
