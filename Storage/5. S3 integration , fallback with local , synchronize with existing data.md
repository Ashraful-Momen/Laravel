# Step-by-Step S3 Integration with Fallback for Laravel Docker Swarm

## Phase 1: Prepare S3 Configuration (No Downtime)

### Step 1: Add S3 Credentials to .env
Add these to your `.env` file:

```env
# S3 Compatible Storage
S3_DRIVER=s3
S3_KEY=your_access_key_here
S3_SECRET=your_secret_key_here
S3_REGION=us-east-1
S3_BUCKET=your-bucket-name
S3_ENDPOINT=https://your-s3-provider-endpoint.com
S3_USE_PATH_STYLE=true
S3_URL=https://your-s3-provider-endpoint.com/your-bucket-name

# Fallback configuration
STORAGE_PRIMARY=s3
STORAGE_FALLBACK=local
STORAGE_SYNC_ENABLED=true
```

### Step 2: Install S3 Package
SSH into your server and run:

```bash
# Enter the app container
docker exec -it $(docker ps -q -f name=laravel_app) bash

# Install the S3 package
composer require league/flysystem-aws-s3-v3 "^3.0"

# Exit container
exit
```

## Phase 2: Configure Laravel Filesystem

### Step 3: Update config/filesystems.php
Create or update the file with S3 configuration:

```php
<?php

return [
    'default' => env('FILESYSTEM_DISK', 'local'),
    
    'disks' => [
        'local' => [
            'driver' => 'local',
            'root' => storage_path('app'),
            'throw' => false,
        ],

        'public' => [
            'driver' => 'local',
            'root' => storage_path('app/public'),
            'url' => env('APP_URL').'/storage',
            'visibility' => 'public',
            'throw' => false,
        ],

        's3' => [
            'driver' => 's3',
            'key' => env('S3_KEY'),
            'secret' => env('S3_SECRET'),
            'region' => env('S3_REGION'),
            'bucket' => env('S3_BUCKET'),
            'url' => env('S3_URL'),
            'endpoint' => env('S3_ENDPOINT'),
            'use_path_style_endpoint' => env('S3_USE_PATH_STYLE', false),
            'throw' => false,
            'visibility' => 'public',
        ],

        's3-public' => [
            'driver' => 's3',
            'key' => env('S3_KEY'),
            'secret' => env('S3_SECRET'),
            'region' => env('S3_REGION'),
            'bucket' => env('S3_BUCKET'),
            'url' => env('S3_URL'),
            'endpoint' => env('S3_ENDPOINT'),
            'use_path_style_endpoint' => env('S3_USE_PATH_STYLE', false),
            'throw' => false,
            'visibility' => 'public',
            'root' => 'public',
        ],

        's3-storage' => [
            'driver' => 's3',
            'key' => env('S3_KEY'),
            'secret' => env('S3_SECRET'),
            'region' => env('S3_REGION'),
            'bucket' => env('S3_BUCKET'),
            'url' => env('S3_URL'),
            'endpoint' => env('S3_ENDPOINT'),
            'use_path_style_endpoint' => env('S3_USE_PATH_STYLE', false),
            'throw' => false,
            'visibility' => 'public',
            'root' => 'storage',
        ],
    ],
];
```

### Step 4: Create Fallback Storage Service
Create `app/Services/FallbackStorageService.php`:

```php
<?php

namespace App\Services;

use Illuminate\Support\Facades\Storage;
use Illuminate\Support\Facades\Log;
use Exception;

class FallbackStorageService
{
    protected $primaryDisk;
    protected $fallbackDisk;
    protected $syncEnabled;

    public function __construct()
    {
        $this->primaryDisk = env('STORAGE_PRIMARY', 's3');
        $this->fallbackDisk = env('STORAGE_FALLBACK', 'local');
        $this->syncEnabled = env('STORAGE_SYNC_ENABLED', true);
    }

    /**
     * Store file with automatic fallback
     */
    public function put($path, $contents, $options = [])
    {
        $stored = false;
        $result = null;

        // Try primary storage (S3)
        try {
            $result = Storage::disk($this->primaryDisk)->put($path, $contents, $options);
            $stored = true;
            
            // Sync to fallback if enabled
            if ($this->syncEnabled) {
                try {
                    Storage::disk($this->fallbackDisk)->put($path, $contents, $options);
                } catch (Exception $e) {
                    Log::warning('Failed to sync to fallback storage: ' . $e->getMessage());
                }
            }
        } catch (Exception $e) {
            Log::error('Primary storage failed: ' . $e->getMessage());
            
            // Fallback to local storage
            try {
                $result = Storage::disk($this->fallbackDisk)->put($path, $contents, $options);
                $stored = true;
                Log::info('File stored in fallback storage: ' . $path);
            } catch (Exception $e) {
                Log::error('Fallback storage also failed: ' . $e->getMessage());
                throw $e;
            }
        }

        return $result;
    }

    /**
     * Get file with automatic fallback
     */
    public function get($path)
    {
        // Try primary storage first
        try {
            if (Storage::disk($this->primaryDisk)->exists($path)) {
                return Storage::disk($this->primaryDisk)->get($path);
            }
        } catch (Exception $e) {
            Log::warning('Primary storage read failed: ' . $e->getMessage());
        }

        // Try fallback storage
        try {
            if (Storage::disk($this->fallbackDisk)->exists($path)) {
                Log::info('File retrieved from fallback storage: ' . $path);
                return Storage::disk($this->fallbackDisk)->get($path);
            }
        } catch (Exception $e) {
            Log::error('Fallback storage read failed: ' . $e->getMessage());
        }

        throw new Exception('File not found in any storage: ' . $path);
    }

    /**
     * Get URL with fallback
     */
    public function url($path)
    {
        try {
            // Check if file exists in primary
            if (Storage::disk($this->primaryDisk)->exists($path)) {
                return Storage::disk($this->primaryDisk)->url($path);
            }
        } catch (Exception $e) {
            Log::warning('Primary storage URL generation failed: ' . $e->getMessage());
        }

        // Fallback to local URL
        return Storage::disk($this->fallbackDisk)->url($path);
    }

    /**
     * Delete from both storages
     */
    public function delete($path)
    {
        $deleted = false;

        try {
            Storage::disk($this->primaryDisk)->delete($path);
            $deleted = true;
        } catch (Exception $e) {
            Log::warning('Failed to delete from primary storage: ' . $e->getMessage());
        }

        try {
            Storage::disk($this->fallbackDisk)->delete($path);
            $deleted = true;
        } catch (Exception $e) {
            Log::warning('Failed to delete from fallback storage: ' . $e->getMessage());
        }

        return $deleted;
    }

    /**
     * Check if file exists in any storage
     */
    public function exists($path)
    {
        try {
            if (Storage::disk($this->primaryDisk)->exists($path)) {
                return true;
            }
        } catch (Exception $e) {
            Log::warning('Primary storage exists check failed: ' . $e->getMessage());
        }

        try {
            return Storage::disk($this->fallbackDisk)->exists($path);
        } catch (Exception $e) {
            Log::error('Fallback storage exists check failed: ' . $e->getMessage());
            return false;
        }
    }
}
```

### Step 5: Create Storage Facade
Create `app/Facades/FallbackStorage.php`:

```php
<?php

namespace App\Facades;

use Illuminate\Support\Facades\Facade;

class FallbackStorage extends Facade
{
    protected static function getFacadeAccessor()
    {
        return 'fallback-storage';
    }
}
```

### Step 6: Register Service Provider
Create `app/Providers/FallbackStorageServiceProvider.php`:

```php
<?php

namespace App\Providers;

use Illuminate\Support\ServiceProvider;
use App\Services\FallbackStorageService;

class FallbackStorageServiceProvider extends ServiceProvider
{
    public function register()
    {
        $this->app->singleton('fallback-storage', function ($app) {
            return new FallbackStorageService();
        });
    }

    public function boot()
    {
        //
    }
}
```

Add to `config/app.php`:
```php
'providers' => [
    // ... other providers
    App\Providers\FallbackStorageServiceProvider::class,
],

'aliases' => [
    // ... other aliases
    'FallbackStorage' => App\Facades\FallbackStorage::class,
],
```

## Phase 3: Update Dockerfile for S3 Tools

### Step 7: Create New Dockerfile
Create `Dockerfile.s3`:

```dockerfile
# Use PHP 8.3 FPM image
FROM php:8.3-fpm

# Set working directory
WORKDIR /var/www/html

# Install system dependencies including AWS CLI and rclone
RUN apt-get update && apt-get install -y \
    build-essential \
    libpng-dev \
    libjpeg62-turbo-dev \
    libfreetype6-dev \
    libzip-dev \
    libicu-dev \
    zip \
    unzip \
    git \
    curl \
    libonig-dev \
    libxml2-dev \
    libpq-dev \
    libssl-dev \
    pkg-config \
    default-mysql-client \
    python3 \
    python3-pip \
    && apt-get clean \
    && rm -rf /var/lib/apt/lists/*

# Install AWS CLI
RUN pip3 install --upgrade awscli

# Install rclone
RUN curl https://rclone.org/install.sh | bash

# Install PHP extensions
RUN docker-php-ext-configure gd --with-freetype --with-jpeg \
    && docker-php-ext-install -j$(nproc) \
    pdo \
    pdo_mysql \
    pdo_pgsql \
    mbstring \
    zip \
    exif \
    pcntl \
    gd \
    xml \
    bcmath \
    soap \
    intl \
    mysqli \
    opcache

# Install Redis extension via PECL
RUN pecl install redis && docker-php-ext-enable redis

# Install Composer
COPY --from=composer:latest /usr/bin/composer /usr/bin/composer

# Copy PHP configuration
COPY ./docker/php/local.ini /usr/local/etc/php/conf.d/local.ini

# Create user for Laravel application
RUN groupadd -g 1000 www \
    && useradd -u 1000 -ms /bin/bash -g www www

# Copy the entire app
COPY . .

# Install composer dependencies
USER root
RUN composer install --no-dev --optimize-autoloader --no-interaction

# Set permissions
RUN chown -R www:www /var/www/html && \
    chmod -R 755 storage bootstrap/cache

# Create sync script
COPY docker/scripts/sync-to-s3.sh /usr/local/bin/sync-to-s3
RUN chmod +x /usr/local/bin/sync-to-s3

# Switch to non-root user
USER www

# Expose port 9000 for PHP-FPM
EXPOSE 9000

# Start PHP-FPM server
CMD ["php-fpm"]
```

### Step 8: Create Sync Script
Create `docker/scripts/sync-to-s3.sh`:

```bash
#!/bin/bash

# Load environment variables
source /var/www/html/.env

# Configure AWS CLI for S3-compatible storage
aws configure set aws_access_key_id $S3_KEY
aws configure set aws_secret_access_key $S3_SECRET
aws configure set default.region $S3_REGION

# Sync public files to S3
echo "Syncing public files to S3..."
aws s3 sync /var/www/html/public/uploads \
    s3://$S3_BUCKET/public/ \
    --endpoint-url $S3_ENDPOINT \
    --acl public-read \
    --exclude "*.gitignore" \
    --exclude ".DS_Store"

# Sync storage files to S3
echo "Syncing storage files to S3..."
aws s3 sync /var/www/html/storage/app/public \
    s3://$S3_BUCKET/storage/ \
    --endpoint-url $S3_ENDPOINT \
    --acl public-read \
    --exclude "*.gitignore" \
    --exclude ".DS_Store"

echo "Sync completed!"
```

## Phase 4: Update Nginx Configuration

### Step 9: Create Enhanced Nginx Config
Create `docker/nginx/default-s3.conf`:

```nginx
upstream php-fpm {
    server app:9000;
}

server {
    listen 80;
    server_name _;
    root /var/www/html/public;
    index index.php index.html;

    client_max_body_size 100M;

    # Logging
    access_log /var/log/nginx/access.log;
    error_log /var/log/nginx/error.log;

    # Try to serve from S3 first, then local for uploads
    location ~ ^/uploads/(.*)$ {
        # First, try local file
        try_files $uri @s3_uploads;
    }

    location @s3_uploads {
        resolver 8.8.8.8 8.8.4.4 valid=300s;
        resolver_timeout 5s;
        
        # Replace with your S3 endpoint and bucket
        set $s3_bucket "your-bucket-name";
        set $s3_endpoint "your-s3-provider-endpoint.com";
        
        proxy_pass https://$s3_endpoint/$s3_bucket/public/$1;
        proxy_set_header Host $s3_endpoint;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # Cache settings
        proxy_cache_valid 200 302 1h;
        proxy_cache_valid 404 1m;
        proxy_cache_bypass $http_cache_control;
        add_header X-Cache-Status $upstream_cache_status;
        
        # If S3 fails, serve local file
        proxy_intercept_errors on;
        error_page 404 500 502 503 504 = @local_fallback;
    }

    # Try to serve from S3 first, then local for storage
    location ~ ^/storage/(.*)$ {
        try_files $uri @s3_storage;
    }

    location @s3_storage {
        resolver 8.8.8.8 8.8.4.4 valid=300s;
        resolver_timeout 5s;
        
        set $s3_bucket "your-bucket-name";
        set $s3_endpoint "your-s3-provider-endpoint.com";
        
        proxy_pass https://$s3_endpoint/$s3_bucket/storage/$1;
        proxy_set_header Host $s3_endpoint;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # Cache settings
        proxy_cache_valid 200 302 1h;
        proxy_cache_valid 404 1m;
        proxy_cache_bypass $http_cache_control;
        add_header X-Cache-Status $upstream_cache_status;
        
        # If S3 fails, serve local file
        proxy_intercept_errors on;
        error_page 404 500 502 503 504 = @local_fallback;
    }

    location @local_fallback {
        root /var/www/html/public;
        try_files $uri =404;
        add_header X-Served-From "local-fallback";
    }

    # PHP processing
    location ~ \.php$ {
        try_files $uri =404;
        fastcgi_split_path_info ^(.+\.php)(/.+)$;
        fastcgi_pass php-fpm;
        fastcgi_index index.php;
        include fastcgi_params;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        fastcgi_param PATH_INFO $fastcgi_path_info;
        fastcgi_buffer_size 128k;
        fastcgi_buffers 256 16k;
        fastcgi_busy_buffers_size 256k;
    }

    location / {
        try_files $uri $uri/ /index.php?$query_string;
        gzip_static on;
    }

    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
}
```

## Phase 5: Deploy Updates

### Step 10: Build and Deploy New Image

```bash
# 1. Build new Docker image with S3 support
docker build -f Dockerfile.s3 -t instasure-dockerized_app:s3-latest .

# 2. Update the stack file to use new image
sed -i 's/instasure-dockerized_app:latest/instasure-dockerized_app:s3-latest/g' docker-stack.yml

# 3. Update Nginx configuration in stack
# Edit docker-stack.yml and change:
# - /home/ashraful/gitlab_project/instasure-dockerized/docker/nginx/default.conf
# to:
# - /home/ashraful/gitlab_project/instasure-dockerized/docker/nginx/default-s3.conf

# 4. Deploy the updated stack
docker stack deploy -c docker-stack.yml laravel
```

### Step 11: Initial Data Sync

```bash
# 1. Get the container ID of the app service
APP_CONTAINER=$(docker ps -q -f name=laravel_app)

# 2. Run the sync script
docker exec -it $APP_CONTAINER /usr/local/bin/sync-to-s3

# 3. Verify sync
docker exec -it $APP_CONTAINER aws s3 ls s3://your-bucket-name/ --endpoint-url https://your-s3-endpoint.com
```

## Phase 6: Testing and Verification

### Step 12: Create Test Controller
Create `app/Http/Controllers/StorageTestController.php`:

```php
<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use App\Facades\FallbackStorage;
use Illuminate\Support\Facades\Log;

class StorageTestController extends Controller
{
    public function testUpload(Request $request)
    {
        try {
            if ($request->hasFile('file')) {
                $file = $request->file('file');
                $path = 'uploads/' . time() . '_' . $file->getClientOriginalName();
                
                // Use fallback storage
                $result = FallbackStorage::put($path, file_get_contents($file->getRealPath()));
                
                return response()->json([
                    'success' => true,
                    'path' => $path,
                    'url' => FallbackStorage::url($path)
                ]);
            }
        } catch (\Exception $e) {
            Log::error('Upload failed: ' . $e->getMessage());
            return response()->json([
                'success' => false,
                'error' => $e->getMessage()
            ], 500);
        }
    }

    public function testRead($filename)
    {
        try {
            $path = 'uploads/' . $filename;
            
            if (FallbackStorage::exists($path)) {
                $content = FallbackStorage::get($path);
                return response()->json([
                    'success' => true,
                    'exists' => true,
                    'size' => strlen($content),
                    'url' => FallbackStorage::url($path)
                ]);
            }
            
            return response()->json([
                'success' => false,
                'exists' => false
            ], 404);
        } catch (\Exception $e) {
            return response()->json([
                'success' => false,
                'error' => $e->getMessage()
            ], 500);
        }
    }

    public function healthCheck()
    {
        $s3Status = 'offline';
        $localStatus = 'offline';
        
        try {
            \Storage::disk('s3')->exists('health-check.txt');
            $s3Status = 'online';
        } catch (\Exception $e) {
            Log::warning('S3 health check failed: ' . $e->getMessage());
        }
        
        try {
            \Storage::disk('local')->exists('health-check.txt');
            $localStatus = 'online';
        } catch (\Exception $e) {
            Log::error('Local storage health check failed: ' . $e->getMessage());
        }
        
        return response()->json([
            's3' => $s3Status,
            'local' => $localStatus,
            'primary' => env('STORAGE_PRIMARY'),
            'fallback' => env('STORAGE_FALLBACK')
        ]);
    }
}
```

Add routes in `routes/web.php`:
```php
Route::post('/test/upload', [StorageTestController::class, 'testUpload']);
Route::get('/test/read/{filename}', [StorageTestController::class, 'testRead']);
Route::get('/test/storage-health', [StorageTestController::class, 'healthCheck']);
```

## Phase 7: Monitoring and Maintenance

### Step 13: Create Monitoring Script
Create `docker/scripts/monitor-storage.sh`:

```bash
#!/bin/bash

# Check S3 connectivity
check_s3() {
    aws s3 ls s3://$S3_BUCKET --endpoint-url $S3_ENDPOINT > /dev/null 2>&1
    if [ $? -eq 0 ]; then
        echo "S3: Connected"
        return 0
    else
        echo "S3: Failed"
        return 1
    fi
}

# Check local storage
check_local() {
    if [ -d "/var/www/html/storage/app/public" ]; then
        echo "Local: Available"
        return 0
    else
        echo "Local: Failed"
        return 1
    fi
}

# Main monitoring loop
while true; do
    echo "=== Storage Health Check ==="
    date
    check_s3
    S3_STATUS=$?
    check_local
    LOCAL_STATUS=$?
    
    if [ $S3_STATUS -ne 0 ] && [ $LOCAL_STATUS -eq 0 ]; then
        echo "WARNING: Running on fallback storage only!"
        # Send alert (email, Slack, etc.)
    fi
    
    echo "=========================="
    sleep 300  # Check every 5 minutes
done
```

### Step 14: Create Sync Cron Job
Add to your app container or create a separate cron service:

```bash
# Add to crontab
*/30 * * * * /usr/local/bin/sync-to-s3 >> /var/log/s3-sync.log 2>&1
```

## Phase 8: Application Code Updates

### Step 15: Update File Upload Logic
For existing upload code, update to use FallbackStorage:

```php
// Before:
Storage::disk('public')->put($path, $contents);

// After:
use App\Facades\FallbackStorage;
FallbackStorage::put($path, $contents);
```

Create a helper function in `app/helpers.php`:
```php
<?php

if (!function_exists('storage_url')) {
    function storage_url($path) {
        return app('fallback-storage')->url($path);
    }
}
```

Add to `composer.json`:
```json
"autoload": {
    "files": [
        "app/helpers.php"
    ]
}
```

Run `composer dump-autoload`.

## Rollback Plan

If issues occur, you can quickly rollback:

```bash
# 1. Switch back to old image
docker service update laravel_app --image instasure-dockerized_app:latest

# 2. Update .env to disable S3
# STORAGE_PRIMARY=local
# STORAGE_FALLBACK=local

# 3. Restart services
docker service update laravel_app --force
```

## Verification Checklist

- [ ] S3 credentials configured in .env
- [ ] Composer package installed
- [ ] FallbackStorageService created and registered
- [ ] New Docker image built with S3 tools
- [ ] Nginx configuration updated
- [ ] Initial data synced to S3
- [ ] Test upload working
- [ ] Fallback mechanism verified
- [ ] Monitoring script running
- [ ] Cron job for periodic sync set up

## Troubleshooting

1. **S3 Connection Failed:**
   ```bash
   docker exec -it $(docker ps -q -f name=laravel_app) bash
   aws s3 ls --endpoint-url $S3_ENDPOINT
   ```

2. **Check Logs:**
   ```bash
   docker service logs laravel_app --tail 100
   docker service logs laravel_nginx --tail 100
   ```

3. **Clear Cache:**
   ```bash
   docker exec -it $(docker ps -q -f name=laravel_app) php artisan config:clear
   docker exec -it $(docker ps -q -f name=laravel_app) php artisan cache:clear
   ```

4. **Test S3 Directly:**
   ```bash
   curl -I https://your-s3-endpoint.com/your-bucket-name/test.txt
   ```
