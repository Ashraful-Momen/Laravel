
## 1. Create a Storage Service Class

```php
<?php
// app/Services/StorageService.php

namespace App\Services;

use Illuminate\Support\Facades\Storage;
use Illuminate\Support\Facades\Log;
use Aws\S3\Exception\S3Exception;
use Exception;

class StorageService
{
    protected $primaryDisk;
    protected $fallbackDisk;
    protected $syncEnabled;
    protected $autoRetry;
    protected $maxRetries;
    protected $isS3Available;

    public function __construct()
    {
        $config = config('filesystems.storage_config');
        $this->primaryDisk = $config['primary_disk'];
        $this->fallbackDisk = $config['fallback_disk'];
        $this->syncEnabled = $config['sync_enabled'];
        $this->autoRetry = $config['auto_retry'];
        $this->maxRetries = $config['max_retries'];
        $this->isS3Available = $this->checkS3Connection();
    }

    /**
     * Check S3 connection
     */
    protected function checkS3Connection(): bool
    {
        try {
            Storage::disk('s3')->exists('connection-test.txt');
            return true;
        } catch (S3Exception $e) {
            Log::warning('S3 connection failed: ' . $e->getMessage());
            return false;
        } catch (Exception $e) {
            Log::error('Storage connection check error: ' . $e->getMessage());
            return false;
        }
    }

    /**
     * Get active disk based on availability
     */
    protected function getActiveDisk(): string
    {
        return $this->isS3Available ? $this->primaryDisk : $this->fallbackDisk;
    }

    /**
     * Store file with automatic fallback
     */
    public function store(string $path, $contents, array $options = []): bool
    {
        $activeDisk = $this->getActiveDisk();
        $retryCount = 0;

        while ($retryCount <= $this->maxRetries) {
            try {
                $success = Storage::disk($activeDisk)->put($path, $contents, $options);
                
                if ($success && $this->syncEnabled && $activeDisk === $this->fallbackDisk) {
                    $this->queueForSync($path);
                }
                
                return $success;
            } catch (Exception $e) {
                $retryCount++;
                
                if ($retryCount > $this->maxRetries || !$this->autoRetry) {
                    Log::error("Failed to store file after {$retryCount} attempts: " . $e->getMessage());
                    return false;
                }

                // Switch to fallback on failure
                if ($activeDisk === $this->primaryDisk) {
                    $activeDisk = $this->fallbackDisk;
                    Log::warning("Switched to fallback storage after S3 failure");
                }
                
                sleep(1); // Wait before retry
            }
        }

        return false;
    }

    /**
     * Queue file for synchronization
     */
    protected function queueForSync(string $path): void
    {
        // Store in database or cache for later sync
        $syncQueue = cache()->get('storage_sync_queue', []);
        $syncQueue[] = [
            'path' => $path,
            'disk' => $this->fallbackDisk,
            'timestamp' => now(),
        ];
        cache()->put('storage_sync_queue', $syncQueue, 86400); // 24 hours
    }

    /**
     * Synchronize files from local to S3
     */
    public function synchronize(): array
    {
        if (!$this->isS3Available) {
            return ['success' => false, 'message' => 'S3 not available'];
        }

        $syncQueue = cache()->get('storage_sync_queue', []);
        $results = ['successful' => 0, 'failed' => 0, 'errors' => []];

        foreach ($syncQueue as $index => $file) {
            try {
                if (Storage::disk($this->fallbackDisk)->exists($file['path'])) {
                    $contents = Storage::disk($this->fallbackDisk)->get($file['path']);
                    $success = Storage::disk('s3')->put($file['path'], $contents);
                    
                    if ($success) {
                        $results['successful']++;
                        unset($syncQueue[$index]);
                    } else {
                        $results['failed']++;
                        $results['errors'][] = "Failed to sync: {$file['path']}";
                    }
                } else {
                    unset($syncQueue[$index]); // Remove non-existent files
                }
            } catch (Exception $e) {
                $results['failed']++;
                $results['errors'][] = "Error syncing {$file['path']}: " . $e->getMessage();
            }
        }

        cache()->put('storage_sync_queue', array_values($syncQueue), 86400);
        return $results;
    }

    /**
     * Check if S3 is available
     */
    public function isS3Available(): bool
    {
        return $this->isS3Available;
    }

    /**
     * Get file URL
     */
    public function url(string $path): string
    {
        try {
            if ($this->isS3Available) {
                return Storage::disk('s3')->url($path);
            }
            return Storage::disk($this->fallbackDisk)->url($path);
        } catch (Exception $e) {
            return Storage::disk($this->fallbackDisk)->url($path);
        }
    }

    /**
     * Proxy method calls to appropriate disk
     */
    public function __call($method, $args)
    {
        $activeDisk = $this->getActiveDisk();
        return Storage::disk($activeDisk)->$method(...$args);
    }
}
```

## 2. Create a Command for Synchronization

```php
<?php
// app/Console/Commands/SyncStorage.php

namespace App\Console\Commands;

use Illuminate\Console\Command;
use App\Services\StorageService;

class SyncStorage extends Command
{
    protected $signature = 'storage:sync';
    protected $description = 'Synchronize local files to S3';

    public function handle(StorageService $storageService)
    {
        if (!$storageService->isS3Available()) {
            $this->error('S3 is not available. Cannot synchronize.');
            return 1;
        }

        $this->info('Starting storage synchronization...');
        $results = $storageService->synchronize();

        $this->info("Synchronization completed:");
        $this->info("Successful: {$results['successful']}");
        $this->info("Failed: {$results['failed']}");

        if (!empty($results['errors'])) {
            $this->error("Errors:");
            foreach ($results['errors'] as $error) {
                $this->error("- {$error}");
            }
        }

        return 0;
    }
}
```

## 3. Create a Middleware for Storage Check

```php
<?php
// app/Http/Middleware/CheckStorageConnection.php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use App\Services\StorageService;

class CheckStorageConnection
{
    protected $storageService;

    public function __construct(StorageService $storageService)
    {
        $this->storageService = $storageService;
    }

    public function handle(Request $request, Closure $next)
    {
        // Check S3 connection on each request (you might want to cache this)
        $isS3Available = $this->storageService->isS3Available();
        
        // Share storage status with all views
        view()->share('s3Available', $isS3Available);
        
        return $next($request);
    }
}
```

## 4. Update Filesystem Configuration

```php
// config/filesystems.php - Update the disks array

'disks' => [
    'local' => [
        'driver' => 'local',
        'root' => storage_path('app'),
        'throw' => false,
    ],

    'public' => [
        'driver' => 'local',
        'root' => storage_path('app/public'),
        'url' => env('APP_URL').'/storage',
        'visibility' => 'public',
        'throw' => false,
    ],

    's3' => [
        'driver' => 's3',
        'key' => env('S3_KEY'),
        'secret' => env('S3_SECRET'),
        'region' => env('S3_REGION'),
        'bucket' => env('S3_BUCKET'),
        'url' => env('S3_URL'),
        'endpoint' => env('S3_ENDPOINT'),
        'use_path_style_endpoint' => env('S3_USE_PATH_STYLE', false),
        'throw' => false,
        'visibility' => 'public',
        'root' => 'instasure', // Add this to point to /instasure directory
        'options' => [
            'CacheControl' => 'max-age=31536000',
            'Metadata' => [
                'source' => 'laravel-app'
            ]
        ],
    ],

    // Add this fallback disk
    'fallback' => [
        'driver' => 'local',
        'root' => storage_path('app/instasure'),
        'url' => env('APP_URL').'/storage/instasure',
        'visibility' => 'public',
        'throw' => false,
    ],
],
```

## 5. Create a Helper Function

```php
<?php
// app/Helpers/storage.php

use App\Services\StorageService;

if (!function_exists('smart_storage')) {
    function smart_storage(): StorageService
    {
        return app(StorageService::class);
    }
}
```

## 6. Register the Service Provider

```php
<?php
// app/Providers/AppServiceProvider.php

namespace App\Providers;

use Illuminate\Support\ServiceProvider;
use App\Services\StorageService;

class AppServiceProvider extends ServiceProvider
{
    public function register()
    {
        $this->app->singleton(StorageService::class, function ($app) {
            return new StorageService();
        });
    }

    public function boot()
    {
        //
    }
}
```

## 7. Update Kernel to Include Middleware

```php
// app/Http/Kernel.php

protected $middleware = [
    // Other middleware...
    \App\Http\Middleware\CheckStorageConnection::class,
];
```

## 8. Create a Scheduled Task for Auto-Sync

```php
// app/Console/Kernel.php

protected function schedule(Schedule $schedule)
{
    $schedule->command('storage:sync')
             ->everyFiveMinutes()
             ->when(function () {
                 return app(StorageService::class)->isS3Available();
             });
}
```

## 9. Usage Examples

```php
// Store a file
$storage = smart_storage();
$success = $storage->store('user/admin/img/profile.jpg', $fileContents);

// Get file URL
$url = $storage->url('user/admin/img/profile.jpg');

// Check if file exists
$exists = $storage->exists('user/admin/img/profile.jpg');

// Delete file
$deleted = $storage->delete('user/admin/img/profile.jpg');
```

## 10. Manual Synchronization Command

Run this command to manually sync files:
```bash
php artisan storage:sync
```

## 11. Folder Structure Setup

Create the local folder structure:
```bash
mkdir -p storage/app/instasure/{user/{admin,parent_dealer,child_dealer},life_and_health/{package,order,claim},tele_medicine/{package,order},hdc/{package,order},motor_insurance/{package,order,claim},fire_insurance/{package,order,claim},theft_insurance/{package,order,claim},device_insurance/{package,order,claim},travel_insurance/{package,order,claim},cattle_insurance/{package,order,claim}}
```

This implementation provides:

1. **Automatic fallback** from S3 to local storage when S3 is unavailable
2. **Automatic retry** mechanism with configurable retry limits
3. **Synchronization queue** for files stored locally when S3 is down
4. **Scheduled synchronization** when S3 becomes available again
5. **Transparent usage** - your application code doesn't need to worry about storage availability
6. **Monitoring** through logging and error reporting
7. **Easy integration** with helper functions and service injection

The system will automatically handle storage failures and ensure data consistency between local and S3 storage.
