Yes, you're exactly right! Here's how to set it up properly:

## 1. Update Filesystem Configuration

```php
// config/filesystems.php

 'disks' => [
        'local' => [
            'driver' => 'local',
            'root' => storage_path('app'),
            'throw' => false,
        ],

        'public' => [
            'driver' => 'local',
            'root' => storage_path('app/public'),
            'url' => env('APP_URL') . '/storage',
            'visibility' => 'public',
            'throw' => false,
        ],

        's3' => [
            'driver' => 's3',
            'key' => env('S3_KEY'),
            'secret' => env('S3_SECRET'),
            'region' => env('S3_REGION'),
            'bucket' => env('S3_BUCKET'),
            'url' => env('S3_URL'),
            'endpoint' => env('S3_ENDPOINT'),
            'use_path_style_endpoint' => env('S3_USE_PATH_STYLE', false),
            'throw' => false,
            'visibility' => 'public',
            'root' => 'instasure', // Add this back to point to /instasure directory in S3
            'options' => [
                'CacheControl' => 'max-age=31536000',
                'Metadata' => [
                    'source' => 'laravel-app'
                ]
            ],
        ],

        // Add this fallback disk
        'fallback' => [
            'driver' => 'local',
            // 'root' => storage_path('app/instasure'), //storage path -> /app/storage/app/instasure/
            'root' => public_path('instasure'), // Changed to public_path /app/public/instasure/
            // 'url' => env('APP_URL') . '/storage/instasure',
            'url' => env('APP_URL') . '/instasure',
            'visibility' => 'public',
            'throw' => false,
        ],
    ],
```

## 2. Update StorageService for Public Directory Sync

```php
<?php
// app/Services/StorageService.php

namespace App\Services;

use Illuminate\Support\Facades\Storage;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Cache;
use Aws\S3\Exception\S3Exception;
use Exception;

class StorageService
{
    protected $primaryDisk;
    protected $fallbackDisk;
    protected $syncEnabled;
    protected $autoRetry;
    protected $maxRetries;
    protected $isS3Available;

    public function __construct()
    {
        $config = config('filesystems.storage_config');
        $this->primaryDisk = $config['primary_disk'];
        $this->fallbackDisk = $config['fallback_disk'];
        $this->syncEnabled = $config['sync_enabled'];
        $this->autoRetry = $config['auto_retry'];
        $this->maxRetries = $config['max_retries'];
        $this->isS3Available = $this->checkS3Connection();
    }

    /**
     * Check S3 connection with proper error handling
     */
    protected function checkS3Connection(): bool
    {
        try {
            // Use a simple operation to test connection - list files in root
            Storage::disk('s3')->files('/');
            return true;
        } catch (S3Exception $e) {
            Log::warning('S3 connection failed: ' . $e->getMessage());
            return false;
        } catch (Exception $e) {
            Log::error('Storage connection check error: ' . $e->getMessage());
            return false;
        }
    }

    /**
     * Get active disk based on availability (with real-time check)
     */
    protected function getActiveDisk(): string
    {
        // Always check S3 availability in real-time
        $this->isS3Available = $this->checkS3Connection();
        return $this->isS3Available ? $this->primaryDisk : $this->fallbackDisk;
    }

    /**
     * Store file with automatic fallback
     */
    public function store(string $path, $contents, array $options = []): bool
    {
        $activeDisk = $this->getActiveDisk();
        $retryCount = 0;

        while ($retryCount <= $this->maxRetries) {
            try {
                $success = Storage::disk($activeDisk)->put($path, $contents, $options);
                
                if ($success && $this->syncEnabled && $activeDisk === $this->fallbackDisk) {
                    $this->queueForSync($path);
                }
                
                return $success;
            } catch (Exception $e) {
                $retryCount++;
                
                if ($retryCount > $this->maxRetries || !$this->autoRetry) {
                    Log::error("Failed to store file after {$retryCount} attempts: " . $e->getMessage());
                    return false;
                }

                // Switch to fallback on failure and re-check connection
                if ($activeDisk === $this->primaryDisk) {
                    $activeDisk = $this->fallbackDisk;
                    $this->isS3Available = false;
                    Log::warning("Switched to fallback storage after S3 failure: " . $e->getMessage());
                }
                
                sleep(1); // Wait before retry
            }
        }

        return false;
    }

    /**
     * Queue file for synchronization
     */
    protected function queueForSync(string $path): void
    {
        $syncQueue = Cache::get('storage_sync_queue', []);
        
        // Avoid duplicates
        if (!in_array($path, array_column($syncQueue, 'path'))) {
            $syncQueue[] = [
                'path' => $path,
                'disk' => $this->fallbackDisk,
                'timestamp' => now(),
                'attempts' => 0,
            ];
            Cache::put('storage_sync_queue', $syncQueue, 86400); // 24 hours
        }
    }

    /**
     * Synchronize files from local to S3
     */
    public function synchronize(): array
    {
        if (!$this->checkS3Connection()) {
            return ['success' => false, 'message' => 'S3 not available'];
        }

        $syncQueue = Cache::get('storage_sync_queue', []);
        $results = ['successful' => 0, 'failed' => 0, 'errors' => []];

        foreach ($syncQueue as $index => &$file) {
            try {
                // Read from public directory
                $localPath = public_path('instasure/' . $file['path']);
                
                if (file_exists($localPath)) {
                    $contents = file_get_contents($localPath);
                    
                    // Store to S3
                    $success = Storage::disk('s3')->put($file['path'], $contents);
                    
                    if ($success) {
                        $results['successful']++;
                        unset($syncQueue[$index]);
                    } else {
                        $file['attempts']++;
                        $results['failed']++;
                        $results['errors'][] = "Failed to sync: {$file['path']} (attempt {$file['attempts']})";
                    }
                } else {
                    unset($syncQueue[$index]); // Remove non-existent files
                }
            } catch (Exception $e) {
                $file['attempts']++;
                $results['failed']++;
                $results['errors'][] = "Error syncing {$file['path']}: " . $e->getMessage();
            }
        }

        Cache::put('storage_sync_queue', array_values($syncQueue), 86400);
        return $results;
    }

    /**
     * Check if S3 is available (real-time check)
     */
    public function isS3Available(): bool
    {
        return $this->checkS3Connection();
    }

    /**
     * Force check S3 connection
     */
    public function checkConnection(): bool
    {
        $this->isS3Available = $this->checkS3Connection();
        return $this->isS3Available;
    }

    /**
     * Get file URL
     */
    public function url(string $path): string
    {
        try {
            if ($this->checkS3Connection()) {
                return Storage::disk('s3')->url($path);
            }
            // Return URL for public directory file
            return url('/instasure/' . $path);
        } catch (Exception $e) {
            return url('/instasure/' . $path);
        }
    }

    /**
     * Proxy method calls to appropriate disk
     */
    public function __call($method, $args)
    {
        $activeDisk = $this->getActiveDisk();
        return Storage::disk($activeDisk)->$method(...$args);
    }
}
```

## 3. Create the Public Directory Structure

```bash
# Create the directory structure in public folder
mkdir -p public/instasure/{user/{admin,parent_dealer,child_dealer},life_and_health/{package,order,claim},tele_medicine/{package,order},hdc/{package,order},motor_insurance/{package,order,claim},fire_insurance/{package,order,claim},theft_insurance/{package,order,claim},device_insurance/{package,order,claim},travel_insurance/{package,order,claim},cattle_insurance/{package,order,claim}}

# Set proper permissions
chmod -R 755 public/instasure/
chown -R www-data:www-data public/instasure/  # Adjust user/group as needed
```

## 4. Test the Flow

```php
// In Tinker:
$storage = app(App\Services\StorageService::class);

// Test 1: Normal S3 operation
echo "S3 Available: " . ($storage->isS3Available() ? 'Yes' : 'No');
$storage->store('user/admin/img/test.jpg', 'image content');

// Test 2: Simulate S3 failure
config(['filesystems.disks.s3.key' => 'invalid-key']);
$storage = app(App\Services\StorageService::class); // Fresh instance
echo "S3 Available after break: " . ($storage->isS3Available() ? 'Yes' : 'No');

// This should store in public/instasure/
$storage->store('life_and_health/package/pkg_img/package.jpg', 'package image content');

// Check local file exists
$localPath = public_path('instasure/life_and_health/package/pkg_img/package.jpg');
echo "Local file exists: " . (file_exists($localPath) ? 'Yes' : 'No');

// Check sync queue
$queue = Cache::get('storage_sync_queue', []);
print_r($queue);

// Test 3: Restore S3 and sync
config(['filesystems.disks.s3.key' => env('S3_KEY')]);
$results = $storage->synchronize();
print_r($results);

// Verify file is now on S3
$s3Exists = Storage::disk('s3')->exists('life_and_health/package/pkg_img/package.jpg');
echo "File on S3 after sync: " . ($s3Exists ? 'Yes' : 'No');
```

## 5. Update Nginx Configuration

Make sure nginx can serve files from the public directory:

```nginx
# In your nginx config
location /instasure/ {
    alias /var/www/html/public/instasure/;
    expires 1d;
    add_header Cache-Control "public, max-age=86400";
    add_header X-Served-By "Local-Storage";
    
    # Try files with .php extension as PHP files
    location ~ \.php$ {
        try_files $uri =404;
        fastcgi_pass app:9000;
        fastcgi_index index.php;
        include fastcgi_params;
        fastcgi_param SCRIPT_FILENAME $request_filename;
    }
}
```

## Update the nginx : 

```nginx
server {
    listen 80;
    server_name localhost 36.255.69.72;
    index index.php index.html;
    error_log  /var/log/nginx/error.log;
    access_log /var/log/nginx/access.log;
    root /var/www/html/public;

    # Basic Laravel configuration
    location / {
        try_files $uri $uri/ /index.php?$query_string;
    }

    # PHP-FPM configuration
    location ~ \.php$ {
        try_files $uri =404;
        fastcgi_split_path_info ^(.+\.php)(/.+)$;
        fastcgi_pass app:9000;
        fastcgi_index index.php;
        include fastcgi_params;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        fastcgi_param PATH_INFO $fastcgi_path_info;
        
        # Increase timeouts for file uploads
        fastcgi_read_timeout 300;
        fastcgi_connect_timeout 300;
        fastcgi_send_timeout 300;
    }

    # Handle static files locally first, then S3
    location ~* \.(jpg|jpeg|png|gif|ico|css|js|svg|woff|woff2|ttf|eot)$ {
        try_files $uri @s3_fallback;
        expires 1y;
        add_header Cache-Control "public, immutable";
        add_header X-Served-By "Local-Static";
    }

    # S3 fallback for static files
    location @s3_fallback {
        proxy_pass https://s3.brilliant.com.bd/instasure/public$uri;
        proxy_ssl_verify off;
        proxy_ssl_server_name on;
        proxy_set_header Host s3.brilliant.com.bd;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        add_header Cache-Control "public, max-age=31536000, immutable";
        add_header X-Served-By "S3-Fallback";
        
        # If S3 also fails, return 404
        proxy_intercept_errors on;
        error_page 404 = @final_404;
    }

    # Handle instasure files from local public directory
    location ~* ^/instasure/(.+)$ {
        # First try local file in public/instasure directory
        try_files /instasure/$1 @s3_instasure;
        expires 1d;
        add_header Cache-Control "public, max-age=86400";
        add_header X-Served-By "Local-Instasure";
    }

    # S3 fallback for instasure files
    location @s3_instasure {
        proxy_pass https://s3.brilliant.com.bd/instasure/$1;
        proxy_ssl_verify off;
        proxy_ssl_server_name on;
        proxy_set_header Host s3.brilliant.com.bd;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        add_header Cache-Control "public, max-age=86400";
        add_header X-Served-By "S3-Instasure";
        
        # If S3 fails, try to serve from local if exists
        proxy_intercept_errors on;
        error_page 404 500 502 503 504 = @local_instasure_fallback;
    }

    # Final fallback to local instasure file
    location @local_instasure_fallback {
        # Try to serve the local file if it exists
        try_files /instasure/$1 =404;
        expires 1d;
        add_header Cache-Control "public, max-age=86400";
        add_header X-Served-By "Local-Instasure-Fallback";
    }

    # Handle storage files from S3 with local fallback
    location ~* ^/storage/(.+)$ {
        # First try local storage
        try_files /storage/$1 @s3_storage;
        expires 1d;
        add_header Cache-Control "public, max-age=86400";
        add_header X-Served-By "Local-Storage";
    }

    # S3 storage fallback
    location @s3_storage {
        proxy_pass https://s3.brilliant.com.bd/instasure/storage/$1;
        proxy_ssl_verify off;
        proxy_ssl_server_name on;
        proxy_set_header Host s3.brilliant.com.bd;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        add_header Cache-Control "public, max-age=86400";
        add_header X-Served-By "S3-Storage";
    }

    # Final 404 handler
    location @final_404 {
        return 404;
    }

    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header Referrer-Policy "no-referrer-when-downgrade" always;
    add_header Content-Security-Policy "default-src 'self' http: https: data: blob: 'unsafe-inline'" always;

    # Hide nginx version
    server_tokens off;

    # Deny access to hidden files
    location ~ /\. {
        deny all;
    }

    # File upload size
    client_max_body_size 100M;
}
```

## The Complete Flow:

1. **S3 Available**: Files stored directly to S3 at `/instasure/path/to/file`
2. **S3 Unavailable**: Files stored locally at `/app/public/instasure/path/to/file`
3. **File added to sync queue** for later synchronization
4. **S3 Available Again**: Run synchronization to copy files from `/app/public/instasure/` to S3 `/instasure/`
5. **URL Generation**: Always returns the appropriate URL (S3 if available, local if not)

This setup ensures that your application remains functional during S3 outages while maintaining data consistency through automatic synchronization.
