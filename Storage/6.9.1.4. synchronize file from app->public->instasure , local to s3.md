Yes, you're exactly right! Here's how to set it up properly:

## 1. Update Filesystem Configuration

```php
// config/filesystems.php

'disks' => [
    // ... other disks

    's3' => [
        'driver' => 's3',
        'key' => env('S3_KEY'),
        'secret' => env('S3_SECRET'),
        'region' => env('S3_REGION'),
        'bucket' => env('S3_BUCKET'),
        'url' => env('S3_URL'),
        'endpoint' => env('S3_ENDPOINT'),
        'use_path_style_endpoint' => env('S3_USE_PATH_STYLE', false),
        'throw' => false,
        'visibility' => 'public',
        'root' => 'instasure', // S3 files go to /instasure/ folder
    ],

    'fallback' => [
        'driver' => 'local',
        'root' => public_path('instasure'), // Local files go to /app/public/instasure/
        'url' => env('APP_URL').'/instasure', // URL for accessing local files
        'visibility' => 'public',
        'throw' => false,
    ],
],
```

## 2. Update StorageService for Public Directory Sync

```php
<?php
// app/Services/StorageService.php

namespace App\Services;

use Illuminate\Support\Facades\Storage;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Cache;
use Aws\S3\Exception\S3Exception;
use Exception;

class StorageService
{
    // ... other properties and methods

    /**
     * Synchronize files from local public directory to S3
     */
    public function synchronize(): array
    {
        if (!$this->checkS3Connection()) {
            return ['success' => false, 'message' => 'S3 not available'];
        }

        $syncQueue = Cache::get('storage_sync_queue', []);
        $results = ['successful' => 0, 'failed' => 0, 'errors' => []];

        foreach ($syncQueue as $index => &$file) {
            try {
                // Read from public directory
                $localPath = public_path('instasure/' . $file['path']);
                
                if (file_exists($localPath)) {
                    $contents = file_get_contents($localPath);
                    
                    // Store to S3
                    $success = Storage::disk('s3')->put($file['path'], $contents);
                    
                    if ($success) {
                        $results['successful']++;
                        unset($syncQueue[$index]);
                        
                        // Optional: Delete local file after successful sync
                        // unlink($localPath);
                    } else {
                        $file['attempts']++;
                        $results['failed']++;
                        $results['errors'][] = "Failed to sync: {$file['path']} (attempt {$file['attempts']})";
                    }
                } else {
                    unset($syncQueue[$index]); // Remove non-existent files
                }
            } catch (Exception $e) {
                $file['attempts']++;
                $results['failed']++;
                $results['errors'][] = "Error syncing {$file['path']}: " . $e->getMessage();
            }
        }

        Cache::put('storage_sync_queue', array_values($syncQueue), 86400);
        return $results;
    }

    /**
     * Get file URL - returns S3 URL if available, local URL if not
     */
    public function url(string $path): string
    {
        try {
            if ($this->checkS3Connection()) {
                return Storage::disk('s3')->url($path);
            }
            // Return URL for public directory file
            return url('/instasure/' . $path);
        } catch (Exception $e) {
            return url('/instasure/' . $path);
        }
    }

    // ... rest of the class
}
```

## 3. Create the Public Directory Structure

```bash
# Create the directory structure in public folder
mkdir -p public/instasure/{user/{admin,parent_dealer,child_dealer},life_and_health/{package,order,claim},tele_medicine/{package,order},hdc/{package,order},motor_insurance/{package,order,claim},fire_insurance/{package,order,claim},theft_insurance/{package,order,claim},device_insurance/{package,order,claim},travel_insurance/{package,order,claim},cattle_insurance/{package,order,claim}}

# Set proper permissions
chmod -R 755 public/instasure/
chown -R www-data:www-data public/instasure/  # Adjust user/group as needed
```

## 4. Test the Flow

```php
// In Tinker:
$storage = app(App\Services\StorageService::class);

// Test 1: Normal S3 operation
echo "S3 Available: " . ($storage->isS3Available() ? 'Yes' : 'No');
$storage->store('user/admin/img/test.jpg', 'image content');

// Test 2: Simulate S3 failure
config(['filesystems.disks.s3.key' => 'invalid-key']);
$storage = app(App\Services\StorageService::class); // Fresh instance
echo "S3 Available after break: " . ($storage->isS3Available() ? 'Yes' : 'No');

// This should store in public/instasure/
$storage->store('life_and_health/package/pkg_img/package.jpg', 'package image content');

// Check local file exists
$localPath = public_path('instasure/life_and_health/package/pkg_img/package.jpg');
echo "Local file exists: " . (file_exists($localPath) ? 'Yes' : 'No');

// Check sync queue
$queue = Cache::get('storage_sync_queue', []);
print_r($queue);

// Test 3: Restore S3 and sync
config(['filesystems.disks.s3.key' => env('S3_KEY')]);
$results = $storage->synchronize();
print_r($results);

// Verify file is now on S3
$s3Exists = Storage::disk('s3')->exists('life_and_health/package/pkg_img/package.jpg');
echo "File on S3 after sync: " . ($s3Exists ? 'Yes' : 'No');
```

## 5. Update Nginx Configuration

Make sure nginx can serve files from the public directory:

```nginx
# In your nginx config
location /instasure/ {
    alias /var/www/html/public/instasure/;
    expires 1d;
    add_header Cache-Control "public, max-age=86400";
    add_header X-Served-By "Local-Storage";
    
    # Try files with .php extension as PHP files
    location ~ \.php$ {
        try_files $uri =404;
        fastcgi_pass app:9000;
        fastcgi_index index.php;
        include fastcgi_params;
        fastcgi_param SCRIPT_FILENAME $request_filename;
    }
}
```

## The Complete Flow:

1. **S3 Available**: Files stored directly to S3 at `/instasure/path/to/file`
2. **S3 Unavailable**: Files stored locally at `/app/public/instasure/path/to/file`
3. **File added to sync queue** for later synchronization
4. **S3 Available Again**: Run synchronization to copy files from `/app/public/instasure/` to S3 `/instasure/`
5. **URL Generation**: Always returns the appropriate URL (S3 if available, local if not)

This setup ensures that your application remains functional during S3 outages while maintaining data consistency through automatic synchronization.
