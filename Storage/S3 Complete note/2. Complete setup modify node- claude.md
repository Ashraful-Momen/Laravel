# Complete S3 Storage Implementation Guide with Local Fallback

## Overview
This guide implements a robust storage system that uses S3 as primary storage with automatic fallback to local storage when S3 is unavailable. The system includes automatic synchronization of local files to S3 when the connection is restored.

## Architecture Features
- **Primary Storage**: S3 bucket
- **Fallback Storage**: Local disk (public directory)
- **Auto-retry mechanism**: Configurable retry attempts
- **Queue-based synchronization**: Syncs local files to S3 when available
- **Real-time connection checking**: Verifies S3 availability
- **Middleware integration**: Shares storage status across the application

---

## Step 1: Environment Configuration

### 1.1 Update `.env` File
Add these S3 configuration variables to your `.env` file:

```env
# Filesystem Configuration
FILESYSTEM_DRIVER=s3

# S3 Configuration
S3_KEY=YOUR_ACCESS_KEY_HERE
S3_SECRET=YOUR_SECRET_KEY_HERE
S3_REGION=us-east-1
S3_BUCKET=instasure
S3_URL=https://s3.brilliant.com.bd/instasure
S3_ENDPOINT=https://s3.brilliant.com.bd
S3_USE_PATH_STYLE=true

# Storage Configuration
STORAGE_PRIMARY=s3
STORAGE_FALLBACK=fallback
STORAGE_SYNC_ENABLED=true
STORAGE_AUTO_RETRY=true
STORAGE_MAX_RETRIES=3
```

### 1.2 Docker Stack Configuration
If using Docker Swarm, ensure your `docker-stack.yml` includes all S3 environment variables:

```yaml
environment:
  # S3 Configuration
  - FILESYSTEM_DRIVER=s3
  - S3_KEY=${S3_KEY}
  - S3_SECRET=${S3_SECRET}
  - S3_REGION=us-east-1
  - S3_BUCKET=instasure
  - S3_URL=https://s3.brilliant.com.bd/instasure
  - S3_ENDPOINT=https://s3.brilliant.com.bd
  - S3_USE_PATH_STYLE=true
  
  # Storage Configuration
  - STORAGE_PRIMARY=s3
  - STORAGE_FALLBACK=fallback
  - STORAGE_SYNC_ENABLED=true
  - STORAGE_AUTO_RETRY=true
  - STORAGE_MAX_RETRIES=3
```

---

## Step 2: Configure Filesystems

### 2.1 Update `config/filesystems.php`

```php
<?php

return [
    'default' => env('FILESYSTEM_DRIVER', 's3'),
    'cloud' => env('FILESYSTEM_CLOUD', 's3'),

    'disks' => [
        'local' => [
            'driver' => 'local',
            'root' => storage_path('app'),
            'throw' => false,
        ],

        'public' => [
            'driver' => 'local',
            'root' => storage_path('app/public'),
            'url' => env('APP_URL') . '/storage',
            'visibility' => 'public',
            'throw' => false,
        ],

        's3' => [
            'driver' => 's3',
            'key' => env('S3_KEY'),
            'secret' => env('S3_SECRET'),
            'region' => env('S3_REGION'),
            'bucket' => env('S3_BUCKET'),
            'url' => env('S3_URL'),
            'endpoint' => env('S3_ENDPOINT'),
            'use_path_style_endpoint' => env('S3_USE_PATH_STYLE', false),
            'throw' => false,
            'visibility' => 'public',
            'root' => 'instasure', // S3 subdirectory
            'options' => [
                'CacheControl' => 'max-age=31536000',
                'Metadata' => [
                    'source' => 'laravel-app'
                ]
            ],
        ],

        // Fallback disk configuration
        'fallback' => [
            'driver' => 'local',
            'root' => public_path('instasure'), // Files stored in /public/instasure/
            'url' => env('APP_URL') . '/instasure',
            'visibility' => 'public',
            'throw' => false,
        ],
    ],

    // Storage behavior configuration
    'storage_config' => [
        'primary_disk' => env('STORAGE_PRIMARY', 's3'),
        'fallback_disk' => env('STORAGE_FALLBACK', 'fallback'),
        'sync_enabled' => env('STORAGE_SYNC_ENABLED', true),
        'auto_retry' => env('STORAGE_AUTO_RETRY', true),
        'max_retries' => env('STORAGE_MAX_RETRIES', 3),
    ],
];
```

---

## Step 3: Create Storage Service

### 3.1 Create `app/Services/StorageService.php`

This service handles all storage operations with automatic fallback:

```php
<?php

namespace App\Services;

use Illuminate\Support\Facades\Storage;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Cache;
use Aws\S3\Exception\S3Exception;
use Exception;

class StorageService
{
    protected $primaryDisk;
    protected $fallbackDisk;
    protected $syncEnabled;
    protected $autoRetry;
    protected $maxRetries;
    protected $isS3Available;

    public function __construct()
    {
        $config = config('filesystems.storage_config');
        $this->primaryDisk = $config['primary_disk'];
        $this->fallbackDisk = $config['fallback_disk'];
        $this->syncEnabled = $config['sync_enabled'];
        $this->autoRetry = $config['auto_retry'];
        $this->maxRetries = $config['max_retries'];
        $this->isS3Available = $this->checkS3Connection();
    }

    /**
     * Check S3 connection with proper error handling
     */
    protected function checkS3Connection(): bool
    {
        try {
            Storage::disk('s3')->files('/');
            return true;
        } catch (S3Exception $e) {
            Log::warning('S3 connection failed: ' . $e->getMessage());
            return false;
        } catch (Exception $e) {
            Log::error('Storage connection check error: ' . $e->getMessage());
            return false;
        }
    }

    /**
     * Get active disk based on availability
     */
    protected function getActiveDisk(): string
    {
        $this->isS3Available = $this->checkS3Connection();
        $disk = $this->isS3Available ? $this->primaryDisk : $this->fallbackDisk;
        
        Log::info("Active disk: {$disk} (S3 available: " . ($this->isS3Available ? 'YES' : 'NO') . ")");
        
        return $disk;
    }

    /**
     * Store file with automatic fallback
     */
    public function store(string $path, $contents, array $options = []): bool
    {
        $activeDisk = $this->getActiveDisk();
        $retryCount = 0;

        while ($retryCount <= $this->maxRetries) {
            try {
                $success = Storage::disk($activeDisk)->put($path, $contents, $options);

                if ($success) {
                    Log::info("File stored successfully on {$activeDisk}: {$path}");
                    
                    if ($this->syncEnabled && $activeDisk === $this->fallbackDisk) {
                        $this->queueForSync($path);
                    }
                    return true;
                }

            } catch (Exception $e) {
                Log::error("Storage failed on {$activeDisk}: " . $e->getMessage());
                
                // Manual fallback for local storage
                if ($activeDisk === $this->fallbackDisk) {
                    try {
                        $localPath = public_path('instasure/' . $path);
                        $directory = dirname($localPath);

                        if (!is_dir($directory)) {
                            mkdir($directory, 0755, true);
                        }

                        if (file_put_contents($localPath, $contents) !== false) {
                            chmod($localPath, 0644);
                            Log::info("Manual file creation successful: {$localPath}");
                            
                            if ($this->syncEnabled) {
                                $this->queueForSync($path);
                            }
                            return true;
                        }
                    } catch (Exception $manualException) {
                        Log::error("Manual file creation failed: " . $manualException->getMessage());
                    }
                }

                $retryCount++;
                if ($retryCount > $this->maxRetries) {
                    return false;
                }

                // Switch to fallback on primary failure
                if ($activeDisk === $this->primaryDisk) {
                    $activeDisk = $this->fallbackDisk;
                    $this->isS3Available = false;
                }

                sleep(1); // Wait before retry
            }
        }

        return false;
    }

    /**
     * Queue file for synchronization
     */
    protected function queueForSync(string $path): void
    {
        $syncQueue = Cache::get('storage_sync_queue', []);
        
        if (!in_array($path, array_column($syncQueue, 'path'))) {
            $syncQueue[] = [
                'path' => $path,
                'disk' => $this->fallbackDisk,
                'timestamp' => now(),
                'attempts' => 0,
            ];
            Cache::put('storage_sync_queue', $syncQueue, 86400); // 24 hours
        }
    }

    /**
     * Synchronize files from local to S3
     */
    public function synchronize(): array
    {
        if (!$this->checkS3Connection()) {
            return ['success' => false, 'message' => 'S3 not available'];
        }

        $syncQueue = Cache::get('storage_sync_queue', []);
        $results = ['successful' => 0, 'failed' => 0, 'errors' => []];

        foreach ($syncQueue as $index => &$file) {
            try {
                $localPath = public_path('instasure/' . $file['path']);

                if (file_exists($localPath)) {
                    $contents = file_get_contents($localPath);
                    
                    if (Storage::disk('s3')->put($file['path'], $contents)) {
                        $results['successful']++;
                        unset($syncQueue[$index]);
                        Log::info("Synced to S3: {$file['path']}");
                    } else {
                        $file['attempts']++;
                        $results['failed']++;
                        $results['errors'][] = "Failed to sync: {$file['path']}";
                    }
                } else {
                    unset($syncQueue[$index]); // Remove non-existent files
                }
            } catch (Exception $e) {
                $file['attempts']++;
                $results['failed']++;
                $results['errors'][] = "Error syncing {$file['path']}: " . $e->getMessage();
            }
        }

        Cache::put('storage_sync_queue', array_values($syncQueue), 86400);
        return $results;
    }

    /**
     * Check if S3 is available
     */
    public function isS3Available(): bool
    {
        return $this->checkS3Connection();
    }

    /**
     * Get file URL
     */
    public function url(string $path): string
    {
        try {
            if ($this->checkS3Connection()) {
                return Storage::disk('s3')->url($path);
            }
            return url('/instasure/' . $path);
        } catch (Exception $e) {
            return url('/instasure/' . $path);
        }
    }

    /**
     * Proxy method calls to appropriate disk
     */
    public function __call($method, $args)
    {
        $activeDisk = $this->getActiveDisk();
        return Storage::disk($activeDisk)->$method(...$args);
    }
}
```

---

## Step 4: Register Service Provider

### 4.1 Update `app/Providers/AppServiceProvider.php`

```php
<?php

namespace App\Providers;

use Illuminate\Support\Facades\Schema;
use Illuminate\Support\ServiceProvider;
use App\Services\StorageService;

class AppServiceProvider extends ServiceProvider
{
    public function register()
    {
        // Register StorageService as singleton
        $this->app->singleton(StorageService::class, function ($app) {
            return new StorageService();
        });
    }

    public function boot()
    {
        Schema::defaultStringLength(191);
        date_default_timezone_set('Asia/Dhaka');
    }
}
```

---

## Step 5: Create Middleware

### 5.1 Create `app/Http/Middleware/CheckStorageConnection.php`

```php
<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;
use App\Services\StorageService;

class CheckStorageConnection
{
    protected $storageService;

    public function __construct(StorageService $storageService)
    {
        $this->storageService = $storageService;
    }

    public function handle(Request $request, Closure $next)
    {
        // Check S3 connection and share with views
        $isS3Available = $this->storageService->isS3Available();
        view()->share('s3Available', $isS3Available);
        
        return $next($request);
    }
}
```

### 5.2 Register Middleware in `app/Http/Kernel.php`

```php
protected $middleware = [
    // Other middleware...
    \App\Http\Middleware\CheckStorageConnection::class,
];
```

---

## Step 6: Create Helper Function

### 6.1 Create `app/Helpers/storage.php`

```php
<?php

use App\Services\StorageService;

if (!function_exists('smart_storage')) {
    function smart_storage(): StorageService
    {
        return app(StorageService::class);
    }
}
```

### 6.2 Update `composer.json` Autoload

```json
"autoload": {
    "files": [
        "app/Helpers/storage.php"
    ],
    "psr-4": {
        "App\\": "app/",
        "Database\\Factories\\": "database/factories/",
        "Database\\Seeders\\": "database/seeders/"
    }
}
```

Run `composer dump-autoload` after this change.

---

## Step 7: Create Sync Command

### 7.1 Create `app/Console/Commands/SyncStorage.php`

```php
<?php

namespace App\Console\Commands;

use Illuminate\Console\Command;
use App\Services\StorageService;

class SyncStorage extends Command
{
    protected $signature = 'storage:sync';
    protected $description = 'Synchronize local files to S3';

    public function handle(StorageService $storageService)
    {
        if (!$storageService->isS3Available()) {
            $this->error('S3 is not available. Cannot synchronize.');
            return 1;
        }

        $this->info('Starting storage synchronization...');
        $results = $storageService->synchronize();

        $this->info("Synchronization completed:");
        $this->info("Successful: {$results['successful']}");
        $this->info("Failed: {$results['failed']}");

        if (!empty($results['errors'])) {
            $this->error("Errors:");
            foreach ($results['errors'] as $error) {
                $this->error("- {$error}");
            }
        }

        return 0;
    }
}
```

---

## Step 8: Schedule Synchronization

### 8.1 Update `app/Console/Kernel.php`

```php
<?php

namespace App\Console;

use Illuminate\Console\Scheduling\Schedule;
use Illuminate\Foundation\Console\Kernel as ConsoleKernel;
use App\Services\StorageService;

class Kernel extends ConsoleKernel
{
    protected function schedule(Schedule $schedule)
    {
        // Sync storage every minute when S3 is available
        $schedule->command('storage:sync')
            ->everyMinute()
            ->when(function () {
                return app(StorageService::class)->isS3Available();
            });
    }

    protected function commands()
    {
        $this->load(__DIR__ . '/Commands');
        require base_path('routes/console.php');
    }
}
```

---

## Step 9: Docker Scheduler Service

### 9.1 Add Scheduler Service to `docker-stack.yml`

```yaml
scheduler:
  image: instasure-dockerized_app:latest
  deploy:
    replicas: 1   # Always just ONE scheduler
    restart_policy:
      condition: on-failure
  working_dir: /var/www/html
  command: >
    sh -c "while true; do 
      php artisan schedule:run >> /var/www/html/storage/logs/cron.log 2>&1; 
      sleep 60; 
    done"
  volumes:
    - /home/ashraful/gitlab_project/instasure-dockerized:/var/www/html
    - /home/ashraful/gitlab_project/instasure-dockerized/docker/php/local.ini:/usr/local/etc/php/conf.d/local.ini
  networks:
    - laravel_network
  depends_on:
    - mysql
    - redis
  environment:
    # Include all S3 and storage environment variables
    - FILESYSTEM_DRIVER=s3
    - S3_KEY=${S3_KEY}
    - S3_SECRET=${S3_SECRET}
    # ... other environment variables
```

---

## Step 10: Implementation in Controllers

### 10.1 Example Usage in Controller

```php
use App\Services\StorageService;

public function profileUpdate(Request $request)
{
    $user = User::find(Auth::id());
    
    if ($request->hasFile('avatar_original')) {
        try {
            $file = $request->file('avatar_original');
            $originalName = $file->getClientOriginalName();
            
            // Use StorageService
            $storageService = new StorageService();
            $filePath = 'profile/img/' . uniqid() . '_' . $originalName;
            
            if ($storageService->store($filePath, file_get_contents($file->getRealPath()))) {
                $user->avatar_original = $filePath;
                $user->save();
                
                Log::info('Profile image saved: ' . $filePath);
                
                // Log storage location
                if ($storageService->isS3Available()) {
                    Log::info('Stored on S3: ' . $storageService->url($filePath));
                } else {
                    Log::info('Stored locally (S3 unavailable): ' . $storageService->url($filePath));
                }
                
                return response()->json([
                    'success' => true,
                    'message' => 'Profile updated successfully',
                    'avatar_url' => $storageService->url($filePath)
                ]);
            }
            
        } catch (Exception $e) {
            Log::error('Error uploading profile image: ' . $e->getMessage());
            return response()->json(['error' => 'Upload failed'], 500);
        }
    }
}
```

### 10.2 Using Helper Function

```php
// Using the helper function
$stored = smart_storage()->store('path/to/file.jpg', $contents);
$url = smart_storage()->url('path/to/file.jpg');
$exists = smart_storage()->exists('path/to/file.jpg');
```

---

## Step 11: View Implementation

### 11.1 Display Images in Blade Templates

```blade
{{-- Check S3 availability (shared via middleware) --}}
@if($s3Available)
    <img src="{{ Storage::disk('s3')->url($user->avatar_original) }}" 
         alt="Profile" class="img-thumbnail" />
@else
    <img src="{{ url('/instasure/' . $user->avatar_original) }}" 
         alt="Profile" class="img-thumbnail" />
@endif

{{-- Or using the service --}}
@php
    $storageService = app(\App\Services\StorageService::class);
@endphp
<img src="{{ $storageService->url($user->avatar_original) }}" 
     alt="Profile" class="img-thumbnail" />
```

---

## Step 12: Permissions Setup

### 12.1 Directory Permissions

Ensure proper permissions for the fallback storage directory:

```bash
# Create directory if it doesn't exist
mkdir -p public/instasure

# Set permissions
chmod -R 755 public/instasure

# Set ownership (adjust user as needed)
chown -R www-data:www-data public/instasure
```

### 12.2 Docker Container Permissions

In Docker, ensure the web user has write permissions:

```dockerfile
# In Dockerfile
RUN mkdir -p /var/www/html/public/instasure \
    && chown -R www-data:www-data /var/www/html/public/instasure \
    && chmod -R 755 /var/www/html/public/instasure
```

---

## Step 13: Testing

### 13.1 Test S3 Connection

```bash
# Access container
docker exec -it $(docker ps -qf "name=laravel_app") bash

# Test with Tinker
php artisan tinker
```

```php
// In Tinker
Storage::disk('s3')->exists('/');
// Should return true if S3 is connected

// List S3 files
Storage::disk('s3')->allFiles('');

// Test fallback
Storage::disk('fallback')->put('test.txt', 'Hello World');

// Check sync queue
Cache::get('storage_sync_queue');
```

### 13.2 Manual Sync Test

```bash
# Run sync manually
php artisan storage:sync
```

### 13.3 Test File Upload

```php
// Test upload with service
$storageService = new \App\Services\StorageService();
$result = $storageService->store('test/file.txt', 'Test content');
echo $result ? 'Success' : 'Failed';
```

---

## Step 14: Monitoring and Logs

### 14.1 Check Laravel Logs

```bash
# View storage logs
tail -f storage/logs/laravel.log

# View cron logs (for scheduled sync)
tail -f storage/logs/cron.log
```

### 14.2 Monitor Sync Queue

```php
// Check pending sync items
php artisan tinker
Cache::get('storage_sync_queue');
```

---

## Step 15: Troubleshooting

### Common Issues and Solutions

#### 1. **S3 Connection Fails**
- Verify S3 credentials in `.env`
- Check S3 endpoint URL
- Ensure bucket exists
- Check network connectivity

#### 2. **Local Storage Permission Denied**
```bash
# Fix permissions
chmod -R 755 public/instasure
chown -R www-data:www-data public/instasure
```

#### 3. **Files Not Syncing**
- Check if scheduler is running
- Verify S3 connection: `php artisan storage:sync`
- Check sync queue: `Cache::get('storage_sync_queue')`
- Review logs for errors

#### 4. **Middleware Not Working**
- Clear config cache: `php artisan config:clear`
- Check if middleware is registered in Kernel.php
- Verify service provider registration

#### 5. **Helper Function Not Found**
```bash
composer dump-autoload
```

---

## Best Practices

1. **Always use the StorageService** for file operations instead of direct Storage facade
2. **Monitor sync queue** regularly to ensure files are being synchronized
3. **Set up alerts** for S3 connection failures
4. **Implement cleanup** for old local files after successful sync
5. **Use environment-specific** configurations for different environments
6. **Test failover scenarios** regularly
7. **Keep logs** of all storage operations for debugging
8. **Implement file validation** before storage
9. **Use appropriate file paths** structure for organization
10. **Regular backups** of both S3 and local storage

---

## Security Considerations

1. **Never commit credentials** to version control
2. **Use IAM roles** for S3 access in production
3. **Implement rate limiting** for file uploads
4. **Validate file types** and sizes
5. **Scan for malware** in uploaded files
6. **Use HTTPS** for S3 endpoints
7. **Implement access controls** for stored files
8. **Regular security audits** of storage permissions

---

## Performance Optimization

1. **Cache S3 availability status** for a short duration
2. **Use queue workers** for large file operations
3. **Implement chunked uploads** for large files
4. **CDN integration** for frequently accessed files
5. **Compress files** before storage when appropriate
6. **Lazy loading** for images in views
7. **Implement pagination** for file listings
8. **Use database indexing** for file metadata

---

## Conclusion

This implementation provides a robust, fault-tolerant storage system that ensures your application continues to function even when S3 is unavailable. The automatic synchronization ensures that files are eventually consistent across both storage systems, providing reliability and redundancy for your application's file storage needs.
